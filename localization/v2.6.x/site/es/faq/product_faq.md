---
id: product_faq.md
summary: >-
  Encuentre respuestas a las preguntas más frecuentes sobre la base de datos
  vectorial más avanzada del mundo.
title: Preguntas frecuentes sobre el producto
---
<h1 id="Product-FAQ" class="common-anchor-header">Preguntas frecuentes sobre el producto<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">¿Cuánto cuesta Milvus?</h4><p>Milvus es un proyecto de código abierto 100% gratuito.</p>
<p>Por favor, adhiérase a <a href="http://www.apache.org/licenses/LICENSE-2.0">la Licencia Apache 2.0</a> cuando utilice Milvus con fines de producción o distribución.</p>
<p>Zilliz, la empresa que está detrás de Milvus, también ofrece una versión en la nube totalmente gestionada de la plataforma para aquellos que no quieran construir y mantener su propia instancia distribuida. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> mantiene automáticamente la fiabilidad de los datos y permite a los usuarios pagar sólo por lo que utilizan.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">¿Es Milvus compatible con arquitecturas que no sean x86?</h4><p>Milvus no puede instalarse ni ejecutarse en plataformas que no sean x86.</p>
<p>Su CPU debe soportar uno de los siguientes conjuntos de instrucciones para ejecutar Milvus: SSE4.2, AVX, AVX2, AVX512. Todos ellos son conjuntos de instrucciones SIMD dedicados a x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">¿Dónde almacena Milvus los datos?</h4><p>Milvus maneja dos tipos de datos, los datos insertados y los metadatos.</p>
<p>Los datos insertados, incluidos los datos vectoriales, los datos escalares y el esquema específico de la colección, se almacenan en el almacenamiento persistente como registro incremental. Milvus es compatible con múltiples backends de almacenamiento de objetos, incluidos <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> y <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Los metadatos se generan dentro de Milvus. Cada módulo de Milvus tiene sus propios metadatos que se almacenan en etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">¿Por qué no hay datos vectoriales en etcd?</h4><p>etcd almacena los metadatos del módulo Milvus; MinIO almacena las entidades.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">¿Milvus permite insertar y buscar datos simultáneamente?</h4><p>Sí. Las operaciones de inserción y las operaciones de consulta son gestionadas por dos módulos separados que son mutuamente independientes. Desde la perspectiva del cliente, una operación de inserción se completa cuando los datos insertados entran en la cola de mensajes. Sin embargo, los datos insertados no se pueden buscar hasta que se cargan en el nodo de consulta. Para segmentos crecientes con datos incrementales, Milvus construye automáticamente índices provisionales para garantizar un rendimiento de búsqueda eficiente, incluso cuando el tamaño del segmento no alcanza el umbral de construcción de índices, calculado como <code translate="no">dataCoord.segment.maxSize</code> × <code translate="no">dataCoord.segment.sealProportion</code>. Puede controlar este comportamiento a través del parámetro de configuración <code translate="no">queryNode.segcore.interimIndex.enableIndex</code> en el <a href="https://github.com/milvus-io/milvus/blob/master/configs/milvus.yaml#L440">archivo de configuración de Milvus</a> - fijándolo en <code translate="no">true</code> activa la indexación temporal (por defecto) mientras que fijándolo en <code translate="no">false</code> la desactiva.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">¿Pueden insertarse en Milvus vectores con claves primarias duplicadas?</h4><p>Sí. Milvus no comprueba si las claves primarias de los vectores están duplicadas.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Cuando se insertan vectores con claves primarias duplicadas, ¿Milvus lo trata como una operación de actualización?</h4><p>No. Milvus no soporta actualmente operaciones de actualización y no comprueba si las claves primarias de entidad son duplicadas. Usted es responsable de asegurar que las claves primarias de las entidades son únicas, y si no lo son Milvus puede contener múltiples entidades con claves primarias duplicadas.</p>
<p>Si esto ocurre, qué copia de datos devolverá cuando se consulte sigue siendo un comportamiento desconocido. Esta limitación se corregirá en futuras versiones.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">¿Cuál es la longitud máxima de las claves primarias de entidad autodefinidas?</h4><p>Las claves primarias de entidad deben ser enteros no negativos de 64 bits.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">¿Cuál es la cantidad máxima de datos que se pueden añadir por operación de inserción?</h4><p>Una operación de inserción no debe superar los 1.024 MB. Se trata de un límite impuesto por gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">¿Influye el tamaño de la colección en el rendimiento de la consulta cuando se busca en una partición específica?</h4><p>No. Si se especifican particiones para una búsqueda, Milvus sólo busca en las particiones especificadas.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">¿Necesita Milvus cargar toda la colección cuando se especifican particiones para una búsqueda?</h4><p>Depende de los datos que se necesiten para la búsqueda. Todas las particiones que puedan aparecer en el resultado de la búsqueda deben cargarse antes de buscar.</p>
<ul>
<li>Por ejemplo, si sólo quiere buscar en una(s) partición(es) específica(s), no necesita cargarlas todas. Llame a <code translate="no">load_partition()</code> para cargar la(s) partición(es) deseada(s) <em>y luego</em> especifique la(s) partición(es) en la llamada al método <code translate="no">search()</code>.</li>
<li>Si desea buscar en todas las particiones, llame a <code translate="no">load_collection()</code> para cargar toda la colección incluyendo todas las particiones.</li>
<li>Si no carga la colección o la(s) partición(es) específica(s) antes de buscar, Milvus devolverá un error.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">¿Se pueden crear índices después de insertar vectores?</h4><p>Sí. Si antes se ha creado un índice para una colección mediante <code translate="no">create_index()</code>, Milvus creará automáticamente un índice para los vectores insertados posteriormente. Sin embargo, Milvus no construye un índice hasta que los vectores recién insertados llenan un segmento entero y el archivo de índice recién creado está separado del anterior.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">¿En qué se diferencian los índices FLAT e IVF_FLAT?</h4><p>El índice IVF_FLAT divide el espacio vectorial en grupos de listas. Con el valor de lista por defecto de 16.384, Milvus compara las distancias entre el vector objetivo y los centroides de todos los 16.384 clusters para devolver los clusters más cercanos a la sonda. Milvus compara entonces las distancias entre el vector objetivo y los vectores en los clusters seleccionados para obtener los vectores más cercanos. A diferencia de IVF_FLAT, FLAT compara directamente las distancias entre el vector objetivo y cualquier otro vector.</p>
<p>Cuando el número total de vectores es aproximadamente igual a nlist, hay poca distancia entre IVF_FLAT y FLAT en términos de requisitos de cálculo y rendimiento de búsqueda. Sin embargo, a medida que el número de vectores supera nlist por un factor de dos o más, IVF_FLAT comienza a demostrar ventajas de rendimiento.</p>
<p>Consulte <a href="/docs/es/index.md">Índice de vectores</a> para obtener más información.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">¿Cómo descarga Milvus los datos?</h4><p>Milvus devuelve éxito cuando los datos insertados se ingestan en la cola de mensajes. Sin embargo, los datos aún no se han volcado al disco. Entonces el nodo de datos de Milvus escribe los datos de la cola de mensajes en el almacenamiento persistente como registros incrementales. Si se llama a <code translate="no">flush()</code>, el nodo de datos se ve obligado a escribir todos los datos de la cola de mensajes en el almacenamiento persistente inmediatamente.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">¿Qué es la normalización? ¿Por qué es necesaria la normalización?</h4><p>La normalización se refiere al proceso de convertir un vector para que su norma sea igual a 1. Si se utiliza el producto interno para calcular la similitud vectorial, los vectores deben ser normalizados. Después de la normalización, el producto interior es igual a la similitud coseno.</p>
<p>Para más información, véase <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a>.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">¿Por qué la distancia euclídea (L2) y el producto interior (PI) devuelven resultados diferentes?</h4><p>Para vectores normalizados, la distancia euclídea (L2) es matemáticamente equivalente al producto interior (PI). Si estas métricas de similitud devuelven resultados diferentes, compruebe si sus vectores están normalizados</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">¿Existe un límite para el número total de colecciones y particiones en Milvus?</h4><p>Sí. Puede crear hasta 65.535 colecciones en una instancia de Milvus. Al calcular el número de colecciones existentes, Milvus cuenta todas las colecciones con fragmentos y particiones en ellas.</p>
<p>Por ejemplo, supongamos que ya ha creado 100 colecciones, con 2 fragmentos y 4 particiones en 60 de ellas y con 1 fragmento y 12 particiones en las 40 colecciones restantes. El número actual de colecciones se puede calcular como:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">¿Por qué obtengo menos de k vectores cuando busco vectores en <code translate="no">topk</code>?</h4><p>Entre los índices que soporta Milvus, IVF_FLAT e IVF_SQ8 implementan el método de agrupación k-means. Un espacio de datos se divide en <code translate="no">nlist</code> clusters y los vectores insertados se distribuyen en estos clusters. Milvus selecciona entonces los <code translate="no">nprobe</code> clusters más cercanos y compara las distancias entre el vector objetivo y todos los vectores en los clusters seleccionados para devolver los resultados finales.</p>
<p>Si <code translate="no">nlist</code> y <code translate="no">topk</code> son grandes y nprobe es pequeño, el número de vectores en los clusters nprobe puede ser menor que <code translate="no">k</code>. Por lo tanto, cuando se buscan los vectores más cercanos <code translate="no">topk</code>, el número de vectores devueltos es menor que <code translate="no">k</code>.</p>
<p>Para evitarlo, intente establecer <code translate="no">nprobe</code> más grande y <code translate="no">nlist</code> y <code translate="no">k</code> más pequeños.</p>
<p>Consulte <a href="/docs/es/index.md">Índice de vectores</a> para obtener más información.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">¿Cuál es la dimensión máxima de vector soportada en Milvus?</h4><p>Milvus puede gestionar vectores con hasta 32.768 dimensiones por defecto. Puede aumentar el valor de <code translate="no">Proxy.maxDimension</code> para permitir un vector de mayor dimensión.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">¿Es Milvus compatible con la CPU Apple M1?</h4><p>La versión actual de Milvus no soporta directamente la CPU Apple M1. Después de Milvus 2.3, Milvus proporciona imágenes Docker para la arquitectura ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">¿Qué tipos de datos soporta Milvus en el campo de clave primaria?</h4><p>En la versión actual, Milvus soporta tanto INT64 como string.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">¿Es Milvus escalable?</h4><p>Sí. Puede desplegar un clúster Milvus con múltiples nodos a través de Helm Chart en Kubernetes. Consulte la <a href="/docs/es/scaleout.md">Guía de escalado</a> para obtener más instrucciones.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">¿Qué son segmento creciente y segmento sellado?</h4><p>Cuando llega una solicitud de búsqueda, Milvus busca tanto datos incrementales como datos históricos. Los datos incrementales son actualizaciones recientes, se almacenan en los segmentos crecientes, que se almacenan en memoria antes de que alcancen el umbral para ser persistidos en el almacenamiento de objetos y se construye un índice más eficiente para ellos, mientras que los datos históricos son actualizaciones de hace un tiempo. Se encuentran en los segmentos sellados que se han persistido en el almacenamiento de objetos. Los datos incrementales y los datos históricos juntos constituyen el conjunto de datos para la búsqueda. Este diseño hace que cualquier dato ingestado a Milvus sea instantáneamente consultable. Para Milvus Distributed, hay factores más complejos que deciden cuándo un registro recién ingestado puede aparecer en el resultado de la búsqueda. Conozca más matices al respecto en <a href="https://milvus.io/docs/consistency.md">los niveles de consistencia</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">¿Está Milvus disponible para la búsqueda concurrente?</h4><p>Sí. Para consultas sobre la misma colección, Milvus busca simultáneamente en los datos incrementales e históricos. Sin embargo, las consultas sobre colecciones diferentes se realizan en serie. Mientras que los datos históricos pueden ser un conjunto de datos extremadamente grande, las búsquedas en los datos históricos consumen relativamente más tiempo y se realizan esencialmente en serie.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">¿Por qué permanecen los datos en MinIO después de que se abandone la colección correspondiente?</h4><p>Los datos en MinIO están diseñados para permanecer durante un cierto período de tiempo para la conveniencia de la reversión de datos.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">¿Milvus admite motores de mensajes distintos de Pulsar?</h4><p>Sí. Kafka está soportado en Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">¿Cuál es la diferencia entre una búsqueda y una consulta?</h4><p>En Milvus, una búsqueda de similitud vectorial recupera vectores basándose en el cálculo de similitud y la aceleración del índice vectorial. A diferencia de una búsqueda de similitud vectorial, una consulta vectorial recupera vectores mediante un filtrado escalar basado en una expresión booleana. La expresión booleana filtra los campos escalares o el campo de clave primaria, y recupera todos los resultados que coinciden con los filtros. En una consulta no intervienen ni la métrica de similitud ni el índice vectorial.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">¿Por qué un valor vectorial flotante tiene una precisión de 7 dígitos decimales en Milvus?</h4><p>Milvus permite almacenar vectores como matrices Float32. Un valor Float32 tiene una precisión de 7 dígitos decimales. Incluso con un valor Float64, como 1.3476964684980388, Milvus lo almacena como 1.347696. Por lo tanto, cuando se recupera un vector de Milvus, se pierde la precisión del valor Float64.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">¿Cómo maneja Milvus los tipos de datos vectoriales y la precisión?</h4><p>Milvus soporta los tipos de vectores Binary, Float32, Float16 y BFloat16.</p>
<ul>
<li>Vectores binarios: Almacenan datos binarios como secuencias de 0s y 1s, utilizados en el procesamiento de imágenes y recuperación de información.</li>
<li>Vectores Float32: Almacenamiento por defecto con una precisión de unos 7 dígitos decimales. Incluso los valores Float64 se almacenan con precisión Float32, lo que conlleva una posible pérdida de precisión al recuperarlos.</li>
<li>Vectores Float16 y BFloat16: Ofrecen una precisión y un uso de memoria reducidos. Float16 es adecuado para aplicaciones con ancho de banda y almacenamiento limitados, mientras que BFloat16 equilibra el rango y la eficiencia, comúnmente utilizado en el aprendizaje profundo para reducir los requisitos computacionales sin afectar significativamente a la precisión.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">¿Milvus permite especificar valores por defecto para campos escalares o vectoriales?</h4><p>Actualmente, Milvus 2.4.x no permite especificar valores por defecto para campos escalares o vectoriales. Esta característica está prevista para futuras versiones.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">¿Se libera el espacio de almacenamiento inmediatamente después de la eliminación de datos en Milvus?</h4><p>No, el espacio de almacenamiento no se libera inmediatamente cuando se borran datos en Milvus. Aunque la eliminación de datos marca las entidades como "eliminadas lógicamente", el espacio real puede no liberarse instantáneamente. He aquí por qué:</p>
<ul>
<li><strong>Compactación</strong>: Milvus compacta automáticamente los datos en segundo plano. Este proceso fusiona segmentos de datos más pequeños en otros más grandes y elimina los datos eliminados lógicamente (entidades marcadas para su eliminación) o los datos que han superado su tiempo de vida (TTL). Sin embargo, la compactación crea nuevos segmentos mientras marca los antiguos como "Eliminados".</li>
<li><strong>Recogida de Basura</strong>: Un proceso independiente llamado Recogida de Basura (GC) elimina periódicamente estos segmentos "Arrojados", liberando el espacio de almacenamiento que ocupaban. Esto garantiza un uso eficiente del almacenamiento, pero puede introducir un ligero retraso entre la eliminación y la recuperación de espacio.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">¿Puedo ver los datos insertados, borrados o subinsertados inmediatamente después de la operación sin esperar a que se produzca una descarga?</h4><p>Sí, en Milvus, la visibilidad de los datos no está directamente ligada a las operaciones de vaciado debido a su arquitectura de desagregación almacenamiento-ordenador. Puede gestionar la legibilidad de los datos utilizando niveles de consistencia.</p>
<p>Al seleccionar un nivel de consistencia, tenga en cuenta las compensaciones entre consistencia y rendimiento. Para operaciones que requieran visibilidad inmediata, utilice un nivel de consistencia "Fuerte". Para escrituras más rápidas, priorice una consistencia más débil (los datos pueden no ser visibles inmediatamente). Para más información, consulte <a href="/docs/es/consistency.md">Consistencia</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">Después de habilitar la función de clave de partición, ¿cuál es el valor predeterminado de <code translate="no">num_partitions</code> en Milvus, y por qué?</h4><p>Cuando se activa la función de clave de partición, el valor por defecto de <code translate="no">num_partitions</code> en Milvus se establece en <code translate="no">16</code>. Este valor por defecto se elige por razones de estabilidad y rendimiento. Puede ajustar el valor de <code translate="no">num_partitions</code> según sea necesario especificándolo en la función <code translate="no">create_collection</code>.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">¿Existe un límite máximo de longitud para las expresiones de filtrado escalar?</h4><p>Sí, la longitud máxima de una expresión de filtrado escalar está restringida por el límite de transferencia RPC, que se define en el archivo de configuración <code translate="no">milvus.yaml</code>. En concreto, el límite se establece mediante el parámetro <code translate="no">serverMaxRecvSize</code> de la sección proxy:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Por defecto, el tamaño máximo de cada petición RPC es de 64 MB. Por lo tanto, la longitud de la expresión de filtrado debe ser inferior a este límite para garantizar un procesamiento correcto.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">Al realizar una búsqueda masiva de vectores, ¿cuántos vectores se pueden especificar a la vez? ¿Existe algún límite?</h4><p>Sí, el número de vectores que se pueden especificar en una búsqueda masiva de vectores está limitado por el tamaño de la transferencia RPC, tal y como se define en el archivo de configuración <code translate="no">milvus.yaml</code>. Este límite viene determinado por el parámetro <code translate="no">serverMaxRecvSize</code> de la sección proxy:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Por defecto, el tamaño máximo de cada petición RPC es de 64MB. Por lo tanto, el tamaño total de los vectores de entrada, incluidos sus datos dimensionales y metadatos, debe ser inferior a este límite para garantizar el éxito de la ejecución.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Cómo puedo obtener todo el valor único de un campo escalar dado de una colección？</h4><p>Actualmente, no existe un método directo para conseguirlo. Como solución, recomendamos utilizar un query_iterator para recuperar todos los valores de un campo específico, y luego realizar la deduplicación manualmente. Tenemos previsto añadir soporte directo para esta función en Milvus 2.6. Ejemplo de uso de query_iterator:</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column    </span>
<button class="copy-code-btn"></button></code></pre>
<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">¿Cuáles son las limitaciones del uso de campos dinámicos? Por ejemplo, ¿hay límites de tamaño, métodos de modificación o restricciones de indexación?</h4><p>Los campos dinámicos se representan internamente utilizando campos JSON, con un límite de tamaño de 65.536 bytes. Admiten modificaciones upsert, lo que le permite añadir o actualizar campos. Sin embargo, a partir de Milvus 2.5.1, los campos dinámicos no admiten indexación. El soporte para añadir índices para JSON se introducirá en futuras versiones.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">¿Milvus admite cambios de esquema?</h4><p>A partir de la versión 2.5.0 de Milvus, los cambios de esquema se limitan a modificaciones específicas, como el ajuste de propiedades como el parámetro <code translate="no">mmap</code>. Los usuarios también pueden modificar <code translate="no">max_length</code> para los campos varchar y <code translate="no">max_capacity</code> para los campos array. Sin embargo, la capacidad de añadir o eliminar campos en los esquemas está prevista para futuras versiones, mejorando la flexibilidad de la gestión de esquemas dentro de Milvus.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">¿La modificación de max_length para VarChar requiere una reorganización de los datos?</h4><p>No, la modificación de <code translate="no">max_length</code> para un campo VarChar no requiere la reorganización de los datos, como la compactación o la reorganización. Este ajuste actualiza principalmente los criterios de validación para cualquier dato nuevo que se inserte en el campo, sin afectar a los datos existentes. Como resultado, este cambio se considera ligero y no impone una sobrecarga significativa al sistema.</p>
<h4 id="Still-have-questions" class="common-anchor-header">¿Aún tiene preguntas?</h4><p>Puede hacerlo:</p>
<ul>
<li>Eche un vistazo a <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> en GitHub. Puede plantear preguntas, compartir ideas y ayudar a los demás.</li>
<li>Únase a nuestra <a href="https://slack.milvus.io/">comunidad Slack</a> para encontrar apoyo y participar en nuestra comunidad de código abierto.</li>
</ul>
