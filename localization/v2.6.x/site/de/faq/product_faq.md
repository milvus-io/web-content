---
id: product_faq.md
summary: >-
  Hier finden Sie Antworten auf häufig gestellte Fragen über die weltweit
  fortschrittlichste Vektordatenbank.
title: Produkt-FAQ
---
<h1 id="Product-FAQ" class="common-anchor-header">Produkt-FAQ<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Wie viel kostet Milvus?</h4><p>Milvus ist ein 100% kostenloses Open-Source-Projekt.</p>
<p>Bitte halten Sie sich an die <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a>, wenn Sie Milvus für Produktions- oder Vertriebszwecke verwenden.</p>
<p>Zilliz, das Unternehmen hinter Milvus, bietet auch eine vollständig verwaltete Cloud-Version der Plattform für diejenigen an, die keine eigene verteilte Instanz erstellen und warten möchten. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> sorgt automatisch für die Zuverlässigkeit der Daten und ermöglicht es den Nutzern, nur für das zu zahlen, was sie verwenden.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Unterstützt Milvus nicht-x86-Architekturen?</h4><p>Milvus kann nicht auf nicht-x86 Plattformen installiert oder ausgeführt werden.</p>
<p>Ihre CPU muss einen der folgenden Befehlssätze unterstützen, um Milvus auszuführen: SSE4.2, AVX, AVX2, AVX512. Dies sind alles x86-spezifische SIMD-Befehlssätze.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Wo speichert Milvus Daten?</h4><p>Milvus arbeitet mit zwei Arten von Daten, eingefügten Daten und Metadaten.</p>
<p>Eingefügte Daten, einschließlich Vektordaten, skalare Daten und sammlungsspezifische Schemata, werden im persistenten Speicher als inkrementelles Protokoll gespeichert. Milvus unterstützt mehrere Objektspeicher-Backends, darunter <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> und <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Die Metadaten werden innerhalb von Milvus generiert. Jedes Milvus-Modul hat seine eigenen Metadaten, die in etcd gespeichert werden.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Warum gibt es keine Vektordaten in etcd?</h4><p>etcd speichert Milvus-Modul-Metadaten; MinIO speichert Entitäten.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Unterstützt Milvus das gleichzeitige Einfügen und Suchen von Daten?</h4><p>Ja. Einfügeoperationen und Abfrageoperationen werden von zwei separaten Modulen gehandhabt, die voneinander unabhängig sind. Aus der Sicht des Clients ist ein Einfügevorgang abgeschlossen, wenn die eingefügten Daten in die Nachrichtenwarteschlange gelangen. Die eingefügten Daten sind jedoch nicht durchsuchbar, bis sie in den Abfrageknoten geladen werden. Erreicht die Segmentgröße nicht den Schwellenwert für die Indexerstellung (standardmäßig 512 MB), greift Milvus auf die Brute-Force-Suche zurück, und die Abfrageleistung kann beeinträchtigt werden.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Können Vektoren mit doppelten Primärschlüsseln in Milvus eingefügt werden?</h4><p>Ja. Milvus prüft nicht, ob es sich bei den Primärschlüsseln der Vektoren um Duplikate handelt.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Wenn Vektoren mit doppelten Primärschlüsseln eingefügt werden, behandelt Milvus dies dann als Aktualisierungsvorgang?</h4><p>Nein. Milvus unterstützt derzeit keine Aktualisierungsoperationen und prüft nicht, ob Entity-Primärschlüssel doppelt vorhanden sind. Sie sind dafür verantwortlich, dass die Primärschlüssel der Entitäten eindeutig sind, und wenn sie es nicht sind, kann Milvus mehrere Entitäten mit doppelten Primärschlüsseln enthalten.</p>
<p>In diesem Fall bleibt unbekannt, welche Datenkopie bei einer Abfrage zurückgegeben wird. Diese Einschränkung wird in zukünftigen Versionen behoben werden.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Wie lang dürfen selbst definierte Entitätsprimärschlüssel maximal sein?</h4><p>Entitäts-Primärschlüssel müssen nicht-negative 64-Bit-Ganzzahlen sein.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Wie groß ist die maximale Datenmenge, die pro Einfügevorgang hinzugefügt werden kann?</h4><p>Ein Einfügevorgang darf eine Größe von 1.024 MB nicht überschreiten. Dies ist eine von gRPC festgelegte Grenze.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">Wirkt sich die Größe der Sammlung auf die Abfrageleistung bei der Suche in einer bestimmten Partition aus?</h4><p>Nein. Wenn Partitionen für eine Suche angegeben werden, durchsucht Milvus nur die angegebenen Partitionen.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Muss Milvus die gesamte Sammlung laden, wenn Partitionen für eine Suche angegeben werden?</h4><p>Das hängt davon ab, welche Daten für die Suche benötigt werden. Alle Partitionen, die im Suchergebnis auftauchen könnten, müssen vor der Suche geladen werden.</p>
<ul>
<li>Wenn Sie z. B. nur bestimmte Partitionen durchsuchen wollen, müssen Sie nicht alle laden. Rufen Sie <code translate="no">load_partition()</code> auf, um die gewünschte(n) Partition(en) zu laden <em>, und</em> geben Sie <em>dann</em> die Partition(en) in dem Methodenaufruf <code translate="no">search()</code> an.</li>
<li>Wenn Sie alle Partitionen durchsuchen wollen, rufen Sie <code translate="no">load_collection()</code> auf, um die gesamte Sammlung einschließlich aller Partitionen zu laden.</li>
<li>Wenn Sie die Sammlung oder bestimmte Partition(en) vor der Suche nicht laden, wird Milvus einen Fehler zurückgeben.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Können Indizes nach dem Einfügen von Vektoren erstellt werden?</h4><p>Ja. Wenn zuvor ein Index für eine Sammlung durch <code translate="no">create_index()</code> erstellt wurde, erstellt Milvus automatisch einen Index für die später eingefügten Vektoren. Milvus erstellt jedoch erst dann einen Index, wenn die neu eingefügten Vektoren ein ganzes Segment füllen und die neu erstellte Indexdatei von der vorherigen getrennt ist.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">Wie unterscheiden sich die Indizes FLAT und IVF_FLAT?</h4><p>Der IVF_FLAT-Index unterteilt den Vektorraum in Listencluster. Bei dem Standardlistenwert von 16.384 vergleicht Milvus die Abstände zwischen dem Zielvektor und den Mittelpunkten aller 16.384 Cluster, um die nächstgelegenen Cluster zu ermitteln. Milvus vergleicht dann die Abstände zwischen dem Zielvektor und den Vektoren in den ausgewählten Clustern, um die nächstgelegenen Vektoren zu ermitteln. Im Gegensatz zu IVF_FLAT vergleicht FLAT direkt die Abstände zwischen dem Zielvektor und allen anderen Vektoren.</p>
<p>Wenn die Gesamtzahl der Vektoren annähernd nlist entspricht, ist der Unterschied zwischen IVF_FLAT und FLAT in Bezug auf den Rechenaufwand und die Suchleistung gering. Sobald jedoch die Anzahl der Vektoren nlist um den Faktor zwei oder mehr übersteigt, beginnt IVF_FLAT Leistungsvorteile zu zeigen.</p>
<p>Siehe <a href="/docs/de/index.md">Vektorindex</a> für weitere Informationen.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Wie bündelt Milvus Daten?</h4><p>Milvus gibt einen Erfolg zurück, wenn die eingefügten Daten in die Nachrichtenwarteschlange aufgenommen wurden. Die Daten werden jedoch noch nicht auf die Festplatte gespült. Dann schreibt der Datenknoten von Milvus die Daten in der Nachrichtenwarteschlange als inkrementelle Protokolle in den permanenten Speicher. Wenn <code translate="no">flush()</code> aufgerufen wird, wird der Datenknoten gezwungen, alle Daten in der Nachrichtenwarteschlange sofort in den permanenten Speicher zu schreiben.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Was ist Normalisierung? Warum ist Normalisierung erforderlich?</h4><p>Normalisierung bezieht sich auf den Prozess der Konvertierung eines Vektors, so dass seine Norm gleich 1 ist. Wenn das innere Produkt zur Berechnung der Vektorähnlichkeit verwendet wird, müssen die Vektoren normalisiert werden. Nach der Normalisierung ist das innere Produkt gleich der Kosinusähnlichkeit.</p>
<p>Siehe <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> für weitere Informationen.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Warum liefern der euklidische Abstand (L2) und das innere Produkt (IP) unterschiedliche Ergebnisse?</h4><p>Für normalisierte Vektoren ist der euklidische Abstand (L2) mathematisch äquivalent zum inneren Produkt (IP). Wenn diese Ähnlichkeitsmetriken unterschiedliche Ergebnisse liefern, prüfen Sie, ob Ihre Vektoren normalisiert sind</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Gibt es eine Grenze für die Gesamtzahl der Sammlungen und Unterteilungen in Milvus?</h4><p>Ja. Sie können bis zu 65.535 Sammlungen in einer Milvus-Instanz erstellen. Bei der Berechnung der Anzahl der vorhandenen Sammlungen zählt Milvus alle Sammlungen, die Scherben und Partitionen enthalten.</p>
<p>Nehmen wir zum Beispiel an, Sie haben bereits 100 Sammlungen angelegt, von denen 60 2 Shards und 4 Partitionen enthalten und die restlichen 40 Sammlungen 1 Shard und 12 Partitionen. Die aktuelle Anzahl der Sammlungen kann wie folgt berechnet werden:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Warum erhalte ich weniger als k Vektoren, wenn ich nach <code translate="no">topk</code> Vektoren suche?</h4><p>Von den Indizes, die Milvus unterstützt, implementieren IVF_FLAT und IVF_SQ8 die k-means Clustering-Methode. Ein Datenraum wird in <code translate="no">nlist</code> Cluster unterteilt und die eingefügten Vektoren werden auf diese Cluster verteilt. Milvus wählt dann die <code translate="no">nprobe</code> nächstgelegenen Cluster aus und vergleicht die Abstände zwischen dem Zielvektor und allen Vektoren in den ausgewählten Clustern, um die endgültigen Ergebnisse zu erhalten.</p>
<p>Wenn <code translate="no">nlist</code> und <code translate="no">topk</code> groß sind und nprobe klein ist, kann die Anzahl der Vektoren in den nprobe-Clustern geringer sein als <code translate="no">k</code>. Wenn Sie also nach den <code translate="no">topk</code> nächstgelegenen Vektoren suchen, ist die Anzahl der zurückgegebenen Vektoren geringer als <code translate="no">k</code>.</p>
<p>Um dies zu vermeiden, versuchen Sie, <code translate="no">nprobe</code> größer und <code translate="no">nlist</code> und <code translate="no">k</code> kleiner zu setzen.</p>
<p>Weitere Informationen finden Sie unter <a href="/docs/de/index.md">Vektorindex</a>.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Was ist die maximale Vektordimension, die Milvus unterstützt?</h4><p>Milvus kann standardmäßig Vektoren mit bis zu 32.768 Dimensionen verwalten. Sie können den Wert von <code translate="no">Proxy.maxDimension</code> erhöhen, um einen Vektor mit einer größeren Dimension zu ermöglichen.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Unterstützt Milvus die Apple M1 CPU?</h4><p>Die aktuelle Milvus-Version unterstützt die Apple M1-CPU nicht direkt. Nach Milvus 2.3 bietet Milvus Docker-Images für die ARM64-Architektur.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Welche Datentypen unterstützt Milvus für das Primärschlüsselfeld?</h4><p>In der aktuellen Version unterstützt Milvus sowohl INT64 als auch String.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Ist Milvus skalierbar?</h4><p>Ja. Sie können Milvus-Cluster mit mehreren Knoten über Helm Chart auf Kubernetes bereitstellen. Weitere Anweisungen finden Sie im <a href="/docs/de/scaleout.md">Scale Guide</a>.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Was sind wachsende und geschlossene Segmente?</h4><p>Wenn eine Suchanfrage kommt, durchsucht Milvus sowohl inkrementelle als auch historische Daten. Inkrementelle Daten sind aktuelle Aktualisierungen, die in den wachsenden Segmenten gespeichert werden, die im Speicher gepuffert werden, bevor sie den Schwellenwert für die Persistenz im Objektspeicher erreichen, und für die ein effizienterer Index erstellt wird, während historische Daten Aktualisierungen sind, die schon länger zurückliegen. Sie befinden sich in den versiegelten Segmenten, die im Objektspeicher persistiert wurden. Inkrementelle Daten und historische Daten bilden zusammen den gesamten Datenbestand für die Suche. Dieses Design macht alle Daten, die in Milvus aufgenommen werden, sofort durchsuchbar. Bei Milvus Distributed gibt es komplexere Faktoren, die darüber entscheiden, wann ein gerade aufgenommener Datensatz in den Suchergebnissen auftauchen kann. Erfahren Sie mehr darüber unter <a href="https://milvus.io/docs/consistency.md">Konsistenzstufen</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Ist Milvus für die gleichzeitige Suche verfügbar?</h4><p>Ja. Bei Abfragen in derselben Sammlung durchsucht Milvus gleichzeitig die inkrementellen und historischen Daten. Abfragen zu verschiedenen Sammlungen werden jedoch nacheinander durchgeführt. Da es sich bei den historischen Daten um einen extrem großen Datenbestand handeln kann, sind die Abfragen auf den historischen Daten relativ zeitaufwändiger und werden im Wesentlichen in Serien durchgeführt.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Warum bleiben die Daten in MinIO erhalten, nachdem die entsprechende Sammlung gelöscht wurde?</h4><p>Die Daten in MinIO sind so konzipiert, dass sie für einen bestimmten Zeitraum gespeichert bleiben, um ein Rollback der Daten zu ermöglichen.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Unterstützt Milvus auch andere Message Engines als Pulsar?</h4><p>Ja. Kafka wird in Milvus 2.1.0 unterstützt.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">Was ist der Unterschied zwischen einer Suche und einer Abfrage?</h4><p>In Milvus findet eine Vektorähnlichkeitssuche Vektoren auf der Grundlage von Ähnlichkeitsberechnungen und Vektorindexbeschleunigung. Im Gegensatz zu einer Vektorähnlichkeitssuche werden bei einer Vektorabfrage Vektoren durch skalare Filterung auf der Grundlage eines booleschen Ausdrucks abgerufen. Der boolesche Ausdruck filtert auf skalare Felder oder das Primärschlüsselfeld und ruft alle Ergebnisse ab, die den Filtern entsprechen. Bei einer Abfrage sind weder Ähnlichkeitsmetriken noch ein Vektorindex beteiligt.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Warum hat ein Float-Vektorwert in Milvus eine Genauigkeit von 7 Dezimalstellen?</h4><p>Milvus unterstützt die Speicherung von Vektoren als Float32-Arrays. Ein Float32-Wert hat eine Genauigkeit von 7 Dezimalziffern. Selbst bei einem Float64-Wert, wie z.B. 1.3476964684980388, speichert Milvus ihn als 1.347696. Wenn Sie also einen solchen Vektor von Milvus abrufen, geht die Genauigkeit des Float64-Wertes verloren.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Wie geht Milvus mit Vektordatentypen und Genauigkeit um?</h4><p>Milvus unterstützt die Vektortypen Binary, Float32, Float16 und BFloat16.</p>
<ul>
<li>Binäre Vektoren: Speichern binäre Daten als Sequenzen von 0en und 1en und werden in der Bildverarbeitung und beim Informationsabruf verwendet.</li>
<li>Float32-Vektoren: Standardspeicherung mit einer Genauigkeit von etwa 7 Dezimalstellen. Auch Float64-Werte werden mit Float32-Präzision gespeichert, was zu einem möglichen Präzisionsverlust beim Abruf führt.</li>
<li>Float16- und BFloat16-Vektoren: Bieten eine geringere Genauigkeit und einen geringeren Speicherbedarf. Float16 eignet sich für Anwendungen mit begrenzter Bandbreite und begrenztem Speicherplatz, während BFloat16 ein ausgewogenes Verhältnis zwischen Reichweite und Effizienz bietet und häufig beim Deep Learning verwendet wird, um die Rechenanforderungen zu reduzieren, ohne die Genauigkeit wesentlich zu beeinträchtigen.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Unterstützt Milvus die Angabe von Standardwerten für Skalar- oder Vektorfelder?</h4><p>Derzeit unterstützt Milvus 2.4.x nicht die Angabe von Standardwerten für Skalar- oder Vektorfelder. Diese Funktion ist für zukünftige Versionen geplant.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">Wird der Speicherplatz nach dem Löschen von Daten in Milvus sofort wieder freigegeben?</h4><p>Nein, der Speicherplatz wird nicht sofort freigegeben, wenn Sie Daten in Milvus löschen. Obwohl das Löschen von Daten Entitäten als "logisch gelöscht" markiert, wird der tatsächliche Speicherplatz nicht sofort freigegeben. Dies ist der Grund:</p>
<ul>
<li><strong>Verdichtung</strong>: Milvus komprimiert Daten automatisch im Hintergrund. Bei diesem Prozess werden kleinere Datensegmente zu größeren zusammengeführt und logisch gelöschte Daten (zum Löschen markierte Entitäten) oder Daten, die ihre Time-To-Live (TTL) überschritten haben, entfernt. Bei der Verdichtung werden jedoch neue Segmente erstellt, während alte als "fallengelassen" markiert werden.</li>
<li><strong>Garbage Collection</strong>: Ein separater Prozess namens Garbage Collection (GC) entfernt diese "Dropped"-Segmente in regelmäßigen Abständen und gibt so den von ihnen belegten Speicherplatz wieder frei. Dies gewährleistet eine effiziente Nutzung des Speichers, kann jedoch zu einer leichten Verzögerung zwischen dem Löschen und der Wiedergewinnung von Speicherplatz führen.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">Kann ich eingefügte, gelöschte oder hochgeladene Daten sofort nach dem Vorgang sehen, ohne auf einen Flush zu warten?</h4><p>Ja, in Milvus ist die Datentransparenz aufgrund der Disaggregationsarchitektur von Storage und Compute nicht direkt an Flush-Vorgänge gebunden. Sie können die Lesbarkeit der Daten über Konsistenzstufen verwalten.</p>
<p>Bei der Auswahl einer Konsistenzstufe sollten Sie die Kompromisse zwischen Konsistenz und Leistung berücksichtigen. Für Operationen, die eine sofortige Sichtbarkeit erfordern, verwenden Sie eine "starke" Konsistenzstufe. Für schnellere Schreibvorgänge sollten Sie eine schwächere Konsistenz bevorzugen (die Daten sind möglicherweise nicht sofort sichtbar). Weitere Informationen finden Sie unter <a href="/docs/de/consistency.md">Konsistenz</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">Wie lautet der Standardwert von <code translate="no">num_partitions</code> in Milvus nach der Aktivierung der Partitionsschlüssel-Funktion und warum?</h4><p>Wenn die Partitionsschlüsselfunktion aktiviert ist, wird der Standardwert von <code translate="no">num_partitions</code> in Milvus auf <code translate="no">16</code> gesetzt. Dieser Standardwert wurde aus Stabilitäts- und Leistungsgründen gewählt. Sie können den Wert <code translate="no">num_partitions</code> nach Bedarf anpassen, indem Sie ihn in der Funktion <code translate="no">create_collection</code> angeben.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">Gibt es eine maximale Länge für skalare Filterausdrücke?</h4><p>Ja, die maximale Länge eines skalaren Filterausdrucks wird durch das RPC-Übertragungslimit begrenzt, das in der Konfigurationsdatei <code translate="no">milvus.yaml</code> definiert ist. Das Limit wird insbesondere durch den Parameter <code translate="no">serverMaxRecvSize</code> im Abschnitt proxy festgelegt:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Standardmäßig beträgt die maximale Größe jeder RPC-Anfrage 64 MB. Daher muss die Länge des Filterausdrucks unter diesem Limit liegen, um eine erfolgreiche Verarbeitung zu gewährleisten.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">Wie viele Vektoren können bei einer Massenvektorsuche auf einmal angegeben werden? Gibt es eine Begrenzung?</h4><p>Ja, die Anzahl der Vektoren, die bei einer Bulk-Vektorsuche angegeben werden können, ist durch die RPC-Übertragungsgröße begrenzt, die in der Konfigurationsdatei <code translate="no">milvus.yaml</code> definiert ist. Diese Grenze wird durch den Parameter <code translate="no">serverMaxRecvSize</code> im Abschnitt "Proxy" bestimmt:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Standardmäßig beträgt die maximale Größe jeder RPC-Anfrage 64 MB. Daher muss die Gesamtgröße der Eingabevektoren, einschließlich ihrer Dimensionsdaten und Metadaten, unter dieser Grenze liegen, um eine erfolgreiche Ausführung zu gewährleisten.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Wie kann ich alle eindeutigen Werte eines gegebenen Skalarfeldes aus einer Sammlung abrufen？?</h4><p>Derzeit gibt es keine direkte Methode, um dies zu erreichen. Als Workaround empfehlen wir, einen query_iterator zu verwenden, um alle Werte für ein bestimmtes Feld abzurufen, und dann die Deduplizierung manuell durchzuführen. Wir planen, in Milvus 2.6 eine direkte Unterstützung für diese Funktion hinzuzufügen. Beispiel für die Verwendung von query_iterator:</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column    </span>
<button class="copy-code-btn"></button></code></pre>
<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">Wo liegen die Grenzen bei der Verwendung dynamischer Felder? Gibt es zum Beispiel Größenbeschränkungen, Änderungsmethoden oder Einschränkungen bei der Indizierung?</h4><p>Dynamische Felder werden intern durch JSON-Felder mit einer Größenbeschränkung von 65.536 Byte dargestellt. Sie unterstützen Upsert-Änderungen, so dass Sie Felder hinzufügen oder aktualisieren können. Ab Milvus 2.5.1 unterstützen dynamische Felder jedoch keine Indizierung. Die Unterstützung für das Hinzufügen von Indizes für JSON wird in zukünftigen Versionen eingeführt.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">Unterstützt Milvus Schemaänderungen?</h4><p>Ab Milvus Version 2.5.0 sind Schemaänderungen auf spezifische Modifikationen beschränkt, wie z.B. die Anpassung von Eigenschaften wie dem <code translate="no">mmap</code> Parameter. Benutzer können auch die <code translate="no">max_length</code> für varchar-Felder und <code translate="no">max_capacity</code> für Array-Felder ändern. Die Möglichkeit, Felder in Schemas hinzuzufügen oder zu entfernen, ist jedoch für zukünftige Versionen geplant, um die Flexibilität der Schemaverwaltung in Milvus zu erhöhen.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">Erfordert die Änderung von max_length für VarChar eine Reorganisation der Daten?</h4><p>Nein, die Änderung der <code translate="no">max_length</code> für ein VarChar-Feld erfordert keine Datenreorganisation, wie z. B. Verdichtung oder Reorganisation. Diese Anpassung aktualisiert in erster Linie die Überprüfungskriterien für alle neuen Daten, die in das Feld eingefügt werden, und lässt die vorhandenen Daten unberührt. Daher wird diese Änderung als geringfügig angesehen und verursacht keinen signifikanten Overhead für das System.</p>
<h4 id="Still-have-questions" class="common-anchor-header">Haben Sie noch Fragen?</h4><p>Sie können:</p>
<ul>
<li>Schauen Sie sich <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> auf GitHub an. Sie sind herzlich eingeladen, Fragen zu stellen, Ideen zu teilen und anderen zu helfen.</li>
<li>Treten Sie unserer <a href="https://slack.milvus.io/">Slack-Community</a> bei, um Unterstützung zu erhalten und sich mit unserer Open-Source-Community auszutauschen.</li>
</ul>
