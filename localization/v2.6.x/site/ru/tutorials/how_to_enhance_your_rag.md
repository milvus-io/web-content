---
id: how_to_enhance_your_rag.md
summary: >-
  С ростом популярности приложений Retrieval Augmented Generation RAG все чаще
  возникает вопрос об улучшении их производительности. В этой статье
  представлены все возможные способы оптимизации конвейеров RAG и приведены
  соответствующие иллюстрации, которые помогут вам быстро понять основные
  стратегии оптимизации RAG.
title: Как повысить производительность конвейера RAG
---
<h1 id="How-to-Enhance-the-Performance-of-Your-RAG-Pipeline" class="common-anchor-header">Как повысить производительность конвейера RAG<button data-href="#How-to-Enhance-the-Performance-of-Your-RAG-Pipeline" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>С ростом популярности приложений Retrieval Augmented Generation<a href="https://zilliz.com/learn/Retrieval-Augmented-Generation">(RAG</a>) все чаще возникает вопрос о повышении их производительности. В этой статье представлены все возможные способы оптимизации конвейеров RAG и приведены соответствующие иллюстрации, которые помогут вам быстро понять основные стратегии оптимизации RAG.</p>
<p>Важно отметить, что мы лишь в общих чертах рассмотрим эти стратегии и методы, сосредоточившись на том, как они интегрируются в систему RAG. Однако мы не будем углубляться в сложные детали или проводить вас через пошаговое внедрение.</p>
<h2 id="A-Standard-RAG-Pipeline" class="common-anchor-header">Стандартный конвейер RAG<button data-href="#A-Standard-RAG-Pipeline" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>На схеме ниже показан самый простой стандартный конвейер RAG. Сначала фрагменты документов загружаются в векторное хранилище (например, в <a href="https://zilliz.com/cloud">облако</a> <a href="https://milvus.io/docs">Milvus</a> или <a href="https://zilliz.com/cloud">Zilliz</a>). Затем из векторного хранилища извлекается Top-K наиболее релевантных фрагментов, связанных с запросом. Эти релевантные фрагменты затем вводятся в контекстную подсказку <a href="https://zilliz.com/glossary/large-language-models-(llms)">LLM</a>, и, наконец, LLM возвращает окончательный ответ.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/vanilla_rag.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Various-Types-of-RAG-Enhancement-Techniques" class="common-anchor-header">Различные типы техник улучшения RAG<button data-href="#Various-Types-of-RAG-Enhancement-Techniques" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Мы можем классифицировать различные подходы к улучшению RAG в зависимости от их роли на этапах конвейера RAG.</p>
<ul>
<li><strong>Улучшение запросов</strong>: Модификация и манипулирование процессом запроса на входе RAG для лучшего выражения или обработки намерения запроса.</li>
<li><strong>Улучшение индексирования</strong>: Оптимизация создания индексов с кусками с помощью таких методов, как многокусковое индексирование, пошаговое индексирование или многоходовое индексирование.</li>
<li><strong>Улучшение ретривера</strong>: Применение методов и стратегий оптимизации в процессе поиска.</li>
<li><strong>Усовершенствование генератора</strong>: Корректировка и оптимизация подсказок при сборке подсказок для LLM с целью получения более качественных ответов.</li>
<li><strong>Улучшение конвейера RAG</strong>: Динамическое переключение процессов в рамках всего конвейера RAG, включая использование агентов или инструментов для оптимизации ключевых этапов конвейера RAG.</li>
</ul>
<p>Далее мы представим конкретные методы в каждой из этих категорий.</p>
<h2 id="Query-Enhancement" class="common-anchor-header">Улучшение запросов<button data-href="#Query-Enhancement" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Давайте рассмотрим четыре эффективных метода улучшения работы с запросами: Гипотетические вопросы, вкрапления гипотетических документов, подзапросы и пошаговые подсказки.</p>
<h3 id="Creating-Hypothetical-Questions" class="common-anchor-header">Создание гипотетических вопросов</h3><p>Создание гипотетических вопросов предполагает использование LLM для генерации множества вопросов, которые пользователи могут задать по поводу содержимого каждого блока документов. Прежде чем реальный запрос пользователя дойдет до LLM, векторное хранилище извлекает наиболее релевантные гипотетические вопросы, связанные с реальным запросом, вместе с соответствующими фрагментами документов и направляет их в LLM.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/hypothetical_question.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Эта методология позволяет обойти проблему междоменной асимметрии в процессе векторного поиска, напрямую участвуя в поиске между запросами, что облегчает нагрузку на векторный поиск. Однако это влечет за собой дополнительные накладные расходы и неопределенность при генерации гипотетических вопросов.</p>
<h3 id="HyDE-Hypothetical-Document-Embeddings" class="common-anchor-header">HyDE (Hypothetical Document Embeddings)</h3><p>HyDE расшифровывается как Hypothetical Document Embeddings. Он использует LLM для создания<strong><em>"гипотетического документа</em></strong>" или <strong><em>фальшивого</em></strong> ответа в ответ на запрос пользователя, лишенного контекстной информации. Затем этот фальшивый ответ преобразуется в векторные вкрапления и используется для запроса наиболее релевантных фрагментов документов в векторной базе данных. Затем векторная база данных извлекает Top-K наиболее релевантных фрагментов документов и передает их в LLM и исходный запрос пользователя для создания окончательного ответа.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/hyde.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Этот метод похож на метод гипотетического вопроса в решении проблемы междоменной асимметрии в векторном поиске. Однако у него есть и недостатки, такие как дополнительные вычислительные затраты и неопределенность при генерации фальшивых ответов.</p>
<p>Более подробную информацию можно найти в статье <a href="https://arxiv.org/abs/2212.10496">HyDE</a>.</p>
<h3 id="Creating-Sub-Queries" class="common-anchor-header">Создание подзапросов</h3><p>Когда пользовательский запрос слишком сложен, мы можем использовать LLM для разбиения его на более простые подзапросы перед передачей их в векторную базу данных и LLM. Давайте рассмотрим пример.</p>
<p>Представьте, что пользователь спрашивает:<strong><em>"В чем разница в возможностях между Milvus и Zilliz Cloud?</em></strong>". Этот вопрос довольно сложный и, возможно, не имеет прямого ответа в нашей базе знаний. Чтобы решить эту проблему, мы можем разделить его на два более простых подзапроса:</p>
<ul>
<li>Подзапрос 1: "Каковы особенности Milvus?"</li>
<li>Подзапрос 2: "Каковы особенности Zilliz Cloud?".</li>
</ul>
<p>Получив эти подзапросы, мы отправляем их в векторную базу данных после преобразования в векторные вкрапления. Затем векторная база данных находит фрагменты документов Top-K, наиболее релевантные каждому подзапросу. Наконец, LLM использует эту информацию для генерации лучшего ответа.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/sub_query.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Разбив запрос пользователя на подзапросы, мы облегчаем нашей системе поиск релевантной информации и предоставление точных ответов даже на сложные вопросы.</p>
<h3 id="Creating-Stepback-Prompts" class="common-anchor-header">Создание пошаговых подсказок</h3><p>Еще один способ упростить сложные пользовательские запросы - создать <strong><em>пошаговые подсказки</em></strong>. Эта техника предполагает абстрагирование сложных запросов пользователя в <em><em>"</em>пошаговые вопросы</em>"** с помощью LLM. Затем векторная база данных использует эти пошаговые вопросы для извлечения наиболее релевантных фрагментов документов. И наконец, LLM генерирует более точный ответ на основе этих полученных фрагментов документов.</p>
<p>Проиллюстрируем эту технику на примере. Рассмотрим следующий запрос, который является довольно сложным и не простым для прямого ответа:</p>
<p><strong><em>Исходный запрос пользователя: "У меня есть набор данных с 10 миллиардами записей, и я хочу хранить его в Milvus для запросов. Возможно ли это?"</em></strong></p>
<p>Чтобы упростить этот пользовательский запрос, мы можем использовать LLM для генерации более простого пошагового вопроса:</p>
<p><strong><em>Stepback Question: "Каков предельный размер набора данных, с которым может работать Milvus?".</em></strong></p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/stepback.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Этот метод может помочь нам получить более точные ответы на сложные запросы. Он разбивает исходный вопрос на более простые формы, облегчая нашей системе поиск релевантной информации и предоставление точных ответов.</p>
<h2 id="Indexing-Enhancement" class="common-anchor-header">Улучшение индексации<button data-href="#Indexing-Enhancement" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Улучшение индексации - еще одна стратегия повышения производительности приложений RAG. Давайте рассмотрим три метода улучшения индексации.</p>
<h3 id="Merging-Document-Chunks-Automatically" class="common-anchor-header">Автоматическое объединение фрагментов документов</h3><p>При построении индекса мы можем использовать два уровня детализации: дочерние и соответствующие им родительские блоки. Сначала мы ищем дочерние блоки на более тонком уровне детализации. Затем мы применяем стратегию слияния: если определенное количество, <strong><em>n</em></strong>, дочерних чанков из первых <strong><em>k</em></strong> дочерних чанков принадлежат одному и тому же родительскому чанку, мы предоставляем этот родительский чанк в LLM в качестве контекстной информации.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/merge_chunks.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Эта методология была реализована в <a href="https://docs.llamaindex.ai/en/stable/examples/retrievers/recursive_retriever_nodes.html">LlamaIndex</a>.</p>
<h3 id="Constructing-Hierarchical-Indices" class="common-anchor-header">Построение иерархических индексов</h3><p>При создании индексов для документов мы можем создать двухуровневый индекс: один для резюме документов, другой - для их фрагментов. Процесс векторного поиска состоит из двух этапов: сначала мы фильтруем релевантные документы на основе резюме, а затем извлекаем соответствующие фрагменты документов исключительно из этих релевантных документов.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/hierarchical_index.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Этот подход оказывается полезным в ситуациях с большими объемами данных или в случаях, когда данные иерархичны, например, при поиске контента в библиотечной коллекции.</p>
<h3 id="Hybrid-Retrieval-and-Reranking" class="common-anchor-header">Гибридный поиск и реранжирование</h3><p>Метод гибридного поиска и реранжирования объединяет один или несколько дополнительных методов поиска с <a href="https://zilliz.com/learn/vector-similarity-search">поиском по векторному сходству</a>. Затем <a href="https://zilliz.com/learn/optimize-rag-with-rerankers-the-role-and-tradeoffs#What-is-a-Reranker">реранжировщик</a> ранжирует полученные результаты на основе их релевантности запросу пользователя.</p>
<p>К распространенным алгоритмам дополнительного поиска относятся методы, основанные на лексической частоте, например <a href="https://milvus.io/docs/embed-with-bm25.md">BM25</a>, или большие модели, использующие разреженные вкрапления, например <a href="https://zilliz.com/learn/discover-splade-revolutionize-sparse-data-processing">Splade</a>. Алгоритмы повторного ранжирования включают RRF или более сложные модели, такие как <a href="https://www.sbert.net/examples/applications/cross-encoder/README.html">Cross-Encoder</a>, которые напоминают BERT-подобные архитектуры.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/hybrid_and_rerank.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Этот подход использует различные методы поиска для улучшения качества поиска и устранения потенциальных пробелов в векторном отзыве.</p>
<h2 id="Retriever-Enhancement" class="common-anchor-header">Усовершенствование ретривера<button data-href="#Retriever-Enhancement" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Усовершенствование компонента ретривера в системе RAG также может улучшить работу приложений RAG. Давайте рассмотрим некоторые эффективные методы улучшения ретривера.</p>
<h3 id="Sentence-Window-Retrieval" class="common-anchor-header">Поиск в окне предложения</h3><p>В базовой системе RAG фрагмент документа, передаваемый LLM, представляет собой более крупное окно, охватывающее извлеченный фрагмент вставки. Это гарантирует, что информация, предоставляемая LLM, включает в себя более широкий спектр контекстных деталей, минимизируя потерю информации. Техника Sentence Window Retrieval позволяет отделить фрагмент документа, используемый для поиска вкраплений, от фрагмента, предоставляемого LLM.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/sentence_window.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Однако увеличение размера окна может привести к появлению дополнительной мешающей информации. Мы можем регулировать размер расширения окна в зависимости от конкретных потребностей бизнеса.</p>
<h3 id="Meta-data-Filtering" class="common-anchor-header">Фильтрация метаданных</h3><p>Чтобы обеспечить более точные ответы, мы можем уточнить полученные документы, отфильтровав метаданные, такие как время и категория, перед передачей их в LLM. Например, если получены финансовые отчеты за несколько лет, фильтрация по нужному году позволит уточнить информацию в соответствии с конкретными требованиями. Этот метод эффективен в ситуациях с обширными данными и подробными метаданными, например при поиске контента в библиотечных фондах.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/metadata_filtering.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Generator-Enhancement" class="common-anchor-header">Расширение возможностей генератора<button data-href="#Generator-Enhancement" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Давайте рассмотрим другие методы оптимизации RAG, улучшив генератор в системе RAG.</p>
<h3 id="Compressing-the-LLM-prompt" class="common-anchor-header">Сжатие запроса LLM</h3><p>Шумовая информация в извлеченных фрагментах документов может существенно повлиять на точность окончательного ответа RAG. Ограниченное окно подсказки в LLM также является препятствием для получения более точных ответов. Чтобы решить эту проблему, мы можем сжать нерелевантные детали, подчеркнуть ключевые абзацы и уменьшить общую длину контекста в найденных фрагментах документов.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/compress_prompt.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Этот подход похож на рассмотренный ранее гибридный метод поиска и реранжирования, в котором реранжировщик используется для отсеивания нерелевантных фрагментов документов.</p>
<h3 id="Adjusting-the-chunk-order-in-the-prompt" class="common-anchor-header">Корректировка порядка расположения фрагментов в подсказке</h3><p>В статье<a href="https://arxiv.org/abs/2307.03172">"Lost in the middle</a>" исследователи заметили, что LLM часто не обращают внимания на информацию в середине документов в процессе рассуждения. Вместо этого они склонны больше полагаться на информацию, представленную в начале и конце документов.</p>
<p>Основываясь на этом наблюдении, мы можем изменить порядок извлечения фрагментов, чтобы улучшить качество ответа: при извлечении нескольких фрагментов знаний фрагменты с относительно низким уровнем доверия размещаются в середине, а фрагменты с относительно высоким уровнем доверия - на обоих концах.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/adjust_order.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="RAG-Pipeline-Enhancement" class="common-anchor-header">Улучшение конвейера RAG<button data-href="#RAG-Pipeline-Enhancement" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Мы также можем повысить производительность ваших приложений RAG, улучшив весь конвейер RAG.</p>
<h3 id="Self-reflection" class="common-anchor-header">Саморефлексия</h3><p>Этот подход включает в себя концепцию саморефлексии в агентах ИИ. Как же работает эта техника?</p>
<p>Некоторые первоначально полученные фрагменты документов Top-K неоднозначны и могут не давать прямого ответа на вопрос пользователя. В таких случаях мы можем провести второй раунд размышлений, чтобы проверить, действительно ли эти фрагменты могут отвечать на запрос.</p>
<p>Для проверки можно использовать эффективные методы, такие как модели Natural Language Inference (NLI), или дополнительные инструменты, например поиск в Интернете.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/self_reflection.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Эта концепция саморефлексии была исследована в нескольких работах и проектах, включая <a href="https://arxiv.org/pdf/2310.11511.pdf">Self-RAG</a>, <a href="https://arxiv.org/pdf/2401.15884.pdf">Corrective RAG</a>, <a href="https://github.com/langchain-ai/langgraph/blob/main/examples/reflexion/reflexion.ipynb">LangGraph</a> и т. д.</p>
<h3 id="Query-Routing-with-an-Agent" class="common-anchor-header">Маршрутизация запросов с помощью агента</h3><p>Иногда нам не нужно использовать систему RAG для ответа на простые вопросы, так как это может привести к еще большему непониманию и выводам на основе недостоверной информации. В таких случаях мы можем использовать агента в качестве маршрутизатора на этапе запроса. Этот агент оценивает, должен ли запрос пройти через конвейер RAG. Если да, то запускается последующий конвейер RAG; в противном случае LLM обращается к запросу напрямую.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/query_routing.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>


  <span class="img-wrapper">
    <img translate="no" src="/docs/v2.6.x/assets/advanced_rag/query_routing_with_sub_query.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Агент может принимать различные формы, включая LLM, небольшую классификационную модель или даже набор правил.</p>
<p>Маршрутизация запросов на основе намерений пользователя позволяет перенаправить часть запросов, что приводит к значительному увеличению времени отклика и заметному уменьшению ненужного шума.</p>
<p>Мы можем распространить технику маршрутизации запросов на другие процессы в системе RAG, например определить, когда использовать такие инструменты, как веб-поиск, выполнение подзапросов или поиск изображений. Такой подход гарантирует, что каждый шаг в системе RAG будет оптимизирован на основе конкретных требований запроса, что приведет к более эффективному и точному поиску информации.</p>
<h2 id="Summary" class="common-anchor-header">Резюме<button data-href="#Summary" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Хотя ванильный конвейер RAG может показаться простым, для достижения оптимальной производительности бизнеса часто требуются более сложные методы оптимизации.</p>
<p>В этой статье мы обобщили различные популярные подходы к повышению производительности ваших RAG-приложений. Мы также привели наглядные иллюстрации, чтобы помочь вам быстро понять эти концепции и методы и ускорить их внедрение и оптимизацию.</p>
<p>Вы можете получить простые реализации основных подходов, перечисленных в статье, по этой <a href="https://github.com/milvus-io/bootcamp/tree/master/bootcamp/RAG/advanced_rag">ссылке на GitHub</a>.</p>
