---
id: data_processing.md
summary: Узнайте о процедуре обработки данных в Milvus.
title: Обработка данных
---
<h1 id="Data-Processing" class="common-anchor-header">Обработка данных<button data-href="#Data-Processing" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>В этой статье представлено подробное описание реализации в Milvus вставки данных, построения индекса и запроса данных.</p>
<h2 id="Data-insertion" class="common-anchor-header">Вставка данных<button data-href="#Data-insertion" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Для каждой коллекции в Milvus можно указать количество шардов, каждый из которых соответствует виртуальному каналу<em>(vchannel</em>). Как показано на следующем рисунке, Milvus назначает каждому vchannel в брокере журналов физический канал<em>(pchannel</em>). Любой входящий запрос на вставку/удаление направляется на шарды на основе хэш-значения первичного ключа.</p>
<p>Валидация DML-запросов переносится на прокси, поскольку в Milvus нет сложных транзакций. Прокси запрашивает временную метку для каждого запроса на вставку/удаление у TSO (Timestamp Oracle), который является модулем синхронизации, расположенным в корневом координаторе. Поскольку старая временная метка перезаписывается новой, временные метки используются для определения последовательности обрабатываемых запросов данных. Прокси получает информацию партиями из коорд данных, включая сегменты сущностей и первичные ключи, чтобы увеличить общую пропускную способность и избежать перегрузки центрального узла.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/channels_1.jpg" alt="Channels 1" class="doc-image" id="channels-1" />
   </span> <span class="img-wrapper"> <span>Каналы 1</span> </span></p>
<p>В журнал записываются как операции DML (язык манипулирования данными), так и операции DDL (язык определения данных), но операциям DDL назначается только один канал из-за их низкой частоты появления.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/channels_2.jpg" alt="Channels 2" class="doc-image" id="channels-2" />
   </span> <span class="img-wrapper"> <span>Каналы 2</span> </span></p>
<p><em>V каналов</em> хранятся в базовых узлах брокера журналов. Каждый канал физически неделим и доступен для любого, но только одного узла. Когда скорость поступления данных достигает узкого места, следует обратить внимание на две вещи: перегружен ли узел брокера журналов и нуждается ли он в масштабировании, и достаточно ли шардов для обеспечения баланса нагрузки на каждом узле.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/write_log_sequence.jpg" alt="Write log sequence" class="doc-image" id="write-log-sequence" />
   </span> <span class="img-wrapper"> <span>Последовательность записи журнала</span> </span></p>
<p>На приведенной выше схеме показаны четыре компонента, участвующие в процессе записи последовательности журналов: прокси, брокер журналов, узел данных и хранилище объектов. Процесс включает в себя четыре задачи: проверку DML-запросов, публикацию-подписку последовательности журналов, преобразование потокового журнала в снимки журналов и сохранение снимков журналов. Эти четыре задачи отделены друг от друга, чтобы убедиться, что каждая из них выполняется узлом соответствующего типа. Узлы одного и того же типа являются равноправными и могут эластично и независимо масштабироваться для работы с различными нагрузками данных, в частности с массивными и сильно колеблющимися потоковыми данными.</p>
<h2 id="Index-building" class="common-anchor-header">Построение индекса<button data-href="#Index-building" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Построение индекса осуществляется индексным узлом. Чтобы избежать частого создания индекса при обновлении данных, коллекция в Milvus делится на сегменты, каждый из которых имеет свой собственный индекс.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/index_building.jpg" alt="Index building" class="doc-image" id="index-building" />
   </span> <span class="img-wrapper"> <span>Построение индекса</span> </span></p>
<p>Milvus поддерживает построение индекса для каждого векторного поля, скалярного поля и первичного поля. Как на входе, так и на выходе построения индекса происходит взаимодействие с хранилищем объектов: Индексный узел загружает снимки журнала для индексирования из сегмента (который находится в объектном хранилище) в память, десериализует соответствующие данные и метаданные для построения индекса, сериализует индекс по завершении построения индекса и записывает его обратно в объектное хранилище.</p>
<p>Построение индекса в основном включает в себя операции с векторами и матрицами и, следовательно, требует больших затрат вычислений и памяти. Векторы не могут быть эффективно проиндексированы традиционными древовидными индексами из-за их высокой размерности, но могут быть проиндексированы методами, которые более развиты в этой области, такими как кластерные или графовые индексы. Независимо от типа, построение индекса предполагает массивные итерационные вычисления для крупномасштабных векторов, такие как Kmeans или graph traverse.</p>
<p>В отличие от индексирования скалярных данных, построение векторного индекса должно в полной мере использовать преимущества ускорения SIMD (single instruction, multiple data). Milvus имеет встроенную поддержку наборов инструкций SIMD, например, SSE, AVX2 и AVX512. Учитывая "заминки" и ресурсоемкость построения векторных индексов, эластичность приобретает для Milvus решающее значение с экономической точки зрения. В будущих релизах Milvus будут продолжены исследования в области гетерогенных вычислений и бессерверных вычислений для снижения соответствующих затрат.</p>
<p>Кроме того, Milvus поддерживает скалярную фильтрацию и запросы по первичному полю. Для повышения эффективности запросов в нем имеются встроенные индексы, например, индексы фильтра Блума, хеш-индексы, древовидные индексы и инвертированные индексы, а также планируется внедрение внешних индексов, например, растровых индексов и грубых индексов.</p>
<h2 id="Data-query" class="common-anchor-header">Запрос данных<button data-href="#Data-query" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Запрос данных - это процесс поиска в заданной коллекции <em>k-го</em> количества векторов, ближайших к целевому вектору, или <em>всех</em> векторов в заданном диапазоне расстояний до вектора. Векторы возвращаются вместе с соответствующими первичными ключами и полями.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/data_query.jpg" alt="Data query" class="doc-image" id="data-query" />
   </span> <span class="img-wrapper"> <span>Запрос данных</span> </span></p>
<p>Коллекция в Milvus разбивается на множество сегментов, а узлы запросов загружают индексы по сегментам. Когда поступает поисковый запрос, он транслируется на все узлы запроса для одновременного поиска. Затем каждый узел обрезает локальные сегменты, ищет векторы, удовлетворяющие критериям, сводит и возвращает результаты поиска.</p>
<p>При запросе данных узлы запроса независимы друг от друга. Каждый узел отвечает только за две задачи: Загружать или освобождать сегменты, следуя инструкциям коорд запроса; проводить поиск в локальных сегментах. А прокси отвечает за сокращение результатов поиска от каждого узла запроса и возврат окончательных результатов клиенту.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/handoff.jpg" alt="Handoff" class="doc-image" id="handoff" />
   </span> <span class="img-wrapper"> <span>Передача</span> </span></p>
<p>Существует два типа сегментов: растущие сегменты (для инкрементных данных) и закрытые сегменты (для исторических данных). Узлы запросов подписываются на vchannel, чтобы получать последние обновления (инкрементные данные) в виде растущих сегментов. Когда растущий сегмент достигает заданного порога, координатор данных запечатывает его и начинается построение индекса. Затем операция <em>передачи</em>, инициированная координатором запросов, превращает инкрементные данные в исторические. Координатор запросов равномерно распределяет запечатанные сегменты между всеми узлами запросов в соответствии с использованием памяти, нагрузкой на процессор и количеством сегментов.</p>
<h2 id="Whats-next" class="common-anchor-header">Что дальше<button data-href="#Whats-next" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li>Узнайте, как <a href="https://milvus.io/blog/deep-dive-5-real-time-query.md">использовать векторную базу данных Milvus для запросов в реальном времени</a>.</li>
<li>Узнайте о <a href="https://milvus.io/blog/deep-dive-4-data-insertion-and-data-persistence.md">вставке и сохранении данных в Milvus</a>.</li>
<li>Узнайте, как <a href="https://milvus.io/blog/deep-dive-3-data-processing.md">обрабатываются данные в Milvus</a>.</li>
</ul>
