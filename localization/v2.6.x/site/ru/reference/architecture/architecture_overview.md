---
id: architecture_overview.md
summary: >-
  Milvus - это быстрая, надежная и стабильная база данных векторов, созданная
  специально для поиска сходств и искусственного интеллекта.
title: Обзор архитектуры Milvus
---
<h1 id="Milvus-Architecture-Overview" class="common-anchor-header">Обзор архитектуры Milvus<button data-href="#Milvus-Architecture-Overview" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>Milvus - это <strong>облачная</strong> векторная база данных <strong>с открытым исходным кодом</strong>, предназначенная для высокопроизводительного поиска сходства в массивных векторных массивах данных. Построенная на базе популярных библиотек векторного поиска, таких как Faiss, HNSW, DiskANN и SCANN, она позволяет использовать приложения искусственного интеллекта и сценарии поиска неструктурированных данных. Прежде чем продолжить, ознакомьтесь с <a href="/docs/ru/glossary.md">основными принципами</a> поиска по вкраплениям.</p>
<h2 id="Architecture-Diagram" class="common-anchor-header">Диаграмма архитектуры<button data-href="#Architecture-Diagram" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Следующая диаграмма иллюстрирует высокоуровневую архитектуру Milvus, демонстрируя ее модульную, масштабируемую и облачную конструкцию с полностью дезагрегированными слоями хранения и вычислений.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/milvus_architecture_2_6.png" alt="Architecture_diagram" class="doc-image" id="architecture_diagram" />
   </span> <span class="img-wrapper"> <span>Архитектура_диаграммы</span> </span></p>
<h2 id="Architectural-Principles" class="common-anchor-header">Архитектурные принципы<button data-href="#Architectural-Principles" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Milvus следует принципу дезагрегации плоскости данных и плоскости управления, состоящему из четырех основных уровней, которые являются взаимно независимыми с точки зрения масштабируемости и аварийного восстановления. Эта архитектура с общим хранилищем и полностью дезагрегированными уровнями хранения и вычислений позволяет горизонтально масштабировать вычислительные узлы, а также реализовать Woodpecker в качестве WAL-уровня с нулевым диском для повышения эластичности и снижения эксплуатационных накладных расходов.</p>
<p>Благодаря разделению потоковой обработки на Streaming Node и пакетной обработки на Query Node и Data Node, Milvus достигает высокой производительности при одновременном удовлетворении требований к обработке данных в реальном времени.</p>
<h2 id="Detailed-Layer-Architecture" class="common-anchor-header">Детальная архитектура уровней<button data-href="#Detailed-Layer-Architecture" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Layer-1-Access-Layer" class="common-anchor-header">Уровень 1: уровень доступа</h3><p>Состоящий из группы нестационарных прокси-серверов, уровень доступа является передним уровнем системы и конечной точкой для пользователей. Он проверяет запросы клиентов и сокращает возвращаемые результаты:</p>
<ul>
<li>Прокси сам по себе не имеет статусов. Он обеспечивает единый адрес сервиса, используя компоненты балансировки нагрузки, такие как Nginx, Kubernetes Ingress, NodePort и LVS.</li>
<li>Поскольку в Milvus используется архитектура массивно-параллельной обработки (MPP), прокси агрегирует и обрабатывает промежуточные результаты, прежде чем вернуть окончательные результаты клиенту.</li>
</ul>
<h3 id="Layer-2-Coordinator" class="common-anchor-header">Уровень 2: Координатор</h3><p>Координатор служит мозгом Milvus. В любой момент времени во всем кластере активен ровно один координатор, который отвечает за поддержание топологии кластера, планирование всех типов задач и обеспечение согласованности на уровне кластера.</p>
<p>Ниже перечислены некоторые задачи, решаемые <strong>координатором</strong>:</p>
<ul>
<li><strong>Управление DDL/DCL/TSO</strong>: Обрабатывает запросы языка определения данных (DDL) и языка управления данными (DCL), такие как создание или удаление коллекций, разделов или индексов, а также управление временными метками Oracle (TSO) и выдачей временных тикеров.</li>
<li><strong>Управление потоковыми службами</strong>: Связывает журнал Write-Ahead Log (WAL) с потоковыми узлами и обеспечивает обнаружение сервисов для потоковой службы.</li>
<li><strong>Управление запросами</strong>: Управляет топологией и балансировкой нагрузки для узлов запросов, а также предоставляет и управляет представлениями запросов для маршрутизации запросов.</li>
<li><strong>Управление историческими данными</strong>: Распределяет автономные задачи, такие как уплотнение и создание индексов, между узлами данных, а также управляет топологией сегментов и представлений данных.</li>
</ul>
<h3 id="Layer-3-Worker-Nodes" class="common-anchor-header">Уровень 3: рабочие узлы</h3><p>Руки и ноги. Рабочие узлы - это немые исполнители, которые выполняют указания координатора. Рабочие узлы не имеют статических данных благодаря разделению хранения и вычислений и могут способствовать масштабированию системы и аварийному восстановлению при развертывании на Kubernetes. Существует три типа рабочих узлов:</p>
<h3 id="Streaming-node" class="common-anchor-header">Потоковый узел</h3><p>Потоковый узел служит "мини-мозгом" на уровне сервера, обеспечивая гарантии согласованности на уровне сервера и восстановление после сбоев на основе базового хранилища WAL. Кроме того, Streaming Node отвечает за запросы к растущим данным и генерирует планы запросов. Кроме того, он также занимается преобразованием растущих данных в закрытые (исторические) данные.</p>
<h3 id="Query-node" class="common-anchor-header">Узел запросов</h3><p>Узел запросов загружает исторические данные из объектного хранилища и обеспечивает запрос исторических данных.</p>
<h3 id="Data-node" class="common-anchor-header">Узел данных</h3><p>Узел данных отвечает за автономную обработку исторических данных, такую как уплотнение и построение индексов.</p>
<h3 id="Layer-4-Storage" class="common-anchor-header">Уровень 4: Хранилище</h3><p>Хранилище - это костяк системы, отвечающий за сохранение данных. Оно включает в себя метахранилище, брокер журналов и хранилище объектов.</p>
<h3 id="Meta-storage" class="common-anchor-header">Метахранилище</h3><p>Метахранилище хранит снимки метаданных, таких как схема коллекции и контрольные точки потребления сообщений. Хранение метаданных требует чрезвычайно высокой доступности, высокой согласованности и поддержки транзакций, поэтому Milvus выбрал etcd для метахранилища. Milvus также использует etcd для регистрации и проверки работоспособности сервисов.</p>
<h3 id="Object-storage" class="common-anchor-header">Объектное хранилище</h3><p>В объектном хранилище хранятся файлы моментальных снимков журналов, индексные файлы для скалярных и векторных данных, а также промежуточные результаты запросов. Milvus использует MinIO в качестве объектного хранилища и может быть легко развернут на AWS S3 и Azure Blob, двух самых популярных и экономически эффективных сервисах хранения данных в мире. Однако объектное хранилище имеет высокую задержку доступа и тарифицируется по количеству запросов. Чтобы повысить производительность и снизить затраты, Milvus планирует реализовать разделение данных "холодный-горячий" в пуле кэша на базе памяти или SSD.</p>
<h3 id="WAL-storage" class="common-anchor-header">Хранилище WAL</h3><p>Хранение журнала с опережающей записью (WAL) - основа долговечности и согласованности данных в распределенных системах. Перед фиксацией любого изменения оно сначала записывается в журнал, что гарантирует, что в случае сбоя вы сможете восстановить именно то, на чем остановились.</p>
<p>К распространенным реализациям WAL относятся Kafka, Pulsar и Woodpecker. В отличие от традиционных дисковых решений, Woodpecker использует "облачный" дизайн с нулевым диском, который записывает данные непосредственно в объектное хранилище. Такой подход легко масштабируется в зависимости от ваших потребностей и упрощает работу, устраняя накладные расходы на управление локальными дисками.</p>
<p>Заранее регистрируя каждую операцию записи, уровень WAL гарантирует надежный общесистемный механизм восстановления и согласованности - независимо от того, насколько сложной становится ваша распределенная среда.</p>
<h2 id="Data-Flow-and-API-Categories" class="common-anchor-header">Поток данных и категории API<button data-href="#Data-Flow-and-API-Categories" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>API Milvus классифицируются по функциям и следуют определенным путям в архитектуре:</p>
<table>
<thead>
<tr><th>Категория API</th><th>Операции</th><th>Примеры API</th><th>Архитектурный поток</th></tr>
</thead>
<tbody>
<tr><td><strong>DDL/DCL</strong></td><td>Схема и контроль доступа</td><td><code translate="no">createCollection</code>, <code translate="no">dropCollection</code>, <code translate="no">hasCollection</code>, <code translate="no">createPartition</code></td><td>Уровень доступа → Координатор</td></tr>
<tr><td><strong>DML</strong></td><td>Манипулирование данными</td><td><code translate="no">insert</code>, <code translate="no">delete</code>, <code translate="no">upsert</code></td><td>Уровень доступа → Потоковый рабочий узел</td></tr>
<tr><td><strong>DQL</strong></td><td>Запрос данных</td><td><code translate="no">search</code>, <code translate="no">query</code></td><td>Уровень доступа → пакетный рабочий узел (узлы запросов)</td></tr>
</tbody>
</table>
<h3 id="Example-Data-Flow-Search-Operation" class="common-anchor-header">Пример потока данных: операция поиска</h3><ol>
<li>Клиент отправляет запрос на поиск через SDK/RESTful API</li>
<li>Балансировщик нагрузки направляет запрос к доступному прокси на уровне доступа</li>
<li>Прокси использует кэш маршрутизации для определения целевых узлов; обращается к координатору, только если кэш недоступен</li>
<li>Прокси направляет запрос на соответствующие узлы потоковой передачи, которые затем координируются с узлами запросов для поиска запечатанных данных, выполняя поиск растущих данных локально</li>
<li>Узлы запросов загружают запечатанные сегменты из хранилища объектов по мере необходимости и выполняют поиск на уровне сегментов</li>
<li>Результаты поиска подвергаются многоуровневой редукции: узлы запросов сокращают результаты по нескольким сегментам, узлы потоковой передачи сокращают результаты узлов запросов, а прокси сокращает результаты всех узлов потоковой передачи перед возвращением клиенту</li>
</ol>
<h3 id="Example-Data-Flow-Data-Insertion" class="common-anchor-header">Пример потока данных: вставка данных</h3><ol>
<li>Клиент отправляет запрос на вставку с векторными данными</li>
<li>Уровень доступа проверяет и пересылает запрос на узел потоковой обработки</li>
<li>Потоковый узел регистрирует операцию в хранилище WAL для долговечности</li>
<li>Данные обрабатываются в реальном времени и становятся доступными для запросов</li>
<li>Когда сегменты достигают емкости, потоковый узел запускает преобразование в закрытые сегменты</li>
<li>Узел данных обрабатывает уплотнение и строит индексы поверх закрытых сегментов, сохраняя результаты в хранилище объектов.</li>
<li>Узлы запросов загружают вновь созданные индексы и заменяют соответствующие растущие данные</li>
</ol>
<h2 id="Whats-Next" class="common-anchor-header">Что дальше<button data-href="#Whats-Next" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li>Изучите <a href="/docs/ru/main_components.md">основные компоненты</a> для получения подробной информации о реализации</li>
<li>Узнайте о рабочих процессах <a href="/docs/ru/data_processing.md">обработки данных</a> и стратегиях оптимизации</li>
<li>Поймите <a href="/docs/ru/consistency.md">модель согласованности</a> и гарантии транзакций в Milvus</li>
</ul>
