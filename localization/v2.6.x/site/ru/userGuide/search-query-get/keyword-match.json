{"codeList":["from pymilvus import MilvusClient, DataType\n\nschema = MilvusClient.create_schema(enable_dynamic_field=False)\nschema.add_field(\n    field_name=\"id\",\n    datatype=DataType.INT64,\n    is_primary=True,\n    auto_id=True\n)\nschema.add_field(\n    field_name='text', \n    datatype=DataType.VARCHAR, \n    max_length=1000, \n    enable_analyzer=True, # Whether to enable text analysis for this field\n    enable_match=True # Whether to enable text match\n)\nschema.add_field(\n    field_name=\"embeddings\",\n    datatype=DataType.FLOAT_VECTOR,\n    dim=5\n)\n","import io.milvus.v2.common.DataType;\nimport io.milvus.v2.service.collection.request.AddFieldReq;\nimport io.milvus.v2.service.collection.request.CreateCollectionReq;\n\nCreateCollectionReq.CollectionSchema schema = CreateCollectionReq.CollectionSchema.builder()\n        .enableDynamicField(false)\n        .build();\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"id\")\n        .dataType(DataType.Int64)\n        .isPrimaryKey(true)\n        .autoID(true)\n        .build());\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"text\")\n        .dataType(DataType.VarChar)\n        .maxLength(1000)\n        .enableAnalyzer(true)\n        .enableMatch(true)\n        .build());\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"embeddings\")\n        .dataType(DataType.FloatVector)\n        .dimension(5)\n        .build());\n","import \"github.com/milvus-io/milvus/client/v2/entity\"\n\nschema := entity.NewSchema().WithDynamicFieldEnabled(false)\nschema.WithField(entity.NewField().\n    WithName(\"id\").\n    WithDataType(entity.FieldTypeInt64).\n    WithIsPrimaryKey(true).\n    WithIsAutoID(true),\n).WithField(entity.NewField().\n    WithName(\"text\").\n    WithDataType(entity.FieldTypeVarChar).\n    WithEnableAnalyzer(true).\n    WithEnableMatch(true).\n    WithMaxLength(1000),\n).WithField(entity.NewField().\n    WithName(\"embeddings\").\n    WithDataType(entity.FieldTypeFloatVector).\n    WithDim(5),\n)\n","const schema = [\n  {\n    name: \"id\",\n    data_type: DataType.Int64,\n    is_primary_key: true,\n  },\n  {\n    name: \"text\",\n    data_type: \"VarChar\",\n    enable_analyzer: true,\n    enable_match: true,\n    max_length: 1000,\n  },\n  {\n    name: \"embeddings\",\n    data_type: DataType.FloatVector,\n    dim: 5,\n  },\n];\n","export schema='{\n        \"autoId\": true,\n        \"enabledDynamicField\": false,\n        \"fields\": [\n            {\n                \"fieldName\": \"id\",\n                \"dataType\": \"Int64\",\n                \"isPrimary\": true\n            },\n            {\n                \"fieldName\": \"text\",\n                \"dataType\": \"VarChar\",\n                \"elementTypeParams\": {\n                    \"max_length\": 1000,\n                    \"enable_analyzer\": true,\n                    \"enable_match\": true\n                }\n            },\n            {\n                \"fieldName\": \"embeddings\",\n                \"dataType\": \"FloatVector\",\n                \"elementTypeParams\": {\n                    \"dim\": \"5\"\n                }\n            }\n        ]\n    }'\n","analyzer_params = {\n    \"type\": \"english\"\n}\nschema.add_field(\n    field_name='text',\n    datatype=DataType.VARCHAR,\n    max_length=200,\n    enable_analyzer=True,\n    analyzer_params = analyzer_params,\n    enable_match = True,\n)\n","Map<String, Object> analyzerParams = new HashMap<>();\nanalyzerParams.put(\"type\", \"english\");\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"text\")\n        .dataType(DataType.VarChar)\n        .maxLength(200)\n        .enableAnalyzer(true)\n        .analyzerParams(analyzerParams)\n        .enableMatch(true)\n        .build());\n","analyzerParams := map[string]any{\"type\": \"english\"}\nschema.WithField(entity.NewField().\n    WithName(\"text\").\n    WithDataType(entity.FieldTypeVarChar).\n    WithEnableAnalyzer(true).\n    WithEnableMatch(true).\n    WithAnalyzerParams(analyzerParams).\n    WithMaxLength(200),\n)\n","const schema = [\n  {\n    name: \"id\",\n    data_type: DataType.Int64,\n    is_primary_key: true,\n  },\n  {\n    name: \"text\",\n    data_type: \"VarChar\",\n    enable_analyzer: true,\n    enable_match: true,\n    max_length: 1000,\n    analyzer_params: { type: 'english' },\n  },\n  {\n    name: \"embeddings\",\n    data_type: DataType.FloatVector,\n    dim: 5,\n  },\n];\n","export schema='{\n        \"autoId\": true,\n        \"enabledDynamicField\": false,\n        \"fields\": [\n            {\n                \"fieldName\": \"id\",\n                \"dataType\": \"Int64\",\n                \"isPrimary\": true\n            },\n            {\n                \"fieldName\": \"text\",\n                \"dataType\": \"VarChar\",\n                \"elementTypeParams\": {\n                    \"max_length\": 200,\n                    \"enable_analyzer\": true,\n                    \"enable_match\": true,\n                    \"analyzer_params\": {\"type\": \"english\"}\n                }\n            },\n            {\n                \"fieldName\": \"embeddings\",\n                \"dataType\": \"FloatVector\",\n                \"elementTypeParams\": {\n                    \"dim\": \"5\"\n                }\n            }\n        ]\n    }'\n","TEXT_MATCH(field_name, text)\n","filter = \"TEXT_MATCH(text, 'machine deep')\"\n","String filter = \"TEXT_MATCH(text, 'machine deep')\";\n","filter := \"TEXT_MATCH(text, 'machine deep')\"\n","const filter = \"TEXT_MATCH(text, 'machine deep')\";\n","export filter=\"\\\"TEXT_MATCH(text, 'machine deep')\\\"\"\n","filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\"\n","String filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\";\n","filter := \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\"\n","const filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\"\n","export filter=\"\\\"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\\\"\"\n","filter = \"not TEXT_MATCH(text, 'deep') and TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'learning')\"\n","String filter = \"not TEXT_MATCH(text, 'deep') and TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'learning')\";\n","filter := \"not TEXT_MATCH(text, 'deep') and TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'learning')\"\n","const filter = \"not TEXT_MATCH(text, 'deep') and TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'learning')\";\n","export filter=\"\\\"not TEXT_MATCH(text, 'deep') and TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'learning')\\\"\"\n","# Match entities with `keyword1` or `keyword2`\nfilter = \"TEXT_MATCH(text, 'keyword1 keyword2')\"\n\n# Assuming 'embeddings' is the vector field and 'text' is the VARCHAR field\nresult = client.search(\n    collection_name=\"my_collection\", # Your collection name\n    anns_field=\"embeddings\", # Vector field name\n    data=[query_vector], # Query vector\n    filter=filter,\n    search_params={\"params\": {\"nprobe\": 10}},\n    limit=10, # Max. number of results to return\n    output_fields=[\"id\", \"text\"] # Fields to return\n)\n","String filter = \"TEXT_MATCH(text, 'keyword1 keyword2')\";\n\nSearchResp searchResp = client.search(SearchReq.builder()\n        .collectionName(\"my_collection\")\n        .annsField(\"embeddings\")\n        .data(Collections.singletonList(queryVector)))\n        .filter(filter)\n        .topK(10)\n        .outputFields(Arrays.asList(\"id\", \"text\"))\n        .build());\n","filter := \"TEXT_MATCH(text, 'keyword1 keyword2')\"\n\nresultSets, err := client.Search(ctx, milvusclient.NewSearchOption(\n    \"my_collection\", // collectionName\n    10,               // limit\n    []entity.Vector{entity.FloatVector(queryVector)},\n).WithANNSField(\"embeddings\").\n    WithFilter(filter).\n    WithOutputFields(\"id\", \"text\"))\nif err != nil {\n    fmt.Println(err.Error())\n    // handle error\n}\n","// Match entities with `keyword1` or `keyword2`\nconst filter = \"TEXT_MATCH(text, 'keyword1 keyword2')\";\n\n// Assuming 'embeddings' is the vector field and 'text' is the VARCHAR field\nconst result = await client.search(\n    collection_name: \"my_collection\", // Your collection name\n    anns_field: \"embeddings\", // Vector field name\n    data: [query_vector], // Query vector\n    filter: filter,\n    params: {\"nprobe\": 10},\n    limit: 10, // Max. number of results to return\n    output_fields: [\"id\", \"text\"] //Fields to return\n);\n","export filter=\"\\\"TEXT_MATCH(text, 'keyword1 keyword2')\\\"\"\n\nexport CLUSTER_ENDPOINT=\"http://localhost:19530\"\nexport TOKEN=\"root:Milvus\"\n\ncurl --request POST \\\n--url \"${CLUSTER_ENDPOINT}/v2/vectordb/entities/search\" \\\n--header \"Authorization: Bearer ${TOKEN}\" \\\n--header \"Content-Type: application/json\" \\\n-d '{\n    \"collectionName\": \"my_collection\",\n    \"annsField\": \"embeddings\",\n    \"data\": [[0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104]],\n    \"filter\": '\"$filter\"',\n    \"searchParams\": {\n        \"params\": {\n            \"nprobe\": 10\n        }\n    },\n    \"limit\": 10,\n    \"outputFields\": [\"text\",\"id\"]\n}'\n","# Match entities with both `keyword1` and `keyword2`\nfilter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\"\n\nresult = client.query(\n    collection_name=\"my_collection\",\n    filter=filter, \n    output_fields=[\"id\", \"text\"]\n)\n","String filter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\";\n\nQueryResp queryResp = client.query(QueryReq.builder()\n        .collectionName(\"my_collection\")\n        .filter(filter)\n        .outputFields(Arrays.asList(\"id\", \"text\"))\n        .build()\n);\n","filter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\"\nresultSet, err := client.Query(ctx, milvusclient.NewQueryOption(\"my_collection\").\n    WithFilter(filter).\n    WithOutputFields(\"id\", \"text\"))\nif err != nil {\n    fmt.Println(err.Error())\n    // handle error\n}\n\n","// Match entities with both `keyword1` and `keyword2`\nconst filter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\";\n\nconst result = await client.query(\n    collection_name: \"my_collection\",\n    filter: filter, \n    output_fields: [\"id\", \"text\"]\n)\n","export filter=\"\\\"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\\\"\"\n\nexport CLUSTER_ENDPOINT=\"http://localhost:19530\"\nexport TOKEN=\"root:Milvus\"\n\ncurl --request POST \\\n--url \"${CLUSTER_ENDPOINT}/v2/vectordb/entities/query\" \\\n--header \"Authorization: Bearer ${TOKEN}\" \\\n--header \"Content-Type: application/json\" \\\n-d '{\n    \"collectionName\": \"my_collection\",\n    \"filter\": '\"$filter\"',\n    \"outputFields\": [\"id\", \"text\"]\n}'\n"],"headingContent":"Text Match","anchorList":[{"label":"Text Match","href":"Text-Match","type":1,"isActive":false},{"label":"Overview","href":"Overview","type":2,"isActive":false},{"label":"Enable text match","href":"Enable-text-match","type":2,"isActive":false},{"label":"Use text match","href":"Use-text-match","type":2,"isActive":false},{"label":"Considerations","href":"Considerations","type":2,"isActive":false}]}