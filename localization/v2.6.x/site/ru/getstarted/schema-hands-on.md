---
id: schema-hands-on.md
title: Проектирование модели данных для поиска
summary: >-
  Информационно-поисковые системы, также известные как поисковые системы,
  необходимы для различных приложений искусственного интеллекта, таких как поиск
  с расширением (RAG), визуальный поиск и рекомендации товаров. В основе этих
  систем лежит тщательно разработанная модель данных для организации,
  индексирования и поиска информации.
---
<h1 id="Data-Model-Design-for-Search" class="common-anchor-header">Проектирование модели данных для поиска<button data-href="#Data-Model-Design-for-Search" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>Информационно-поисковые системы, также известные как поисковые системы, необходимы для различных приложений искусственного интеллекта, таких как поиск с расширением (RAG), визуальный поиск и рекомендации товаров. В основе этих систем лежит тщательно разработанная модель данных для организации, индексирования и получения информации.</p>
<p>Milvus позволяет задать модель поисковых данных с помощью схемы коллекции, организующей неструктурированные данные, их плотные или разреженные векторные представления и структурированные метаданные. Независимо от того, работаете ли вы с текстом, изображениями или другими типами данных, это практическое руководство поможет вам понять и применить ключевые концепции схем для разработки модели поисковых данных на практике.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/data-model-anatomy.png" alt="Data Model Anatomy" class="doc-image" id="data-model-anatomy" />
   </span> <span class="img-wrapper"> <span>Анатомия модели данных</span> </span></p>
<h2 id="Data-Model" class="common-anchor-header">Модель данных<button data-href="#Data-Model" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Проектирование модели данных поисковой системы включает в себя анализ потребностей бизнеса и абстрагирование информации в виде модели данных, выраженной в виде схемы. Хорошо определенная схема важна для согласования модели данных с бизнес-целями, обеспечения согласованности данных и качества обслуживания.  Кроме того, выбор правильных типов данных и индексов важен для экономичного достижения бизнес-цели.</p>
<h3 id="Analyzing-Business-Needs" class="common-anchor-header">Анализ потребностей бизнеса</h3><p>Эффективное удовлетворение потребностей бизнеса начинается с анализа типов запросов, которые будут выполнять пользователи, и определения наиболее подходящих методов поиска.</p>
<ul>
<li><p><strong>Запросы пользователей:</strong> Определите типы запросов, которые, как ожидается, будут выполнять пользователи. Это поможет убедиться, что ваша схема поддерживает реальные сценарии использования и оптимизирует производительность поиска. К ним могут относиться:</p>
<ul>
<li><p>поиск документов, соответствующих запросу на естественном языке</p></li>
<li><p>Поиск изображений, похожих на эталонное изображение или соответствующих текстовому описанию</p></li>
<li><p>Поиск товаров по таким атрибутам, как название, категория или бренд.</p></li>
<li><p>фильтрация элементов на основе структурированных метаданных (например, дата публикации, теги, рейтинги)</p></li>
<li><p>Комбинирование нескольких критериев в гибридных запросах (например, при визуальном поиске учитывается семантическое сходство как изображений, так и подписей к ним).</p></li>
</ul></li>
<li><p><strong>Методы поиска:</strong> Выберите подходящие методы поиска, соответствующие типам запросов, которые будут выполнять ваши пользователи. Различные методы служат разным целям и часто могут быть объединены для получения более мощных результатов:</p>
<ul>
<li><p><strong>Семантический поиск</strong>: Использует плотное векторное сходство для поиска элементов с похожим смыслом, идеально подходит для неструктурированных данных, таких как текст или изображения.</p></li>
<li><p><strong>Полнотекстовый поиск</strong>: Дополняет семантический поиск поиском по ключевым словам.  Полнотекстовый поиск может использовать лексический анализ, чтобы не разбивать длинные слова на фрагменты, а в процессе поиска улавливать специальные термины.</p></li>
<li><p><strong>Фильтрация метаданных</strong>: Поверх векторного поиска, применение ограничений, таких как диапазоны дат, категории или теги.</p></li>
</ul></li>
</ul>
<h3 id="Translates-Business-Requirements-into-a-Search-Data-Model" class="common-anchor-header">Перевод бизнес-требований в модель поисковых данных</h3><p>Следующий шаг - преобразование бизнес-требований в конкретную модель данных путем определения основных компонентов информации и методов их поиска:</p>
<ul>
<li><p>Определите данные, которые необходимо хранить: необработанный контент (текст, изображения, аудио), связанные метаданные (заголовки, теги, авторство) и контекстные атрибуты (временные метки, поведение пользователей и т. д.).</p></li>
<li><p>Определите подходящие типы и форматы данных для каждого элемента. Например:</p>
<ul>
<li><p>Текстовые описания → строка</p></li>
<li><p>Вложения изображений или документов → плотные или разреженные векторы</p></li>
<li><p>Категории, теги или флаги → строки, массивы и bool</p></li>
<li><p>Числовые атрибуты, такие как цена или рейтинг → integer или float</p></li>
<li><p>Структурированная информация, например, данные об авторе -&gt; json</p></li>
</ul></li>
</ul>
<p>Четкое определение этих элементов обеспечивает согласованность данных, точность результатов поиска и простоту интеграции с логикой последующих приложений.</p>
<h2 id="Schema-Design" class="common-anchor-header">Разработка схемы<button data-href="#Schema-Design" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В Milvus модель данных выражается через схему коллекции. Разработка правильных полей в схеме коллекции - это ключ к эффективному поиску. Каждое поле определяет конкретный тип данных, хранящихся в коллекции, и играет определенную роль в процессе поиска. На высоком уровне Milvus поддерживает два основных типа полей: <strong>векторные</strong> и <strong>скалярные</strong>.</p>
<p>Теперь вы можете отобразить свою модель данных в схему полей, включая векторы и любые вспомогательные скалярные поля. Убедитесь, что каждое поле соотносится с атрибутами вашей модели данных, особенно обратите внимание на тип вектора (dense или spase) и его размерность.</p>
<h3 id="Vector-Field" class="common-anchor-header">Векторное поле</h3><p>Векторные поля хранят вкрапления для неструктурированных типов данных, таких как текст, изображения и аудио. Эти вкрапления могут быть плотными, разреженными или двоичными, в зависимости от типа данных и используемого метода поиска. Как правило, плотные векторы используются для семантического поиска, в то время как разреженные векторы лучше подходят для полнотекстового или лексического поиска. Двоичные векторы полезны при ограниченном объеме памяти и вычислительных ресурсов. Коллекция может содержать несколько векторных полей, что позволяет использовать мультимодальные или гибридные стратегии поиска. Подробное руководство по этой теме см. в разделе <a href="/docs/ru/multi-vector-search.md">Многовекторный гибридный поиск</a>.</p>
<p>Milvus поддерживает типы векторных данных: <code translate="no">FLOAT_VECTOR</code> для <a href="/docs/ru/dense-vector.md">плотного вектора</a>, <code translate="no">SPARSE_FLOAT_VECTOR</code> для <a href="/docs/ru/sparse_vector.md">разреженного вектора</a> и <code translate="no">BINARY_VECTOR</code> для <a href="/docs/ru/binary-vector.md">двоичного вектора.</a></p>
<h3 id="Scalar-Field" class="common-anchor-header">Скалярное поле</h3><p>Скалярные поля хранят примитивные, структурированные значения, обычно называемые метаданными, такие как числа, строки или даты. Эти значения могут быть возвращены вместе с результатами векторного поиска и необходимы для фильтрации и сортировки. Они позволяют сузить результаты поиска по определенным признакам, например, ограничить документы определенной категорией или определенным временным диапазоном.</p>
<p>Milvus поддерживает скалярные типы, такие как <code translate="no">BOOL</code>, <code translate="no">INT8/16/32/64</code>, <code translate="no">FLOAT</code>, <code translate="no">DOUBLE</code>, <code translate="no">VARCHAR</code>, <code translate="no">JSON</code> и <code translate="no">ARRAY</code> для хранения и фильтрации невекторных данных. Эти типы повышают точность и настраиваемость операций поиска.</p>
<h2 id="Leverage-Advanced-Features-in-Schema-Design" class="common-anchor-header">Использование расширенных возможностей при разработке схем<button data-href="#Leverage-Advanced-Features-in-Schema-Design" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>При разработке схемы недостаточно просто сопоставить данные с полями, используя поддерживаемые типы данных. Необходимо хорошо понимать взаимосвязи между полями и стратегии, доступные для настройки. Учет ключевых особенностей на этапе проектирования гарантирует, что схема будет не только соответствовать текущим требованиям к обработке данных, но и будет масштабируемой и адаптируемой к будущим потребностям. Тщательно интегрировав эти функции, вы сможете построить надежную архитектуру данных, которая максимально использует возможности Milvus и поддерживает вашу более широкую стратегию и цели в области данных. Ниже приведен обзор ключевых особенностей создания схемы коллекции:</p>
<h3 id="Primary-Key" class="common-anchor-header">Первичный ключ</h3><p>Поле первичного ключа является основополагающим компонентом схемы, поскольку оно однозначно идентифицирует каждую сущность в коллекции. Определение первичного ключа является обязательным. Это должно быть скалярное поле целого или строкового типа, помеченное как <code translate="no">is_primary=True</code>. В качестве опции можно включить <code translate="no">auto_id</code> для первичного ключа, которому автоматически присваиваются целые числа, монолитно увеличивающиеся по мере поступления данных в коллекцию.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/primary-field.md">Первичное поле и автоидентификация</a>.</p>
<h3 id="Partitioning" class="common-anchor-header">Разбиение на разделы</h3><p>Чтобы ускорить поиск, можно включить разделение на разделы. Назначив определенное скалярное поле для разбиения и задав критерии фильтрации на основе этого поля во время поиска, можно эффективно ограничить область поиска только соответствующими разделами. Этот метод значительно повышает эффективность поисковых операций за счет уменьшения области поиска.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/use-partition-key.md">Использование ключа раздела</a>.</p>
<h3 id="Analyzer" class="common-anchor-header">Анализатор</h3><p>Анализатор - это важный инструмент для обработки и преобразования текстовых данных. Его основная задача - преобразовать необработанный текст в лексемы и структурировать их для индексирования и поиска. Для этого он выполняет токенизацию строки, удаляет стоп-слова и превращает отдельные слова в лексемы.</p>
<p>Более подробную информацию см. в разделе <a href="/docs/ru/analyzer-overview.md">Обзор анализатора</a>.</p>
<h3 id="Function" class="common-anchor-header">Функция</h3><p>Milvus позволяет определять встроенные функции как часть схемы для автоматического получения определенных полей. Например, вы можете добавить встроенную функцию BM25, которая генерирует разреженный вектор из поля <code translate="no">VARCHAR</code> для поддержки полнотекстового поиска. Эти поля, созданные с помощью функций, упрощают предварительную обработку и обеспечивают самодостаточность коллекции и ее готовность к запросу.</p>
<p>Более подробную информацию можно найти в разделе <a href="/docs/ru/full-text-search.md">"Полнотекстовый поиск</a>.</p>
<h2 id="A-Real-World-Example" class="common-anchor-header">Пример из реального мира<button data-href="#A-Real-World-Example" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>В этом разделе мы опишем схему и пример кода для приложения поиска мультимедийных документов, показанного на диаграмме выше. Эта схема предназначена для управления набором данных, содержащим статьи с данными, отображенными на следующие поля:</p>
<table>
   <tr>
     <th><p><strong>Поле</strong></p></th>
     <th><p><strong>Источник данных</strong></p></th>
     <th><p><strong>Используется методами поиска</strong></p></th>
     <th><p><strong>Первичный ключ</strong></p></th>
     <th><p><strong>Ключ раздела</strong></p></th>
     <th><p><strong>Анализатор</strong></p></th>
     <th><p><strong>Функция ввода/вывода</strong></p></th>
   </tr>
   <tr>
     <td><p>article_id (<code translate="no">INT64</code>)</p></td>
     <td><p>автоматически генерируется при включении <code translate="no">auto_id</code></p></td>
     <td><p><a href="/docs/ru/get-and-scalar-query.md">Запрос с помощью Get</a></p></td>
     <td><p>Y</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
   </tr>
   <tr>
     <td><p>название (<code translate="no">VARCHAR</code>)</p></td>
     <td><p>заголовок статьи</p></td>
     <td><p><a href="/docs/ru/keyword-match.md">Текстовое соответствие</a></p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>Y</p></td>
     <td><p>N</p></td>
   </tr>
   <tr>
     <td><p>временная метка (<code translate="no">INT32</code>)</p></td>
     <td><p>дата публикации</p></td>
     <td><p><a href="/docs/ru/use-partition-key.md">Фильтр по ключу раздела</a></p></td>
     <td><p>N</p></td>
     <td><p>Y</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
   </tr>
   <tr>
     <td><p>текст (<code translate="no">VARCHAR</code>)</p></td>
     <td><p>необработанный текст статьи</p></td>
     <td><p><a href="/docs/ru/multi-vector-search.md">Многовекторный гибридный поиск</a></p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>Y</p></td>
     <td><p>вход</p></td>
   </tr>
   <tr>
     <td><p>text_dense_vector (<code translate="no">FLOAT_VECTOR</code>)</p></td>
     <td><p>плотный вектор, сгенерированный моделью встраивания текста</p></td>
     <td><p><a href="https://zilliverse.feishu.cn/wiki/BaGlwzDmyiyVvVk6NurcFclInCd?from=from_parent_docs">Базовый векторный поиск</a></p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
   </tr>
   <tr>
     <td><p>text_sparse_vector (<code translate="no">SPARSE_FLOAT_VECTOR</code>)</p></td>
     <td><p>разреженный вектор, автоматически генерируемый встроенной функцией BM25</p></td>
     <td><p><a href="https://zilliverse.feishu.cn/wiki/RQTRwhOVPiwnwokqr4scAtyfnBf?from=from_parent_docs">Полный текстовый поиск</a></p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>N</p></td>
     <td><p>выход</p></td>
   </tr>
</table>
<p>Более подробную информацию о схемах и подробное руководство по добавлению различных типов полей вы найдете в разделе <a href="/docs/ru/schema.md">"Объяснение схем"</a>.</p>
<h3 id="Initialize-schema" class="common-anchor-header">Инициализация схемы</h3><p>Для начала нам нужно создать пустую схему. Этот шаг устанавливает основополагающую структуру для определения модели данных.</p>
<div class="multipleCode">
   <a href="#python">Python</a> <a href="#java">Java</a> <a href="#javascript">NodeJS</a> <a href="#go">Go</a> <a href="#bash">cURL</a></div>
<pre><code translate="no" class="language-python"><span class="hljs-keyword">from</span> pymilvus <span class="hljs-keyword">import</span> MilvusClient

schema = MilvusClient.create_schema()
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-java"><span class="hljs-keyword">import</span> io.milvus.v2.client.ConnectConfig;
<span class="hljs-keyword">import</span> io.milvus.v2.client.MilvusClientV2;
<span class="hljs-keyword">import</span> io.milvus.v2.service.collection.request.CreateCollectionReq;

<span class="hljs-comment">// 1. Connect to Milvus server</span>
<span class="hljs-type">ConnectConfig</span> <span class="hljs-variable">connectConfig</span> <span class="hljs-operator">=</span> ConnectConfig.builder()
        .uri(<span class="hljs-string">&quot;http://localhost:19530&quot;</span>)
        .build();

<span class="hljs-type">MilvusClientV2</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MilvusClientV2</span>(connectConfig);

<span class="hljs-comment">// 2. Create an empty schema</span>
CreateCollectionReq.<span class="hljs-type">CollectionSchema</span> <span class="hljs-variable">schema</span> <span class="hljs-operator">=</span> client.createSchema();
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MilvusClient</span>, <span class="hljs-title class_">DataType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@zilliz/milvus2-sdk-node&quot;</span>;

<span class="hljs-comment">//Skip this step using JavaScript</span>
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/milvus-io/milvus/client/v2/entity&quot;</span>

schema := entity.NewSchema()
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-bash"><span class="hljs-comment"># Skip this step using cURL</span>
<button class="copy-code-btn"></button></code></pre>
<h3 id="Add-fields" class="common-anchor-header">Добавить поля</h3><p>После создания схемы следующим шагом будет указание полей, из которых будут состоять ваши данные. Каждое поле связано с соответствующими типами данных и атрибутами.</p>
<div class="multipleCode">
   <a href="#python">Python</a> <a href="#java">Java</a> <a href="#javascript">NodeJS</a> <a href="#go">Go</a> <a href="#bash">cURL</a></div>
<pre><code translate="no" class="language-python"><span class="hljs-keyword">from</span> pymilvus <span class="hljs-keyword">import</span> DataType

schema.add_field(field_name=<span class="hljs-string">&quot;article_id&quot;</span>, datatype=DataType.INT64, is_primary=<span class="hljs-literal">True</span>, auto_id=<span class="hljs-literal">True</span>, description=<span class="hljs-string">&quot;article id&quot;</span>)
schema.add_field(field_name=<span class="hljs-string">&quot;title&quot;</span>, datatype=DataType.VARCHAR, enable_analyzer=<span class="hljs-literal">True</span>, enable_match=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">200</span>, description=<span class="hljs-string">&quot;article title&quot;</span>)
schema.add_field(field_name=<span class="hljs-string">&quot;timestamp&quot;</span>, datatype=DataType.INT32, description=<span class="hljs-string">&quot;publish date&quot;</span>)
schema.add_field(field_name=<span class="hljs-string">&quot;text&quot;</span>, datatype=DataType.VARCHAR, max_length=<span class="hljs-number">2000</span>, enable_analyzer=<span class="hljs-literal">True</span>, description=<span class="hljs-string">&quot;article text content&quot;</span>)
schema.add_field(field_name=<span class="hljs-string">&quot;text_dense_vector&quot;</span>, datatype=DataType.FLOAT_VECTOR, dim=<span class="hljs-number">768</span>, description=<span class="hljs-string">&quot;text dense vector&quot;</span>)
schema.add_field(field_name=<span class="hljs-string">&quot;text_sparse_vector&quot;</span>, datatype=DataType.SPARSE_FLOAT_VECTOR, description=<span class="hljs-string">&quot;text sparse vector&quot;</span>)
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-java"><span class="hljs-keyword">import</span> io.milvus.v2.common.DataType;
<span class="hljs-keyword">import</span> io.milvus.v2.service.collection.request.AddFieldReq;

schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;article_id&quot;</span>)
        .dataType(DataType.Int64)
        .isPrimaryKey(<span class="hljs-literal">true</span>)
        .autoID(<span class="hljs-literal">true</span>)
        .build());
schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;title&quot;</span>)
        .dataType(DataType.VarChar)
        .maxLength(<span class="hljs-number">200</span>)
        .enableAnalyzer(<span class="hljs-literal">true</span>)
        .enableMatch(<span class="hljs-literal">true</span>)
        .build());
schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;timestamp&quot;</span>)
        .dataType(DataType.Int32)
        .build())
schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;text&quot;</span>)
        .dataType(DataType.VarChar)
        .maxLength(<span class="hljs-number">2000</span>)
        .enableAnalyzer(<span class="hljs-literal">true</span>)
        .build());
schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;text_dense_vector&quot;</span>)
        .dataType(DataType.FloatVector)
        .dimension(<span class="hljs-number">768</span>)
        .build());
schema.addField(AddFieldReq.builder()
        .fieldName(<span class="hljs-string">&quot;text_sparse_vector&quot;</span>)
        .dataType(DataType.SparseFloatVector)
        .build());
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-javascript"><span class="hljs-keyword">const</span> fields = [
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;article_id&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">Int64</span>,
        <span class="hljs-attr">is_primary_key</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">auto_id</span>: <span class="hljs-literal">true</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;title&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">VarChar</span>,
        <span class="hljs-attr">max_length</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">enable_analyzer</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">enable_match</span>: <span class="hljs-literal">true</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;timestamp&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">Int32</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;text&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">VarChar</span>,
        <span class="hljs-attr">max_length</span>: <span class="hljs-number">2000</span>,
        <span class="hljs-attr">enable_analyzer</span>: <span class="hljs-literal">true</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;text_dense_vector&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">FloatVector</span>,
        <span class="hljs-attr">dim</span>: <span class="hljs-number">768</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;text_sparse_vector&quot;</span>,
        <span class="hljs-attr">data_type</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">SparseFloatVector</span>
    }
]
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-go">schema.WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;article_id&quot;</span>).
    WithDataType(entity.FieldTypeInt64).
    WithIsPrimaryKey(<span class="hljs-literal">true</span>).
    WithIsAutoID(<span class="hljs-literal">true</span>).
    WithDescription(<span class="hljs-string">&quot;article id&quot;</span>),
).WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;title&quot;</span>).
    WithDataType(entity.FieldTypeVarChar).
    WithMaxLength(<span class="hljs-number">200</span>).
    WithEnableAnalyzer(<span class="hljs-literal">true</span>).
    WithEnableMatch(<span class="hljs-literal">true</span>).
    WithDescription(<span class="hljs-string">&quot;article title&quot;</span>),
).WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;timestamp&quot;</span>).
    WithDataType(entity.FieldTypeInt32).
    WithDescription(<span class="hljs-string">&quot;publish date&quot;</span>),
).WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;text&quot;</span>).
    WithDataType(entity.FieldTypeVarChar).
    WithMaxLength(<span class="hljs-number">2000</span>).
    WithEnableAnalyzer(<span class="hljs-literal">true</span>).
    WithDescription(<span class="hljs-string">&quot;article text content&quot;</span>),
).WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;text_dense_vector&quot;</span>).
    WithDataType(entity.FieldTypeFloatVector).
    WithDim(<span class="hljs-number">768</span>).
    WithDescription(<span class="hljs-string">&quot;text dense vector&quot;</span>),
).WithField(entity.NewField().
    WithName(<span class="hljs-string">&quot;text_sparse_vector&quot;</span>).
    WithDataType(entity.FieldTypeSparseVector).
    WithDescription(<span class="hljs-string">&quot;text sparse vector&quot;</span>),
)
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-bash"><span class="hljs-built_in">export</span> fields=<span class="hljs-string">&#x27;[
    {
        &quot;fieldName&quot;: &quot;article_id&quot;,
        &quot;dataType&quot;: &quot;Int64&quot;,
        &quot;isPrimary&quot;: true
    },
    {
        &quot;fieldName&quot;: &quot;title&quot;,
        &quot;dataType&quot;: &quot;VarChar&quot;,
        &quot;elementTypeParams&quot;: {
            &quot;max_length&quot;: 200,
            &quot;enable_analyzer&quot;: true,
            &quot;enable_match&quot;: true
        }
    },
    {
        &quot;fieldName&quot;: &quot;timestamp&quot;,
        &quot;dataType&quot;: &quot;Int32&quot;
    },
    {
       &quot;fieldName&quot;: &quot;text&quot;,
       &quot;dataType&quot;: &quot;VarChar&quot;,
       &quot;elementTypeParams&quot;: {
            &quot;max_length&quot;: 2000,
            &quot;enable_analyzer&quot;: true
        }
    },
    {
       &quot;fieldName&quot;: &quot;text_dense_vector&quot;,
       &quot;dataType&quot;: &quot;FloatVector&quot;,
       &quot;elementTypeParams&quot;: {
            &quot;dim&quot;: 768
        }
    },
    {
       &quot;fieldName&quot;: &quot;text_sparse_vector&quot;,
       &quot;dataType&quot;: &quot;SparseFloatVector&quot;,
    }
]&#x27;</span>

<span class="hljs-built_in">export</span> schema=<span class="hljs-string">&quot;{
    \&quot;autoID\&quot;: true,
    \&quot;fields\&quot;: <span class="hljs-variable">$fields</span>
}&quot;</span>
<button class="copy-code-btn"></button></code></pre>
<p>В этом примере для полей заданы следующие атрибуты:</p>
<ul>
<li><p>Первичный ключ: <code translate="no">article_id</code> используется в качестве первичного ключа, что позволяет автоматически назначать первичные ключи для входящих сущностей.</p></li>
<li><p>Ключ раздела: <code translate="no">timestamp</code> назначается в качестве ключа раздела, что позволяет осуществлять фильтрацию по разделам. Это может быть</p></li>
<li><p>Текстовый анализатор: текстовый анализатор применяется к двум строковым полям <code translate="no">title</code> и <code translate="no">text</code> для поддержки текстового соответствия и полнотекстового поиска соответственно.</p></li>
</ul>
<h3 id="Optional-Add-functions" class="common-anchor-header">(Необязательно) Добавление функций</h3><p>Чтобы расширить возможности запроса данных, в схему можно включить функции. Например, можно создать функцию для обработки данных, связанных с определенными полями.</p>
<div class="multipleCode">
   <a href="#python">Python</a> <a href="#java">Java</a> <a href="#javascript">NodeJS</a> <a href="#go">Go</a> <a href="#bash">cURL</a></div>
<pre><code translate="no" class="language-python"><span class="hljs-keyword">from</span> pymilvus <span class="hljs-keyword">import</span> Function, FunctionType

bm25_function = Function(
    name=<span class="hljs-string">&quot;text_bm25&quot;</span>,
    input_field_names=[<span class="hljs-string">&quot;text&quot;</span>],
    output_field_names=[<span class="hljs-string">&quot;text_sparse_vector&quot;</span>],
    function_type=FunctionType.BM25,
)

schema.add_function(bm25_function)
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-java"><span class="hljs-keyword">import</span> io.milvus.common.clientenum.FunctionType;
<span class="hljs-keyword">import</span> io.milvus.v2.service.collection.request.CreateCollectionReq.Function;

<span class="hljs-keyword">import</span> java.util.*;

schema.addFunction(Function.builder()
        .functionType(FunctionType.BM25)
        .name(<span class="hljs-string">&quot;text_bm25&quot;</span>)
        .inputFieldNames(Collections.singletonList(<span class="hljs-string">&quot;text&quot;</span>))
        .outputFieldNames(Collections.singletonList(<span class="hljs-string">&quot;text_sparse_vector&quot;</span>))
        .build());
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">FunctionType</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@zilliz/milvus2-sdk-node&quot;</span>;

<span class="hljs-keyword">const</span> functions = [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;text_bm25&#x27;</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;bm25 function&#x27;</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">FunctionType</span>.<span class="hljs-property">BM25</span>,
      <span class="hljs-attr">input_field_names</span>: [<span class="hljs-string">&#x27;text&#x27;</span>],
      <span class="hljs-attr">output_field_names</span>: [<span class="hljs-string">&#x27;text_sparse_vector&#x27;</span>],
      <span class="hljs-attr">params</span>: {},
    },
]；
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-go">function := entity.NewFunction().
    WithName(<span class="hljs-string">&quot;text_bm25&quot;</span>).
    WithInputFields(<span class="hljs-string">&quot;text&quot;</span>).
    WithOutputFields(<span class="hljs-string">&quot;text_sparse_vector&quot;</span>).
    WithType(entity.FunctionTypeBM25)
schema.WithFunction(function)
<button class="copy-code-btn"></button></code></pre>
<pre><code translate="no" class="language-bash"><span class="hljs-built_in">export</span> myFunctions=<span class="hljs-string">&#x27;[
    {
        &quot;name&quot;: &quot;text_bm25&quot;,
        &quot;type&quot;: &quot;BM25&quot;,
        &quot;inputFieldNames&quot;: [&quot;text&quot;],
        &quot;outputFieldNames&quot;: [&quot;text_sparse_vector&quot;],
        &quot;params&quot;: {}
    }
]&#x27;</span>

<span class="hljs-built_in">export</span> schema=<span class="hljs-string">&quot;{
    \&quot;autoID\&quot;: true,
    \&quot;fields\&quot;: <span class="hljs-variable">$fields</span>
    \&quot;functions\&quot;: <span class="hljs-variable">$myFunctions</span>
}&quot;</span>
<button class="copy-code-btn"></button></code></pre>
<p>В этом примере в схему добавлена встроенная функция BM25, использующая в качестве входных данных поле <code translate="no">text</code> и сохраняющая полученные разреженные векторы в поле <code translate="no">text_sparse_vector</code>.</p>
<h2 id="Next-Steps" class="common-anchor-header">Следующие шаги<button data-href="#Next-Steps" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li><p><a href="/docs/ru/create-collection.md">Создать коллекцию</a></p></li>
<li><p><a href="/docs/ru/alter-collection-field.md">Изменить поле коллекции</a></p></li>
</ul>
