---
id: product_faq.md
summary: >-
  Найдите ответы на часто задаваемые вопросы о самой передовой в мире базе
  данных векторов.
title: Часто задаваемые вопросы о продукте
---
<h1 id="Product-FAQ" class="common-anchor-header">Часто задаваемые вопросы о продукте<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Сколько стоит Milvus?</h4><p>Milvus - это 100% бесплатный проект с открытым исходным кодом.</p>
<p>Пожалуйста, придерживайтесь <a href="http://www.apache.org/licenses/LICENSE-2.0">лицензии Apache License 2.0</a> при использовании Milvus для производства или распространения.</p>
<p>Компания Zilliz, стоящая за Milvus, также предлагает полностью управляемую облачную версию платформы для тех, кто не хочет создавать и поддерживать свой собственный распределенный экземпляр. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> автоматически поддерживает надежность данных и позволяет пользователям платить только за то, что они используют.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Поддерживает ли Milvus архитектуры, отличные от x86?</h4><p>Milvus нельзя установить или запустить на платформах, не поддерживающих архитектуру x86.</p>
<p>Для работы Milvus ваш процессор должен поддерживать один из следующих наборов инструкций: SSE4.2, AVX, AVX2, AVX512. Это все наборы SIMD-инструкций, предназначенные для x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Где Milvus хранит данные?</h4><p>Milvus имеет дело с двумя типами данных - вставленными данными и метаданными.</p>
<p>Вставленные данные, включая векторные данные, скалярные данные и специфическую схему коллекции, хранятся в постоянном хранилище в виде инкрементного журнала. Milvus поддерживает множество бэкендов объектных хранилищ, включая <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> и <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Метаданные генерируются внутри Milvus. Каждый модуль Milvus имеет свои собственные метаданные, которые хранятся в etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Почему в etcd нет векторных данных?</h4><p>В etcd хранятся метаданные модуля Milvus; в MinIO хранятся сущности.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Поддерживает ли Milvus одновременную вставку и поиск данных?</h4><p>Да. Операции вставки и запросы обрабатываются двумя отдельными модулями, которые взаимно независимы. С точки зрения клиента, операция вставки завершается, когда вставленные данные попадают в очередь сообщений. Однако вставленные данные не доступны для поиска до тех пор, пока они не будут загружены в узел запроса. Если размер сегмента не достигает порога построения индекса (512 МБ по умолчанию), Milvus прибегает к грубому поиску, и производительность запросов может снизиться.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Можно ли вставлять в Milvus векторы с дублирующимися первичными ключами?</h4><p>Да. Milvus не проверяет, являются ли первичные ключи векторов дубликатами.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">При вставке векторов с дублирующимися первичными ключами Milvus рассматривает это как операцию обновления?</h4><p>Нет. В настоящее время Milvus не поддерживает операции обновления и не проверяет, являются ли первичные ключи сущностей дубликатами. Вы отвечаете за то, чтобы первичные ключи сущностей были уникальными, и если это не так, то Milvus может содержать несколько сущностей с дублирующимися первичными ключами.</p>
<p>В этом случае неизвестно, какая копия данных будет возвращена при запросе. Это ограничение будет исправлено в будущих релизах.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Какова максимальная длина самоопределяемых первичных ключей сущностей?</h4><p>Первичные ключи сущностей должны быть неотрицательными 64-битными целыми числами.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Какой максимальный объем данных может быть добавлен за одну операцию вставки?</h4><p>Размер операции вставки не должен превышать 1 024 МБ. Это ограничение, накладываемое gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">Влияет ли размер коллекции на производительность запроса при поиске в определенном разделе?</h4><p>Нет. Если разделы для поиска указаны, Milvus выполняет поиск только в указанных разделах.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Нужно ли Milvus загружать всю коллекцию, если для поиска указаны разделы?</h4><p>Это зависит от того, какие данные нужны для поиска. Перед поиском необходимо загрузить все разделы, которые могут появиться в результатах поиска.</p>
<ul>
<li>Например, если вы хотите найти только определенный раздел (разделы), вам не нужно загружать все разделы. Вызовите <code translate="no">load_partition()</code>, чтобы загрузить нужный раздел (разделы) <em>, а затем</em> укажите раздел (разделы) в вызове метода <code translate="no">search()</code>.</li>
<li>Если вы хотите выполнить поиск во всех разделах, вызовите <code translate="no">load_collection()</code>, чтобы загрузить всю коллекцию, включая все разделы.</li>
<li>Если вы не загрузите коллекцию или конкретный раздел(ы) перед поиском, Milvus вернет ошибку.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Можно ли создавать индексы после вставки векторов?</h4><p>Да. Если ранее для коллекции был создан индекс по адресу <code translate="no">create_index()</code>, Milvus автоматически создаст индекс для последующих вставленных векторов. Однако Milvus не строит индекс до тех пор, пока вновь вставленные векторы не заполнят весь сегмент, а вновь созданный индексный файл не будет отделен от предыдущего.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">Чем отличаются индексы FLAT и IVF_FLAT?</h4><p>Индекс IVF_FLAT делит векторное пространство на кластеры списка. При значении списка по умолчанию 16 384, Milvus сравнивает расстояния между целевым вектором и центроидами всех 16 384 кластеров, чтобы вернуть ближайшие кластеры. Затем Milvus сравнивает расстояния между целевым вектором и векторами в выбранных кластерах, чтобы получить ближайшие векторы. В отличие от IVF_FLAT, FLAT напрямую сравнивает расстояния между целевым вектором и каждым другим вектором.</p>
<p>Когда общее количество векторов приблизительно равно nlist, между IVF_FLAT и FLAT существует небольшое расстояние с точки зрения требований к вычислениям и производительности поиска. Однако когда число векторов превышает nlist в два и более раз, IVF_FLAT начинает демонстрировать преимущества в производительности.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/index.md">"Векторный индекс"</a>.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Как Milvus промывает данные?</h4><p>Milvus возвращает успешный результат, когда вставленные данные попадают в очередь сообщений. Однако данные еще не выгружены на диск. Затем узел данных Milvus записывает данные в очереди сообщений в постоянное хранилище в виде инкрементных журналов. Если вызвать <code translate="no">flush()</code>, то узел данных будет вынужден немедленно записать все данные в очереди сообщений в постоянное хранилище.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Что такое нормализация? Зачем нужна нормализация?</h4><p>Нормализация - это процесс преобразования вектора таким образом, чтобы его норма была равна 1. Если для вычисления сходства векторов используется внутреннее произведение, векторы должны быть нормализованы. После нормализации внутреннее произведение равно косинусному сходству.</p>
<p>Более подробную информацию см. в <a href="https://en.wikipedia.org/wiki/Unit_vector">Википедии</a>.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Почему евклидово расстояние (L2) и внутреннее произведение (IP) дают разные результаты?</h4><p>Для нормализованных векторов евклидово расстояние (L2) математически эквивалентно внутреннему произведению (IP). Если эти метрики сходства дают разные результаты, проверьте, нормализованы ли ваши векторы.</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Существует ли ограничение на общее количество коллекций и разделов в Milvus?</h4><p>Да. Вы можете создать до 65 535 коллекций в экземпляре Milvus. При подсчете количества существующих коллекций Milvus учитывает все коллекции, в которых есть осколки и разделы.</p>
<p>Например, предположим, что вы уже создали 100 коллекций, в 60 из которых есть 2 шарда и 4 раздела, а в остальных 40 коллекциях - 1 шард и 12 разделов. Текущее количество коллекций можно вычислить так:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Почему при поиске векторов по адресу <code translate="no">topk</code> я получаю меньше k векторов?</h4><p>Среди индексов, которые поддерживает Milvus, IVF_FLAT и IVF_SQ8 реализуют метод кластеризации k-means. Пространство данных делится на кластеры <code translate="no">nlist</code>, и вставленные векторы распределяются по этим кластерам. Затем Milvus выбирает ближайшие кластеры <code translate="no">nprobe</code> и сравнивает расстояния между целевым вектором и всеми векторами в выбранных кластерах, получая окончательные результаты.</p>
<p>Если <code translate="no">nlist</code> и <code translate="no">topk</code> велики, а nprobe мало, количество векторов в кластерах nprobe может быть меньше, чем <code translate="no">k</code>. Поэтому при поиске ближайших векторов <code translate="no">topk</code> количество возвращаемых векторов будет меньше, чем <code translate="no">k</code>.</p>
<p>Чтобы избежать этого, попробуйте задать <code translate="no">nprobe</code> больше, а <code translate="no">nlist</code> и <code translate="no">k</code> меньше.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/index.md">Индекс вектора</a>.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Какая максимальная размерность вектора поддерживается в Milvus?</h4><p>По умолчанию Milvus может управлять векторами с размерностью до 32 768. Вы можете увеличить значение <code translate="no">Proxy.maxDimension</code>, чтобы позволить вектору иметь большую размерность.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Поддерживает ли Milvus процессор Apple M1?</h4><p>Текущий выпуск Milvus не поддерживает процессор Apple M1 напрямую. После выхода Milvus 2.3 Milvus будет предоставлять Docker-образы для архитектуры ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Какие типы данных поддерживает Milvus для поля первичного ключа?</h4><p>В текущем выпуске Milvus поддерживает INT64 и string.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Является ли Milvus масштабируемым?</h4><p>Да. Вы можете развернуть кластер Milvus с несколькими узлами с помощью Helm Chart на Kubernetes. Дополнительные инструкции см. в <a href="/docs/ru/scaleout.md">руководстве по масштабированию</a>.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Что такое растущий сегмент и уплотненный сегмент?</h4><p>Когда поступает запрос на поиск, Milvus ищет как инкрементные, так и исторические данные. Инкрементные данные - это недавние обновления, они хранятся в растущих сегментах, которые буферизируются в памяти до того, как они достигнут порога для сохранения в объектном хранилище, и для них строится более эффективный индекс, а исторические данные - это обновления, произошедшие некоторое время назад. Они находятся в запечатанных сегментах, которые были сохранены в объектном хранилище. Инкрементные и исторические данные вместе составляют весь набор данных для поиска. Такая конструкция делает любые данные, поступающие в Milvus, доступными для мгновенного поиска. Для Milvus Distributed существуют более сложные факторы, которые решают, когда только что поступившая запись может появиться в результатах поиска. Подробнее об этом можно узнать на <a href="https://milvus.io/docs/consistency.md">уровнях согласованности</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Доступен ли в Milvus параллельный поиск?</h4><p>Да. При запросах по одной и той же коллекции Milvus выполняет одновременный поиск в инкрементных и исторических данных. Однако запросы к разным коллекциям выполняются последовательно. В то время как исторические данные могут представлять собой чрезвычайно огромный набор данных, поиск по историческим данным занимает относительно больше времени и, по сути, выполняется последовательно.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Почему данные в MinIO сохраняются после удаления соответствующей коллекции?</h4><p>Данные в MinIO сохраняются в течение определенного периода времени для удобства отката данных.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Поддерживает ли Milvus движки сообщений, отличные от Pulsar?</h4><p>Да. Kafka поддерживается в версии Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">В чем разница между поиском и запросом?</h4><p>В Milvus поиск по векторному сходству извлекает векторы на основе расчета сходства и ускорения векторного индекса. В отличие от поиска по векторному сходству, векторный запрос извлекает векторы с помощью скалярной фильтрации на основе булева выражения. Булево выражение фильтрует скалярные поля или поле первичного ключа и извлекает все результаты, соответствующие фильтрам. В запросе не задействованы ни метрика сходства, ни индекс вектора.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Почему в Milvus векторное значение float имеет точность 7 десятичных цифр?</h4><p>Milvus поддерживает хранение векторов в виде массивов Float32. Значение Float32 имеет точность 7 десятичных цифр. Даже если значение Float64, например 1.3476964684980388, Milvus сохраняет его как 1.347696. Поэтому, когда вы получаете такой вектор из Milvus, точность значения Float64 теряется.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Как Milvus работает с типами векторных данных и точностью?</h4><p>Milvus поддерживает векторные типы Binary, Float32, Float16 и BFloat16.</p>
<ul>
<li>Двоичные векторы: Хранят двоичные данные в виде последовательностей 0 и 1, используются в обработке изображений и поиске информации.</li>
<li>Векторы Float32: По умолчанию хранятся с точностью около 7 десятичных цифр. Даже значения Float64 хранятся с точностью Float32, что приводит к возможной потере точности при их извлечении.</li>
<li>Векторы Float16 и BFloat16: Предлагают меньшую точность и меньшее использование памяти. Float16 подходит для приложений с ограниченной пропускной способностью и памятью, в то время как BFloat16 балансирует между дальностью и эффективностью, обычно используется в глубоком обучении для снижения вычислительных требований без существенного влияния на точность.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Поддерживает ли Milvus указание значений по умолчанию для скалярных или векторных полей?</h4><p>В настоящее время Milvus 2.4.x не поддерживает указание значений по умолчанию для скалярных или векторных полей. Эта функция запланирована на будущие релизы.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">Освобождается ли место в хранилище сразу после удаления данных в Milvus?</h4><p>Нет, место в хранилище не освобождается сразу после удаления данных в Milvus. Хотя при удалении данных сущности помечаются как "логически удаленные", фактическое пространство может быть освобождено не сразу. Вот почему:</p>
<ul>
<li><strong>Компактирование</strong>: Milvus автоматически уплотняет данные в фоновом режиме. Этот процесс объединяет меньшие сегменты данных в большие и удаляет логически удаленные данные (сущности, помеченные для удаления) или данные, время жизни которых истекло (TTL). Однако при уплотнении создаются новые сегменты, а старые помечаются как "Удаленные".</li>
<li><strong>Сборка мусора</strong>: Отдельный процесс, называемый сборкой мусора (GC), периодически удаляет эти сегменты "Dropped", освобождая занимаемое ими место в хранилище. Это обеспечивает эффективное использование хранилища, но может вызвать небольшую задержку между удалением и освобождением места.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">Могу ли я увидеть вставленные, удаленные или поднятые данные сразу после операции, не дожидаясь промывки?</h4><p>Да, в Milvus видимость данных не связана напрямую с операциями промывки благодаря архитектуре дезагрегации хранилища и вычислений. Вы можете управлять читаемостью данных с помощью уровней согласованности.</p>
<p>При выборе уровня согласованности учитывайте компромисс между согласованностью и производительностью. Для операций, требующих немедленной видимости, используйте уровень согласованности "Strong". Для более быстрой записи приоритет отдавайте более слабой согласованности (данные могут быть видны не сразу). Дополнительные сведения см. в разделе <a href="/docs/ru/consistency.md">Согласованность</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">После включения функции ключа раздела какое значение по умолчанию имеет <code translate="no">num_partitions</code> в Milvus и почему?</h4><p>Когда функция ключа раздела включена, значение по умолчанию <code translate="no">num_partitions</code> в Milvus устанавливается на <code translate="no">16</code>. Это значение по умолчанию выбрано из соображений стабильности и производительности. При необходимости вы можете изменить значение <code translate="no">num_partitions</code>, указав его в функции <code translate="no">create_collection</code>.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">Существует ли ограничение на максимальную длину выражений скалярной фильтрации?</h4><p>Да, максимальная длина скалярного фильтрующего выражения ограничивается пределом передачи RPC, который задается в файле конфигурации <code translate="no">milvus.yaml</code>. В частности, ограничение задается параметром <code translate="no">serverMaxRecvSize</code> в разделе прокси:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>По умолчанию максимальный размер каждого RPC-запроса составляет 64 МБ. Поэтому для успешной обработки длина фильтрующего выражения должна быть меньше этого предела.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">При выполнении массового векторного поиска сколько векторов можно указать одновременно? Существует ли ограничение?</h4><p>Да, количество векторов, которые можно указать при массовом векторном поиске, ограничено размером RPC-передачи, определенным в конфигурационном файле <code translate="no">milvus.yaml</code>. Этот предел определяется параметром <code translate="no">serverMaxRecvSize</code> в разделе прокси:</p>
<pre><code translate="no" class="language-yaml"><span class="hljs-attr">proxy:</span>
  <span class="hljs-attr">grpc:</span>
    <span class="hljs-attr">serverMaxRecvSize:</span> <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>По умолчанию максимальный размер каждого RPC-запроса составляет 64 МБ. Поэтому для успешного выполнения запроса общий размер входных векторов, включая их размерные данные и метаданные, должен быть меньше этого предела.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Как получить все уникальные значения заданного скалярного поля из коллекции?</h4><p>В настоящее время не существует прямого метода для достижения этой цели. В качестве обходного пути мы рекомендуем использовать query_iterator для получения всех значений для определенного поля, а затем выполнить дедупликацию вручную. Мы планируем добавить прямую поддержку этой функции в Milvus 2.6. Пример использования query_iterator:</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column    </span>
<button class="copy-code-btn"></button></code></pre>
<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">Каковы ограничения при использовании динамических полей? Например, есть ли ограничения на размер, методы модификации или ограничения на индексирование?</h4><p>Динамические поля представлены внутри системы с помощью полей JSON, с ограничением по размеру 65 536 байт. Они поддерживают модификации upsert, позволяющие добавлять или обновлять поля. Однако, начиная с версии Milvus 2.5.1, динамические поля не поддерживают индексацию. Поддержка добавления индексов для JSON будет реализована в будущих выпусках.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">Поддерживает ли Milvus изменения схемы?</h4><p>Начиная с версии Milvus 2.5.0, изменения схемы ограничиваются специфическими модификациями, такими как настройка свойств, например, параметра <code translate="no">mmap</code>. Пользователи также могут изменять параметры <code translate="no">max_length</code> для полей varchar и <code translate="no">max_capacity</code> для полей массивов. Однако возможность добавлять или удалять поля в схемах планируется в будущих выпусках, что повысит гибкость управления схемами в Milvus.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">Требует ли изменение max_length для VarChar реорганизации данных?</h4><p>Нет, изменение <code translate="no">max_length</code> для поля VarChar не требует реорганизации данных, например уплотнения или реорганизации. Эта корректировка в первую очередь обновляет критерии проверки для любых новых данных, вставляемых в поле, оставляя существующие данные незатронутыми. В результате это изменение считается легким и не накладывает значительных нагрузок на систему.</p>
<h4 id="Still-have-questions" class="common-anchor-header">У вас остались вопросы?</h4><p>Вы можете:</p>
<ul>
<li>Проверить <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> на GitHub. Вы можете задавать вопросы, делиться идеями и помогать другим.</li>
<li>Присоединяйтесь к нашему <a href="https://slack.milvus.io/">сообществу Slack</a>, чтобы найти поддержку и участвовать в работе нашего сообщества разработчиков с открытым исходным кодом.</li>
</ul>
