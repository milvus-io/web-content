---
id: index-explained.md
title: شرح الفهرس
summary: >-
  الفهرس هو بنية إضافية مبنية فوق البيانات. وتعتمد بنيته الداخلية على خوارزمية
  البحث التقريبي الأقرب الجار المستخدمة. يعمل الفهرس على تسريع عملية البحث،
  ولكنه يتكبد وقتًا إضافيًا للمعالجة المسبقة ومساحة وذاكرة وصول عشوائي إضافية
  أثناء البحث. علاوة على ذلك، فإن استخدام الفهرس عادةً ما يقلل من معدل الاستدعاء
  (على الرغم من أن التأثير ضئيل، إلا أنه لا يزال مهمًا). لذلك، تشرح هذه المقالة
  كيفية تقليل تكاليف استخدام الفهرس إلى الحد الأدنى مع تعظيم الفوائد.
---
<h1 id="Index-Explained" class="common-anchor-header">شرح الفهرس<button data-href="#Index-Explained" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>الفهرس هو بنية إضافية مبنية فوق البيانات. وتعتمد بنيته الداخلية على خوارزمية البحث التقريبي الأقرب المجاورة المستخدمة. يعمل الفهرس على تسريع عملية البحث، لكنه يتكبد وقتًا إضافيًا للمعالجة المسبقة ومساحة وذاكرة وصول عشوائي إضافية أثناء البحث. علاوة على ذلك، فإن استخدام الفهرس عادةً ما يقلل من معدل الاستدعاء (على الرغم من أن التأثير ضئيل، إلا أنه لا يزال مهمًا). لذلك، تشرح هذه المقالة كيفية تقليل تكاليف استخدام الفهرس إلى الحد الأدنى مع تعظيم الفوائد.</p>
<h2 id="Overview" class="common-anchor-header">نظرة عامة<button data-href="#Overview" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>في Milvus، تكون الفهارس خاصة بالحقول، وتختلف أنواع الفهارس القابلة للتطبيق وفقًا لأنواع بيانات الحقول المستهدفة. وباعتباره قاعدة بيانات احترافية للمتجهات، يركز ملفوس على تحسين أداء عمليات البحث عن المتجهات والتصفية القياسية، ولهذا السبب يقدم أنواعًا مختلفة من الفهارس.</p>
<p>يسرد الجدول التالي علاقة التعيين بين أنواع بيانات الحقل وأنواع الفهرس القابلة للتطبيق.</p>
<table>
   <tr>
     <th><p>نوع بيانات الحقل</p></th>
     <th><p>أنواع الفهرس القابلة للتطبيق</p></th>
   </tr>
   <tr>
     <td><ul><li><p>FLOAT_VECTOR</p></li><li><p>FLOAT16_VECTOR</p></li><li><p>بfloat16_vector</p></li></ul></td>
     <td><ul><li><p>مسطح</p></li><li><p>IVF_FLAT</p></li><li><p>IVF_SQ8</p></li><li><p>IVF_PQ</p></li><li><p>GPU_IVF_FLAT</p></li><li><p>GPU_IVF_PQ</p></li><li><p>HNSW</p></li><li><p>DISKANN</p></li></ul></td>
   </tr>
   <tr>
     <td><p>BINARY_VECTOR</p></td>
     <td><ul><li>BIN_FLAT</li><li>BIN_IVF_FLAT</li></ul></td>
   </tr>
   <tr>
     <td><p>متجه_مُتَفَرِّق_مُتَفَرِّق_مُتَجَزِّئ</p></td>
     <td><p>فهرس_مُتَفَرِّق_مقلوب_مُتَفَرِّق</p></td>
   </tr>
   <tr>
     <td><p>VARCHAR</p></td>
     <td><ul><li><p>مقلوب (موصى به)</p></li><li><p>BITMAP</p></li><li><p>تري</p></li></ul></td>
   </tr>
   <tr>
     <td><p>BITMAP</p></td>
     <td><ul><li>BITMAP (مستحسن)</li><li>مقلوب</li></ul></td>
   </tr>
   <tr>
     <td><ul><li><p>INT8</p></li><li><p>INT16</p></li><li><p>INT32</p></li><li><p>INT64</p></li></ul></td>
     <td><ul><li>مقلوب</li><li>STL_SORT</li></ul></td>
   </tr>
   <tr>
     <td><ul><li>مسطح</li><li>مزدوج</li></ul></td>
     <td><p>مقلوب</p></td>
   </tr>
   <tr>
     <td><p>ARRAY <sup>(عناصر من أنواع BOOL و INT8/16/32/64 و VARCHAR)</sup></p></td>
     <td><p>BITMAP (موصى به)</p></td>
   </tr>
   <tr>
     <td><p>ARRAY <sup>(عناصر من أنواع BOOL و INT8/16/32/64 و FLOAT و DOUBLE و VARCHAR)</sup></p></td>
     <td><p>مقلوب</p></td>
   </tr>
   <tr>
     <td><p>JSON</p></td>
     <td><p>مقلوب</p></td>
   </tr>
</table>
<p>تركز هذه المقالة على كيفية تحديد فهارس المتجهات المناسبة. بالنسبة للحقول القياسية، يمكنك دائمًا استخدام نوع الفهرس الموصى به.</p>
<p>يمكن أن يؤثر اختيار نوع فهرس مناسب للبحث المتجه بشكل كبير على الأداء واستخدام الموارد. عند اختيار نوع فهرس لحقل متجه، من الضروري مراعاة عوامل مختلفة، بما في ذلك بنية البيانات الأساسية واستخدام الذاكرة ومتطلبات الأداء.</p>
<h2 id="Vector-Index-anatomy" class="common-anchor-header">تشريح الفهرس المتجه<button data-href="#Vector-Index-anatomy" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>كما هو موضح في الرسم البياني أدناه، يتكون نوع الفهرس في ميلفوس من ثلاثة مكونات أساسية، وهي <strong>بنية البيان</strong>ات، <strong>والتكمية،</strong> <strong>والمصفاة</strong>. يعتبر التحويل الكمي والمصفاة اختياريين، لكنهما يستخدمان على نطاق واسع بسبب التوازن الكبير بين المكاسب وأفضل التكاليف.</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.6.x/assets/vector-index-anatomy.png" alt="Vector Index Anatomy" class="doc-image" id="vector-index-anatomy" />
   </span> <span class="img-wrapper"> <span>تشريح الفهرس الكمي</span> </span></p>
<p>أثناء إنشاء الفهرس، يجمع ميلفوس بين بنية البيانات المختارة وطريقة التكميم لتحديد <strong>معدل التوسيع</strong> الأمثل. في وقت الاستعلام، يسترجع النظام <code translate="no">topK × expansion rate</code> المتجهات المرشحة ويطبق أداة التنقية لإعادة حساب المسافات بدقة أعلى، وأخيرًا يعيد النتائج الأكثر دقة <code translate="no">topK</code>. يوازن هذا النهج الهجين بين السرعة والدقة من خلال تقييد التنقيح الذي يستهلك الكثير من الموارد على مجموعة فرعية مصفاة من المرشحين.</p>
<h3 id="Data-structure" class="common-anchor-header">بنية البيانات</h3><p>تشكل بنية البيانات الطبقة الأساسية للفهرس. تشمل الأنواع الشائعة ما يلي:</p>
<ul>
<li><p><strong>الملف المقلوب (IVF)</strong></p>
<p>تسمح أنواع الفهرس من سلسلة IVF لـ Milvus بتجميع المتجهات في مجموعات من خلال التقسيم القائم على النقط المركزية. من الآمن عمومًا افتراض أن جميع المتجهات في دلو ما من المحتمل أن تكون قريبة من متجه الاستعلام إذا كان مركز الدلو قريبًا من متجه الاستعلام. واستنادًا إلى هذه الفرضية، يقوم برنامج Milvus بمسح تضمينات المتجهات في تلك الدلاء التي تكون فيها مركزيات الدلو قريبة من متجه الاستعلام، بدلاً من فحص مجموعة البيانات بأكملها. تقلل هذه الاستراتيجية من التكاليف الحسابية مع الحفاظ على دقة مقبولة.</p>
<p>يُعد هذا النوع من بنية بيانات الفهرس مثاليًا لمجموعات البيانات واسعة النطاق التي تتطلب إنتاجية سريعة.</p></li>
<li><p><strong>بنية قائمة على الرسم البياني</strong></p>
<p>تُنشئ بنية البيانات القائمة على الرسم البياني للبحث المتجه، مثل العالم الصغير القابل للتنقل الهرمي<a href="https://arxiv.org/abs/1603.09320">(HNSW</a>)، رسمًا بيانيًا متعدد الطبقات حيث يتصل كل متجه بأقرب جيرانه. تتنقل الاستعلامات في هذا التسلسل الهرمي، بدءًا من الطبقات العليا الخشنة والتبديل عبر الطبقات السفلى، مما يتيح تعقيد بحث فعال في الوقت اللوغاريتمي.</p>
<p>ويتفوق هذا النوع من بنية بيانات الفهرس في المساحات عالية الأبعاد والسيناريوهات التي تتطلب استعلامات ذات زمن انتقال منخفض.</p></li>
</ul>
<h3 id="Quantization" class="common-anchor-header">التكميم</h3><p>يقلل التكميم الكمي من بصمة الذاكرة والتكاليف الحسابية من خلال تمثيل أكثر خشونة:</p>
<ul>
<li><p>يُمكّن<strong>التكميم الكمي</strong> (على سبيل المثال <strong>SQ8</strong>) Milvus من ضغط كل بُعد متجه في بايت واحد (8 بت)، مما يقلل من استخدام الذاكرة بنسبة 75% مقارنةً بالعوامة 32 بت مع الحفاظ على دقة معقولة.</p></li>
<li><p><strong>تكميم المنتج</strong><strong>(PQ</strong>) يمكّن Milvus من تقسيم المتجهات إلى متجهات فرعية وترميزها باستخدام التجميع القائم على دفتر الرموز. ويحقق ذلك نسب ضغط أعلى (على سبيل المثال، 4-32 ضعفًا) على حساب انخفاض هامشي في الاسترجاع، مما يجعله مناسبًا للبيئات ذات الذاكرة المحدودة.</p></li>
</ul>
<h3 id="Refiner" class="common-anchor-header">التنقيح</h3><p>التحويل الكمي هو بطبيعته ضياع. وللحفاظ على معدل الاستدعاء، ينتج التكميم باستمرار عددًا أكبر من أفضل النتائج المرشحة أكثر من اللازم، مما يسمح للمُنقّحات باستخدام دقة أعلى لتحديد أفضل النتائج من هذه النتائج المرشحة، مما يعزز معدل الاستدعاء.</p>
<p>على سبيل المثال، تعمل أداة التنقية FP32 على مرشحي نتائج البحث التي يتم إرجاعها بواسطة التكميم من خلال إعادة حساب المسافات باستخدام دقة FP32 بدلاً من القيم المكمّمة.</p>
<p>وهذا أمر بالغ الأهمية بالنسبة للتطبيقات التي تتطلب مفاضلة بين كفاءة البحث والدقة، مثل البحث الدلالي أو أنظمة التوصية، حيث تؤثر الاختلافات الطفيفة في المسافات بشكل كبير على جودة النتائج.</p>
<h3 id="Summary" class="common-anchor-header">الملخص</h3><p>تسمح هذه البنية المتدرجة - التصفية الخشنة عبر هياكل البيانات، والحساب الفعال من خلال التكميم، وضبط الدقة عبر التنقيح - ل Milvus بتحسين المفاضلة بين الدقة والأداء بشكل تكيّفي.</p>
<h2 id="Performance-trade-offs" class="common-anchor-header">مفاضلات الأداء<button data-href="#Performance-trade-offs" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>عند تقييم الأداء، من الضروري الموازنة بين <strong>وقت الإنشاء</strong> <strong>والاستعلام في الثانية</strong> <strong>ومعدل الاسترجاع</strong>. القواعد العامة هي كما يلي:</p>
<ul>
<li><p>عادةً ما تتفوق<strong>أنواع الفهارس القائمة على الرسم البياني</strong> على <strong>متغيرات IVF</strong> من حيث <strong>QPS</strong>.</p></li>
<li><p>تتناسب<strong>متغيرات IVF</strong> بشكل خاص مع السيناريوهات ذات <strong>القمة K الكبيرة (على سبيل المثال، أكثر من 2,000)</strong>.</p></li>
<li><p>عادةً ما توفر<strong>PQ</strong> معدل استرجاع أفضل بمعدلات ضغط مماثلة عند مقارنتها بـ <strong>SQ،</strong> على الرغم من أن الأخيرة توفر أداءً أسرع.</p></li>
<li><p>يساعد استخدام محركات الأقراص الصلبة لجزء من الفهرس (كما هو الحال في <strong>DiskANN</strong>) في إدارة مجموعات البيانات الكبيرة، ولكنه يقدم أيضًا اختناقات محتملة في IOPS.</p></li>
</ul>
<h3 id="Capacity" class="common-anchor-header">السعة</h3><p>تتضمن السعة عادةً العلاقة بين حجم البيانات وذاكرة الوصول العشوائي المتاحة. عند التعامل مع السعة، ضع في اعتبارك ما يلي:</p>
<ul>
<li><p>إذا كان ربع بياناتك الأولية يتناسب مع الذاكرة، ففكر في DiskANN لزمن الوصول المستقر.</p></li>
<li><p>إذا كانت جميع بياناتك الأولية تتناسب مع الذاكرة، ففكر في أنواع الفهرس المستندة إلى الذاكرة و mmap.</p></li>
<li><p>يمكنك استخدام أنواع الفهارس المطبقة على الكمية و mmap لمقايضة الدقة بالسعة القصوى.</p></li>
</ul>
<div class="alert note">
<p>ليس Mmap هو الحل دائمًا. عندما تكون معظم بياناتك على القرص، يوفر DiskANN وقت استجابة أفضل.</p>
</div>
<h3 id="Recall" class="common-anchor-header">الاستدعاء</h3><p>يتضمن الاستدعاء عادةً نسبة التصفية، والتي تشير إلى البيانات التي يتم تصفيتها قبل عمليات البحث. عند التعامل مع الاستدعاء، ضع في اعتبارك ما يلي:</p>
<ul>
<li><p>إذا كانت نسبة التصفية أقل من 85%، تتفوق أنواع الفهرس المستندة إلى الرسم البياني على متغيرات IVF.</p></li>
<li><p>إذا كانت نسبة التصفية بين 85% و95%، فاستخدم متغيرات IVF.</p></li>
<li><p>إذا كانت نسبة التصفية أكثر من 98%، فاستخدم متغيرات (FLAT) للحصول على نتائج بحث أكثر دقة.</p></li>
</ul>
<div class="alert note">
<p>العناصر المذكورة أعلاه ليست صحيحة دائمًا. يُنصح بضبط الاستدعاء باستخدام أنواع مختلفة من الفهرس لتحديد نوع الفهرس الذي يعمل.</p>
</div>
<h3 id="Performance" class="common-anchor-header">الأداء</h3><p>عادةً ما يتضمن أداء البحث عادةً أعلى K، والذي يشير إلى عدد السجلات التي يُرجعها البحث. عند التعامل مع الأداء، ضع في اعتبارك ما يلي:</p>
<ul>
<li><p>بالنسبة للبحث الذي يحتوي على أعلى K صغير (على سبيل المثال، 2,000) يتطلب معدل استدعاء مرتفع، تتفوق أنواع الفهارس المستندة إلى الرسم البياني على متغيرات IVF.</p></li>
<li><p>بالنسبة للبحث الذي يحتوي على أعلى K كبير (مقارنةً بالعدد الإجمالي لتضمينات المتجهات)، تعد متغيرات IVF خيارًا أفضل من أنواع الفهرس المستندة إلى الرسم البياني.</p></li>
<li><p>بالنسبة للبحث الذي يحتوي على أعلى K متوسط الحجم ونسبة تصفية عالية، فإن متغيرات IVF هي الخيارات الأفضل.</p></li>
</ul>
<h3 id="Decision-Matrix-Choosing-the-most-appropriate-index-type" class="common-anchor-header">مصفوفة القرار: اختيار نوع الفهرس الأنسب</h3><p>الجدول التالي هو مصفوفة قرارات يمكنك الرجوع إليها عند اختيار نوع الفهرس المناسب.</p>
<table>
   <tr>
     <th><p>السيناريو</p></th>
     <th><p>الفهرس الموصى به</p></th>
     <th><p>الملاحظات</p></th>
   </tr>
   <tr>
     <td><p>بيانات أولية تناسب الذاكرة</p></td>
     <td><p>HNSW، IVF + التنقيح</p></td>
     <td><p>استخدم HNSW للاستدعاء المنخفض<code translate="no">k</code>/عالي الاستدعاء.</p></td>
   </tr>
   <tr>
     <td><p>البيانات الأولية على القرص، SSD</p></td>
     <td><p>DiskANN</p></td>
     <td><p>الأمثل للاستعلامات الحساسة لوقت الاستجابة.</p></td>
   </tr>
   <tr>
     <td><p>بيانات أولية على القرص، ذاكرة وصول عشوائي محدودة</p></td>
     <td><p>IVFPQ/SQ + mmap</p></td>
     <td><p>يوازن بين الوصول إلى الذاكرة والقرص.</p></td>
   </tr>
   <tr>
     <td><p>نسبة تصفية عالية (&gt;95%)</p></td>
     <td><p>القوة الغاشمة (FLAT)</p></td>
     <td><p>يتجنب النفقات العامة للفهرس للمجموعات المرشحة الصغيرة.</p></td>
   </tr>
   <tr>
     <td><p>كبير <code translate="no">k</code> (≥1% من مجموعة البيانات)</p></td>
     <td><p>IVF</p></td>
     <td><p>يقلل التقليم العنقودي من العمليات الحسابية.</p></td>
   </tr>
   <tr>
     <td><p>معدل استرجاع مرتفع للغاية (&gt;99%)</p></td>
     <td><p>القوة الغاشمة (FLAT) + وحدات معالجة الرسوميات</p></td>
     <td><p>--</p></td>
   </tr>
</table>
<h2 id="Memory-usage-estimation" class="common-anchor-header">تقدير استخدام الذاكرة<button data-href="#Memory-usage-estimation" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><div class="alert note">
<p>يركز هذا القسم على حساب استهلاك الذاكرة لنوع معين من الفهرس ويتضمن العديد من التفاصيل الفنية. يمكنك تخطي هذا القسم بأمان إذا كان لا يتماشى مع اهتماماتك.</p>
</div>
<p>يتأثر استهلاك الذاكرة لفهرس ما ببنية بياناته، ومعدل الضغط من خلال التكميم والمصفاة المستخدمة. بشكل عام، عادةً ما يكون للمؤشرات القائمة على الرسم البياني بصمة ذاكرة أعلى بسبب بنية الرسم البياني (على سبيل المثال، <strong>HNSW</strong>)، والتي عادةً ما تنطوي على مساحة زائدة ملحوظة لكل ناقل. في المقابل، فإن IVF ومتغيراته أكثر كفاءة من حيث الذاكرة لأن مساحة المساحة الزائدة لكل ناقل أقل. ومع ذلك، فإن التقنيات المتقدمة مثل <strong>DiskANN</strong> تسمح لأجزاء من الفهرس، مثل الرسم البياني أو المصفاة، بالإقامة على القرص، مما يقلل من حمل الذاكرة مع الحفاظ على الأداء.</p>
<p>على وجه التحديد، يمكن حساب استخدام ذاكرة الفهرس على النحو التالي:</p>
<h3 id="IVF-index-memory-usage" class="common-anchor-header">استخدام ذاكرة فهرس IVF</h3><p>توازن فهارس IVF بين كفاءة الذاكرة وأداء البحث من خلال تقسيم البيانات إلى مجموعات. فيما يلي تفصيل للذاكرة المستخدمة من قبل مليون متجه ذي 128 بُعدًا مفهرسًا باستخدام متغيرات IVF.</p>
<ol>
<li><p><strong>حساب الذاكرة المستخدمة من قبل المتجهات المركزية.</strong></p>
<p>تمكّن أنواع الفهرس من سلسلة IVF Milvus من تجميع المتجهات في مجموعات باستخدام التقسيم القائم على النقط المركزية. يتم تضمين كل مركزية في الفهرس في تضمين المتجهات الخام. عند تقسيم المتجهات إلى 2000 مجموعة، يمكن حساب استخدام الذاكرة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">2,000 clusters × 128 dimensions × 4 bytes = 1.0 MB
<button class="copy-code-btn"></button></code></pre></li>
<li><p><strong>حساب الذاكرة المستخدمة بواسطة تعيينات المجموعات.</strong></p>
<p>يتم تعيين كل تضمين متجه إلى مجموعة وتخزينها كمعرّفات أعداد صحيحة. بالنسبة إلى 2,000 مجموعة، يكفي عدد صحيح بحجم 2 بايت. يمكن حساب استخدام الذاكرة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 2 bytes = 2.0 MB
<button class="copy-code-btn"></button></code></pre></li>
<li><p><strong>حساب الضغط الناجم عن التكميم.</strong></p>
<p>تستخدم متغيرات IVF عادةً PQ و SQ8، ويمكن تقدير استخدام الذاكرة على النحو التالي:</p>
<ul>
<li><p>باستخدام PQ مع 8 وحدات تكميم فرعية</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 8 bytes = 8.0 MB
<button class="copy-code-btn"></button></code></pre></li>
<li><p>باستخدام SQ8</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 128 dimensions × 1 byte = 128 MB 
<button class="copy-code-btn"></button></code></pre></li>
</ul>
<p>يسرد الجدول التالي الاستخدام التقديري للذاكرة مع تكوينات مختلفة:</p>
<p><table>
<tr>
<th><p>التكوين</p></th>
<th><p>تقدير الذاكرة</p></th>
<th><p>إجمالي الذاكرة</p></th>
</tr>
<tr>
<td><p>IVF-PQ (بدون تنقيح)</p></td>
<td><p>1.0 ميجا بايت + 2.0 ميجا بايت + 8.0 ميجا بايت</p></td>
<td><p>11.0 ميغابايت</p></td>
</tr>
<tr>
<td><p>IVF-PQ + 10٪ تنقيح أولي</p></td>
<td><p>1.0 ميجا بايت + 2.0 ميجا بايت + 8.0 ميجا بايت + 51.2 ميجا بايت</p></td>
<td><p>62.2 ميغابايت</p></td>
</tr>
<tr>
<td><p>IVF-SQ8 (بدون تنقيح)</p></td>
<td><p>1.0 ميجا بايت + 2.0 ميجا بايت + 128 ميجا بايت</p></td>
<td><p>131.0 ميغابايت</p></td>
</tr>
<tr>
<td><p>IVF-FLAT (متجهات خام كاملة)</p></td>
<td><p>1.0 ميجا بايت + 2.0 ميجا بايت + 512 ميجا بايت</p></td>
<td><p>515.0 ميغابايت</p></td>
</tr>
</table></p></li>
<li><p><strong>حساب النفقات العامة للتنقية.</strong></p>
<p>غالبًا ما تقترن متغيرات IVF بمصفاة لإعادة تصنيف المرشحين. بالنسبة للبحث الذي يسترجع أفضل 10 نتائج بمعدل توسع 5، يمكن تقدير نفقات التنقيح على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">10 (topK) x 5 (expansion rate) = 50 candidates
50 candidates x 128 dimensions x 4 bytes = 25.6 KB
<button class="copy-code-btn"></button></code></pre></li>
</ol>
<h3 id="Graph-based-index-memory-usage" class="common-anchor-header">استخدام ذاكرة الفهرس القائم على الرسم البياني</h3><p>تتطلب أنواع الفهارس المستندة إلى الرسم البياني مثل HNSW ذاكرة كبيرة لتخزين كل من بنية الرسم البياني والتضمينات المتجهة الخام. فيما يلي تحليل مفصل للذاكرة التي يستهلكها مليون متجه ذي 128 بُعدًا مفهرسًا باستخدام نوع فهرس HNSW.</p>
<ol>
<li><p><strong>احسب الذاكرة التي تستخدمها بنية الرسم البياني.</strong></p>
<p>يحتفظ كل متجه في HNSW باتصالات مع جيرانه. مع درجة رسم بياني (حواف لكل عقدة) تبلغ 32، يمكن حساب الذاكرة المستهلكة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 32 links × 4 bytes (for 32-bit integer storage) = 128 MB  
<button class="copy-code-btn"></button></code></pre></li>
<li><p><strong>حساب الذاكرة المستخدمة بواسطة تضمينات المتجهات الخام.</strong></p>
<p>يمكن حساب الذاكرة المستهلكة من خلال تخزين متجهات FP32 غير المضغوطة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 128 dimensions × 4 bytes = 512 MB  
<button class="copy-code-btn"></button></code></pre>
<p>عند استخدام HNSW لفهرسة مليون تضمين متجه ذي 128 بُعدًا، سيكون إجمالي الذاكرة المستخدمة <strong>128 ميغابايت (رسم بياني) + 512 ميغابايت (متجهات) = 640 ميغابايت</strong>.</p></li>
<li><p><strong>احسب الضغط الناتج عن التكميم.</strong></p>
<p>يقلل التكميم من حجم المتجهات. على سبيل المثال، يؤدي استخدام PQ مع 8 وحدات تكميم فرعية (8 بايت لكل متجه) إلى ضغط كبير. يمكن حساب الذاكرة التي تستهلكها تضمينات المتجهات المضغوطة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">1,000,000 vectors × 8 bytes = 8 MB
<button class="copy-code-btn"></button></code></pre>
<p>يحقق ذلك معدل ضغط يبلغ 64 ضعفًا عند مقارنته بتضمينات المتجهات الخام، وسيكون إجمالي الذاكرة المستخدمة بواسطة نوع فهرس <strong>HNSWPQ</strong> <strong>128 ميغابايت (رسم بياني) + 8 ميغابايت (متجه مضغوط) = 136 ميغابايت</strong>.</p></li>
<li><p><strong>حساب النفقات العامة للتنقيح.</strong></p>
<p>يؤدي التنقيح، مثل إعادة الترتيب باستخدام المتجهات الخام، إلى تحميل البيانات عالية الدقة مؤقتًا في الذاكرة. بالنسبة للبحث الذي يسترجع أفضل 10 نتائج بمعدل توسع 5، يمكن تقدير نفقات التنقيح الزائدة على النحو التالي:</p>
<pre><code translate="no" class="language-plaintext">10 (topK) x 5 (expansion rate) = 50 candidates
50 candidates x 128 dimensions x 4 bytes = 25.6 KB
<button class="copy-code-btn"></button></code></pre></li>
</ol>
<h3 id="Other-considerations" class="common-anchor-header">اعتبارات أخرى</h3><p>بينما تعمل فهارس IVF والفهارس المستندة إلى الرسم البياني على تحسين استخدام الذاكرة من خلال التكميم، فإن الملفات المعينة بالذاكرة (mmap) وDiskANN تعالج سيناريوهات معالجة مجموعات البيانات التي تتجاوز ذاكرة الوصول العشوائي (RAM) المتاحة.</p>
<h4 id="DiskANN" class="common-anchor-header">DiskANN</h4><p>DiskANN عبارة عن فهرس قائم على الرسم البياني Vamana الذي يربط نقاط البيانات للتنقل الفعال أثناء البحث مع تطبيق PQ لتقليل حجم المتجهات وتمكين حساب المسافة التقريبية السريعة بين المتجهات.</p>
<p>يتم تخزين الرسم البياني Vamana على القرص، مما يسمح ل DiskANN بالتعامل مع مجموعات البيانات الكبيرة التي قد تكون كبيرة جدًا بحيث لا يمكن وضعها في الذاكرة. وهذا مفيد بشكل خاص لمجموعات البيانات ذات المليار نقطة.</p>
<h4 id="Memory-mapped-files-mmap" class="common-anchor-header">ملفات تعيين الذاكرة (mmap)</h4><p>يتيح تخطيط الذاكرة (Mmap) الوصول المباشر للذاكرة إلى الملفات الكبيرة على القرص، مما يسمح لـ Milvus بتخزين الفهارس والبيانات في كل من الذاكرة والأقراص الصلبة. يساعد هذا النهج على تحسين عمليات الإدخال/الإخراج من خلال تقليل النفقات العامة لاستدعاءات الإدخال/الإخراج بناءً على تكرار الوصول، وبالتالي توسيع سعة التخزين للمجموعات دون التأثير بشكل كبير على أداء البحث.</p>
<p>على وجه التحديد، يمكنك تكوين Milvus لتعيين البيانات الأولية في حقول معينة في الذاكرة بدلاً من تحميلها بالكامل في الذاكرة. بهذه الطريقة، يمكنك الحصول على وصول مباشر للذاكرة إلى الحقول دون القلق بشأن مشاكل الذاكرة وتوسيع سعة المجموعة.</p>
