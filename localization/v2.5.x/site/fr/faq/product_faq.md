---
id: product_faq.md
summary: >-
  Trouvez les réponses aux questions les plus fréquemment posées sur la base de
  données vectorielles la plus avancée au monde.
title: FAQ sur les produits
---

<h1 id="Product-FAQ" class="common-anchor-header">FAQ sur les produits<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Combien coûte Milvus ?</h4><p>Milvus est un projet open-source 100% gratuit.</p>
<p>Veuillez respecter la <a href="http://www.apache.org/licenses/LICENSE-2.0">licence Apache 2.0</a> lorsque vous utilisez Milvus à des fins de production ou de distribution.</p>
<p>Zilliz, la société à l'origine de Milvus, propose également une version cloud entièrement gérée de la plateforme pour ceux qui ne souhaitent pas construire et maintenir leur propre instance distribuée. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> maintient automatiquement la fiabilité des données et permet aux utilisateurs de ne payer que pour ce qu'ils utilisent.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Milvus prend-il en charge les architectures non-x86 ?</h4><p>Milvus ne peut pas être installé ou exécuté sur des plates-formes non-x86.</p>
<p>Votre processeur doit prendre en charge l'un des jeux d'instructions suivants pour exécuter Milvus : SSE4.2, AVX, AVX2, AVX512. Il s'agit de jeux d'instructions SIMD dédiés à l'architecture x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Où Milvus stocke-t-il les données ?</h4><p>Milvus traite deux types de données : les données insérées et les métadonnées.</p>
<p>Les données insérées, y compris les données vectorielles, les données scalaires et le schéma spécifique à la collection, sont stockées dans un stockage persistant sous forme de journal incrémentiel. Milvus prend en charge plusieurs backends de stockage d'objets, notamment <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> et <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Les métadonnées sont générées au sein de Milvus. Chaque module Milvus a ses propres métadonnées qui sont stockées dans etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Pourquoi n'y a-t-il pas de données vectorielles dans etcd ?</h4><p>etcd stocke les métadonnées des modules Milvus ; MinIO stocke les entités.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Milvus prend-il en charge l'insertion et la recherche de données simultanément ?</h4><p>Oui. Les opérations d'insertion et les opérations de recherche sont gérées par deux modules distincts qui sont mutuellement indépendants. Du point de vue du client, une opération d'insertion est terminée lorsque les données insérées entrent dans la file d'attente des messages. Cependant, les données insérées ne sont pas consultables tant qu'elles ne sont pas chargées dans le nœud d'interrogation. Si la taille du segment n'atteint pas le seuil de construction de l'index (512 Mo par défaut), Milvus a recours à la recherche par force brute et les performances de la requête peuvent être réduites.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Les vecteurs dont les clés primaires sont dupliquées peuvent-ils être insérés dans Milvus ?</h4><p>Oui. Milvus ne vérifie pas si les clés primaires des vecteurs sont dupliquées.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Lorsque des vecteurs avec des clés primaires dupliquées sont insérés, Milvus les traite-t-il comme une opération de mise à jour ?</h4><p>Non. Milvus ne prend pas actuellement en charge les opérations de mise à jour et ne vérifie pas si les clés primaires des entités sont dupliquées. Il vous incombe de vous assurer que les clés primaires des entités sont uniques et, si ce n'est pas le cas, Milvus peut contenir plusieurs entités avec des clés primaires dupliquées.</p>
<p>Dans ce cas, la copie de données qui sera renvoyée lors d'une requête reste un comportement inconnu. Cette limitation sera corrigée dans les prochaines versions.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Quelle est la longueur maximale des clés primaires d'entité auto-définies ?</h4><p>Les clés primaires des entités doivent être des nombres entiers non négatifs de 64 bits.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Quelle est la quantité maximale de données pouvant être ajoutées par opération d'insertion ?</h4><p>La taille d'une opération d'insertion ne doit pas dépasser 1 024 Mo. Il s'agit d'une limite imposée par gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">La taille de la collection a-t-elle un impact sur les performances de la requête lors d'une recherche dans une partition spécifique ?</h4><p>Non. Si des partitions sont spécifiées pour une recherche, Milvus recherche uniquement dans les partitions spécifiées.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Milvus doit-il charger l'ensemble de la collection lorsque des partitions sont spécifiées pour une recherche ?</h4><p>Cela dépend des données nécessaires à la recherche. Toutes les partitions susceptibles d'apparaître dans les résultats de la recherche doivent être chargées avant la recherche.</p>
<ul>
<li>Par exemple, si vous ne souhaitez rechercher qu'une ou plusieurs partitions spécifiques, il n'est pas nécessaire de charger toutes les partitions. Appelez <code translate="no">load_partition()</code> pour charger la ou les partition(s) voulue(s) <em>, puis</em> spécifiez la ou les partition(s) dans l'appel de la méthode <code translate="no">search()</code>.</li>
<li>Si vous souhaitez rechercher toutes les partitions, appelez <code translate="no">load_collection()</code> pour charger l'ensemble de la collection, y compris toutes les partitions.</li>
<li>Si vous ne chargez pas la collection ou une ou plusieurs partitions spécifiques avant d'effectuer la recherche, Milvus renvoie une erreur.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Peut-on créer des index après avoir inséré des vecteurs ?</h4><p>Oui. Si un index a été construit pour une collection par <code translate="no">create_index()</code> auparavant, Milvus construira automatiquement un index pour les vecteurs insérés ultérieurement. Toutefois, Milvus ne construit pas d'index tant que les vecteurs nouvellement insérés ne remplissent pas un segment entier et que le fichier d'index nouvellement créé n'est pas séparé du précédent.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">En quoi les index FLAT et IVF_FLAT sont-ils différents ?</h4><p>L'index IVF_FLAT divise l'espace vectoriel en groupes de listes. Avec la valeur de liste par défaut de 16 384, Milvus compare les distances entre le vecteur cible et les centroïdes de tous les 16 384 clusters pour renvoyer les clusters les plus proches de la sonde. Milvus compare ensuite les distances entre le vecteur cible et les vecteurs des grappes sélectionnées pour obtenir les vecteurs les plus proches. Contrairement à IVF_FLAT, FLAT compare directement les distances entre le vecteur cible et tous les autres vecteurs.</p>
<p>Lorsque le nombre total de vecteurs est approximativement égal à nlist, il y a peu de différence entre IVF_FLAT et FLAT en termes d'exigences de calcul et de performances de recherche. Toutefois, lorsque le nombre de vecteurs dépasse nlist d'un facteur de deux ou plus, IVF_FLAT commence à présenter des avantages en termes de performances.</p>
<p>Voir <a href="/docs/fr/v2.5.x/index.md">Index des vecteurs</a> pour plus d'informations.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Comment Milvus extrait-il les données ?</h4><p>Milvus renvoie un succès lorsque les données insérées sont ingérées dans la file d'attente des messages. Toutefois, les données ne sont pas encore transférées sur le disque. Le nœud de données de Milvus écrit alors les données de la file d'attente de messages dans le stockage persistant sous forme de journaux incrémentiels. Si <code translate="no">flush()</code> est appelé, le nœud de données est forcé d'écrire immédiatement toutes les données de la file d'attente des messages dans le stockage permanent.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Qu'est-ce que la normalisation ? Pourquoi la normalisation est-elle nécessaire ?</h4><p>La normalisation est le processus de conversion d'un vecteur de sorte que sa norme soit égale à 1. Si le produit intérieur est utilisé pour calculer la similarité vectorielle, les vecteurs doivent être normalisés. Après normalisation, le produit intérieur est égal à la similarité en cosinus.</p>
<p>Voir <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> pour plus d'informations.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Pourquoi la distance euclidienne (L2) et le produit intérieur (PI) donnent-ils des résultats différents ?</h4><p>Pour les vecteurs normalisés, la distance euclidienne (L2) est mathématiquement équivalente au produit intérieur (PI). Si ces mesures de similarité donnent des résultats différents, vérifiez si vos vecteurs sont normalisés.</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Y a-t-il une limite au nombre total de collections et de partitions dans Milvus ?</h4><p>Oui. Vous pouvez créer jusqu'à 65 535 collections dans une instance Milvus. Lors du calcul du nombre de collections existantes, Milvus prend en compte toutes les collections contenant des tessons et des partitions.</p>
<p>Par exemple, supposons que vous ayez déjà créé 100 collections, avec 2 shards et 4 partitions dans 60 d'entre elles et avec 1 shard et 12 partitions dans les 40 collections restantes. Le nombre actuel de collections peut être calculé comme suit :</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Pourquoi est-ce que j'obtiens moins de k vecteurs lorsque je cherche <code translate="no">topk</code> vecteurs ?</h4><p>Parmi les index pris en charge par Milvus, IVF_FLAT et IVF_SQ8 mettent en œuvre la méthode de regroupement k-means. Un espace de données est divisé en <code translate="no">nlist</code> clusters et les vecteurs insérés sont distribués dans ces clusters. Milvus sélectionne ensuite les <code translate="no">nprobe</code> grappes les plus proches et compare les distances entre le vecteur cible et tous les vecteurs dans les grappes sélectionnées pour renvoyer les résultats finaux.</p>
<p>Si <code translate="no">nlist</code> et <code translate="no">topk</code> sont grands et que nprobe est petit, le nombre de vecteurs dans les grappes nprobe peut être inférieur à <code translate="no">k</code>. Par conséquent, lorsque vous recherchez les vecteurs les plus proches <code translate="no">topk</code>, le nombre de vecteurs renvoyés est inférieur à <code translate="no">k</code>.</p>
<p>Pour éviter cela, essayez d'augmenter <code translate="no">nprobe</code> et de réduire <code translate="no">nlist</code> et <code translate="no">k</code>.</p>
<p>Voir <a href="/docs/fr/v2.5.x/index.md">Index des vecteurs</a> pour plus d'informations.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Quelle est la dimension vectorielle maximale prise en charge par Milvus ?</h4><p>Milvus peut gérer des vecteurs ayant jusqu'à 32 768 dimensions par défaut. Vous pouvez augmenter la valeur de <code translate="no">Proxy.maxDimension</code> pour permettre un vecteur de plus grande dimension.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Milvus prend-il en charge le processeur Apple M1 ?</h4><p>La version actuelle de Milvus ne prend pas directement en charge le processeur Apple M1. Après Milvus 2.3, Milvus fournit des images Docker pour l'architecture ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Quels types de données Milvus prend-il en charge dans le champ de clé primaire ?</h4><p>Dans la version actuelle, Milvus prend en charge à la fois INT64 et les chaînes de caractères.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Milvus est-il évolutif ?</h4><p>Oui. Vous pouvez déployer le cluster Milvus avec plusieurs nœuds via Helm Chart sur Kubernetes. Reportez-vous au <a href="/docs/fr/v2.5.x/scaleout.md">Guide de mise à l'échelle</a> pour plus d'instructions.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Qu'est-ce qu'un segment croissant et un segment scellé ?</h4><p>Lorsqu'une demande de recherche arrive, Milvus recherche à la fois des données incrémentielles et des données historiques. Les données incrémentielles sont des mises à jour récentes, elles sont stockées dans les segments croissants, qui sont mis en mémoire tampon avant d'atteindre le seuil de persistance dans le stockage d'objets et un index plus efficace est construit pour elles, tandis que les données historiques sont des mises à jour qui datent d'il y a un certain temps. Elles se trouvent dans les segments scellés qui ont été conservés dans le stockage d'objets. Les données incrémentielles et les données historiques constituent ensemble l'ensemble des données à rechercher. Grâce à cette conception, toutes les données intégrées à Milvus sont instantanément consultables. Pour Milvus Distribué, il existe des facteurs plus complexes qui déterminent quand un enregistrement qui vient d'être ingéré peut apparaître dans les résultats de recherche. Pour en savoir plus, consultez les <a href="https://milvus.io/docs/consistency.md">niveaux de cohérence</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Milvus est-il disponible pour la recherche simultanée ?</h4><p>Oui. Pour les requêtes sur la même collection, Milvus recherche simultanément les données incrémentielles et historiques. Toutefois, les requêtes sur différentes collections sont effectuées en série. Alors que les données historiques peuvent constituer un ensemble de données extrêmement volumineux, les recherches sur les données historiques prennent relativement plus de temps et sont essentiellement effectuées en série.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Pourquoi les données de MinIO sont-elles conservées après l'abandon de la collection correspondante ?</h4><p>Les données dans MinIO sont conçues pour rester pendant un certain temps afin de faciliter le retour en arrière des données.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Milvus prend-il en charge des moteurs de messages autres que Pulsar ?</h4><p>Oui. Kafka est pris en charge dans Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">Quelle est la différence entre une recherche et une requête ?</h4><p>Dans Milvus, une recherche de similarité vectorielle récupère des vecteurs sur la base du calcul de similarité et de l'accélération de l'index vectoriel. Contrairement à une recherche de similarité vectorielle, une requête vectorielle récupère des vecteurs via un filtrage scalaire basé sur une expression booléenne. L'expression booléenne filtre les champs scalaires ou le champ de clé primaire, et récupère tous les résultats qui correspondent aux filtres. Dans une requête, ni la métrique de similarité ni l'index vectoriel ne sont impliqués.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Pourquoi une valeur vectorielle flottante a-t-elle une précision de 7 chiffres après la virgule dans Milvus ?</h4><p>Milvus prend en charge le stockage des vecteurs en tant que tableaux Float32. Une valeur Float32 a une précision de 7 chiffres après la virgule. Même avec une valeur Float64, telle que 1.3476964684980388, Milvus la stocke sous la forme 1.347696. Par conséquent, lorsque vous récupérez un tel vecteur dans Milvus, la précision de la valeur Float64 est perdue.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Comment Milvus gère-t-il les types de données vectorielles et la précision ?</h4><p>Milvus prend en charge les types de vecteurs Binary, Float32, Float16 et BFloat16.</p>
<ul>
<li>Vecteurs binaires : Stockent des données binaires sous forme de séquences de 0 et de 1. Ils sont utilisés dans le traitement des images et la recherche d'informations.</li>
<li>Vecteurs de type Float32 : Stockage par défaut avec une précision d'environ 7 chiffres après la virgule. Même les valeurs Float64 sont stockées avec une précision Float32, ce qui peut entraîner une perte de précision lors de la recherche.</li>
<li>Vecteurs Float16 et BFloat16 : Ils offrent une précision et une utilisation de la mémoire réduites. Float16 convient aux applications dont la bande passante et le stockage sont limités, tandis que BFloat16 équilibre la portée et l'efficacité, couramment utilisé dans l'apprentissage profond pour réduire les exigences de calcul sans avoir d'impact significatif sur la précision.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Milvus prend-il en charge la spécification de valeurs par défaut pour les champs scalaires ou vectoriels ?</h4><p>Actuellement, Milvus 2.4.x ne prend pas en charge la spécification de valeurs par défaut pour les champs scalaires ou vectoriels. Cette fonctionnalité est prévue pour les prochaines versions.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">L'espace de stockage est-il libéré immédiatement après la suppression des données dans Milvus ?</h4><p>Non, l'espace de stockage n'est pas immédiatement libéré lorsque vous supprimez des données dans Milvus. Bien que la suppression de données marque les entités comme "logiquement supprimées", l'espace réel peut ne pas être libéré instantanément. Voici pourquoi :</p>
<ul>
<li><strong>Compactage</strong>: Milvus compacte automatiquement les données en arrière-plan. Ce processus fusionne des segments de données plus petits en segments plus grands et supprime les données supprimées logiquement (entités marquées pour la suppression) ou les données qui ont dépassé leur durée de vie (TTL). Cependant, le compactage crée de nouveaux segments tout en marquant les anciens comme "abandonnés".</li>
<li><strong>Collecte des déchets</strong>: Un processus distinct appelé Garbage Collection (GC) supprime périodiquement ces segments "abandonnés", libérant ainsi l'espace de stockage qu'ils occupaient. Cela garantit une utilisation efficace de l'espace de stockage, mais peut entraîner un léger délai entre la suppression et la récupération de l'espace.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">Puis-je voir les données insérées, supprimées ou réinsérées immédiatement après l'opération, sans attendre la vidange ?</h4><p>Oui, dans Milvus, la visibilité des données n'est pas directement liée aux opérations de vidage en raison de son architecture de désagrégation du stockage et du calcul. Vous pouvez gérer la lisibilité des données à l'aide des niveaux de cohérence.</p>
<p>Lors de la sélection d'un niveau de cohérence, tenez compte des compromis entre la cohérence et les performances. Pour les opérations nécessitant une visibilité immédiate, utilisez un niveau de cohérence "fort". Pour des écritures plus rapides, donnez la priorité à une cohérence plus faible (les données peuvent ne pas être immédiatement visibles). Pour plus d'informations, reportez-vous à la section <a href="/docs/fr/v2.5.x/consistency.md">Cohérence</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">Après avoir activé la fonction de clé de partition, quelle est la valeur par défaut de <code translate="no">num_partitions</code> dans Milvus, et pourquoi ?</h4><p>Lorsque la fonction de clé de partition est activée, la valeur par défaut de <code translate="no">num_partitions</code> dans Milvus est définie sur <code translate="no">16</code>. Cette valeur par défaut est choisie pour des raisons de stabilité et de performances. Vous pouvez ajuster la valeur de <code translate="no">num_partitions</code> selon vos besoins en la spécifiant dans la fonction <code translate="no">create_collection</code>.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">Existe-t-il une limite de longueur maximale pour les expressions de filtrage scalaire ?</h4><p>Oui, la longueur maximale d'une expression de filtrage scalaire est limitée par la limite de transfert RPC, qui est définie dans le fichier de configuration <code translate="no">milvus.yaml</code>. Plus précisément, la limite est fixée par le paramètre <code translate="no">serverMaxRecvSize</code> dans la section proxy :</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Par défaut, la taille maximale de chaque requête RPC est de 64 Mo. Par conséquent, la longueur de l'expression de filtrage doit être inférieure à cette limite pour garantir un traitement réussi.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">Lors d'une recherche de vecteurs en masse, combien de vecteurs peuvent être spécifiés à la fois ? Y a-t-il une limite ?</h4><p>Oui, le nombre de vecteurs qui peuvent être spécifiés dans une recherche de vecteurs en bloc est limité par la taille du transfert RPC, telle qu'elle est définie dans le fichier de configuration <code translate="no">milvus.yaml</code>. Cette limite est déterminée par le paramètre <code translate="no">serverMaxRecvSize</code> dans la section proxy :</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Par défaut, la taille maximale de chaque requête RPC est de 64 Mo. Par conséquent, la taille totale des vecteurs d'entrée, y compris leurs données dimensionnelles et leurs métadonnées, doit être inférieure à cette limite pour garantir une exécution réussie.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Comment puis-je obtenir toutes les valeurs uniques d'un champ scalaire donné à partir d'une collection？ ?</h4><p>Actuellement, il n'existe pas de méthode directe pour y parvenir. Comme solution de contournement, nous recommandons d'utiliser un query_iterator pour récupérer toutes les valeurs d'un champ spécifique, puis d'effectuer la déduplication manuellement. Nous prévoyons d'ajouter une prise en charge directe de cette fonctionnalité dans Milvus 2.6. Exemple d'utilisation d'un query_iterator :</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column </span>
<button class="copy-code-btn"></button></code></pre>

<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">Quelles sont les limites de l'utilisation des champs dynamiques ? Par exemple, y a-t-il des limites de taille, des méthodes de modification ou des restrictions d'indexation ?</h4><p>Les champs dynamiques sont représentés en interne à l'aide de champs JSON, dont la taille est limitée à 65 536 octets. Ils prennent en charge les modifications upsert, ce qui vous permet d'ajouter ou de mettre à jour des champs. Toutefois, à partir de Milvus 2.5.1, les champs dynamiques ne prennent pas en charge l'indexation. La prise en charge de l'ajout d'index pour JSON sera introduite dans les prochaines versions.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">Milvus prend-il en charge les modifications de schéma ?</h4><p>Depuis la version 2.5.0 de Milvus, les modifications de schéma sont limitées à des modifications spécifiques, telles que l'ajustement de propriétés comme le paramètre <code translate="no">mmap</code>. Les utilisateurs peuvent également modifier le paramètre <code translate="no">max_length</code> pour les champs varchar et <code translate="no">max_capacity</code> pour les champs de type tableau. Toutefois, la possibilité d'ajouter ou de supprimer des champs dans les schémas est prévue pour les prochaines versions, ce qui améliorera la flexibilité de la gestion des schémas dans Milvus.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">La modification de max_length pour VarChar nécessite-t-elle une réorganisation des données ?</h4><p>Non, la modification de <code translate="no">max_length</code> pour un champ VarChar ne nécessite pas de réorganisation des données, telle que le compactage ou la réorganisation. Cet ajustement met principalement à jour les critères de validation pour toute nouvelle donnée insérée dans le champ, les données existantes n'étant pas affectées. Par conséquent, cette modification est considérée comme légère et n'impose pas de surcharge significative au système.</p>
<h4 id="Still-have-questions" class="common-anchor-header">Vous avez encore des questions ?</h4><p>Vous pouvez le faire :</p>
<ul>
<li>Consulter <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> sur GitHub. Vous pouvez poser des questions, partager des idées et aider les autres.</li>
<li>Rejoignez notre <a href="https://slack.milvus.io/">communauté Slack</a> pour trouver de l'aide et vous engager avec notre communauté open-source.</li>
</ul>
