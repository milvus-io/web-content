---
id: product_faq.md
summary: >-
  Temukan jawaban atas pertanyaan yang sering diajukan tentang basis data vektor
  tercanggih di dunia.
title: Tanya Jawab Produk
---

<h1 id="Product-FAQ" class="common-anchor-header">Tanya Jawab Produk<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Berapa harga Milvus?</h4><p>Milvus adalah proyek sumber terbuka yang 100% gratis.</p>
<p>Harap patuhi <a href="http://www.apache.org/licenses/LICENSE-2.0">Lisensi Apache 2.0</a> ketika menggunakan Milvus untuk tujuan produksi atau distribusi.</p>
<p>Zilliz, perusahaan di balik Milvus, juga menawarkan versi cloud yang dikelola sepenuhnya dari platform ini bagi mereka yang tidak ingin membangun dan memelihara instance terdistribusi mereka sendiri. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> secara otomatis menjaga keandalan data dan memungkinkan pengguna membayar hanya untuk apa yang mereka gunakan.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Apakah Milvus mendukung arsitektur non-x86?</h4><p>Milvus tidak dapat diinstal atau dijalankan pada platform non-x86.</p>
<p>CPU Anda harus mendukung salah satu set instruksi berikut untuk menjalankan Milvus: SSE4.2, AVX, AVX2, AVX512. Ini semua adalah set instruksi SIMD khusus x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Di mana Milvus menyimpan data?</h4><p>Milvus menangani dua jenis data, data yang disisipkan dan metadata.</p>
<p>Data yang disisipkan, termasuk data vektor, data skalar, dan skema khusus koleksi, disimpan dalam penyimpanan persisten sebagai log tambahan. Milvus mendukung beberapa backend penyimpanan objek, termasuk <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a>, dan <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Metadata dibuat di dalam Milvus. Setiap modul Milvus memiliki metadata sendiri yang disimpan dalam etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Mengapa tidak ada data vektor di etcd?</h4><p>etcd menyimpan metadata modul Milvus; MinIO menyimpan entitas.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Apakah Milvus mendukung penyisipan dan pencarian data secara bersamaan?</h4><p>Ya. Operasi penyisipan dan operasi kueri ditangani oleh dua modul terpisah yang saling independen. Dari perspektif klien, operasi penyisipan selesai ketika data yang disisipkan masuk ke dalam antrian pesan. Namun, data yang disisipkan tidak dapat dicari sampai data tersebut dimuat ke node kueri. Jika ukuran segmen tidak mencapai ambang batas pembuatan indeks (512 MB secara default), Milvus menggunakan pencarian brute-force dan kinerja kueri dapat berkurang.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Dapatkah vektor dengan kunci primer ganda dimasukkan ke dalam Milvus?</h4><p>Ya. Milvus tidak memeriksa apakah kunci primer vektor adalah duplikat.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Ketika vektor dengan kunci primer ganda dimasukkan, apakah Milvus memperlakukannya sebagai operasi pembaruan?</h4><p>Tidak. Milvus saat ini tidak mendukung operasi pembaruan dan tidak memeriksa apakah kunci utama entitas adalah duplikat. Anda bertanggung jawab untuk memastikan bahwa primary key entitas adalah unik, dan jika tidak, Milvus dapat berisi beberapa entitas dengan primary key yang terduplikasi.</p>
<p>Jika hal ini terjadi, salinan data mana yang akan dikembalikan ketika ditanyakan masih belum diketahui. Batasan ini akan diperbaiki di rilis mendatang.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Berapa panjang maksimum dari kunci primer entitas yang ditentukan sendiri?</h4><p>Kunci utama entitas harus berupa bilangan bulat 64-bit non-negatif.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Berapa jumlah maksimum data yang dapat ditambahkan per operasi penyisipan?</h4><p>Operasi penyisipan tidak boleh melebihi ukuran 1.024 MB. Ini adalah batas yang ditetapkan oleh gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">Apakah ukuran koleksi memengaruhi performa kueri saat mencari di partisi tertentu?</h4><p>Tidak. Jika partisi untuk pencarian ditentukan, Milvus hanya akan mencari di partisi yang ditentukan.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Apakah Milvus perlu memuat seluruh koleksi ketika partisi ditentukan untuk pencarian?</h4><p>Tergantung data apa yang dibutuhkan untuk pencarian. Semua partisi yang mungkin muncul dalam hasil pencarian harus dimuat sebelum melakukan pencarian.</p>
<ul>
<li>Sebagai contoh, jika Anda hanya ingin mencari partisi tertentu, Anda tidak perlu memuat semua partisi. Panggil <code translate="no">load_partition()</code> untuk memuat partisi yang dituju <em>, lalu</em> tentukan partisi dalam pemanggilan metode <code translate="no">search()</code>.</li>
<li>Jika Anda ingin mencari semua partisi, panggil <code translate="no">load_collection()</code> untuk memuat seluruh koleksi termasuk semua partisi.</li>
<li>Jika Anda gagal memuat koleksi atau partisi tertentu sebelum melakukan pencarian, Milvus akan mengembalikan kesalahan.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Dapatkah indeks dibuat setelah memasukkan vektor?</h4><p>Ya. Jika indeks telah dibuat untuk koleksi oleh <code translate="no">create_index()</code> sebelumnya, Milvus akan secara otomatis membuat indeks untuk vektor yang disisipkan setelahnya. Namun, Milvus tidak membuat indeks sampai vektor yang baru disisipkan memenuhi seluruh ruas dan berkas indeks yang baru dibuat terpisah dari berkas indeks sebelumnya.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">Apa perbedaan antara indeks FLAT dan IVF_FLAT?</h4><p>Indeks IVF_FLAT membagi ruang vektor ke dalam kelompok daftar. Pada nilai daftar default 16.384, Milvus membandingkan jarak antara vektor target dan centroid dari semua 16.384 klaster untuk kembali menyelidiki klaster terdekat. Milvus kemudian membandingkan jarak antara vektor target dan vektor dalam cluster yang dipilih untuk mendapatkan vektor terdekat. Tidak seperti IVF_FLAT, FLAT secara langsung membandingkan jarak antara vektor target dan setiap vektor lainnya.</p>
<p>Ketika jumlah total vektor kurang lebih sama dengan nlist, hanya ada sedikit perbedaan antara IVF_FLAT dan FLAT dalam hal persyaratan perhitungan dan kinerja pencarian. Namun, ketika jumlah vektor melebihi nlist dengan faktor dua atau lebih, IVF_FLAT mulai menunjukkan keunggulan kinerja.</p>
<p>Lihat <a href="/docs/id/v2.5.x/index.md">Indeks Vektor</a> untuk informasi lebih lanjut.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Bagaimana cara Milvus mem-flash data?</h4><p>Milvus mengembalikan hasil yang sukses ketika data yang disisipkan dimasukkan ke dalam antrean pesan. Namun, data belum di-flush ke disk. Kemudian simpul data Milvus menulis data dalam antrean pesan ke penyimpanan persisten sebagai log tambahan. Jika <code translate="no">flush()</code> dipanggil, simpul data dipaksa untuk menulis semua data dalam antrean pesan ke penyimpanan persisten dengan segera.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Apa yang dimaksud dengan normalisasi? Mengapa normalisasi dibutuhkan?</h4><p>Normalisasi mengacu pada proses mengubah sebuah vektor sehingga normanya sama dengan 1. Jika inner product digunakan untuk menghitung kesamaan vektor, vektor harus dinormalisasi. Setelah normalisasi, hasil kali dalam sama dengan kemiripan kosinus.</p>
<p>Lihat <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> untuk informasi lebih lanjut.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Mengapa jarak Euclidean (L2) dan inner product (IP) memberikan hasil yang berbeda?</h4><p>Untuk vektor yang dinormalisasi, jarak Euclidean (L2) secara matematis setara dengan inner product (IP). Jika metrik kemiripan ini memberikan hasil yang berbeda, periksa apakah vektor Anda dinormalisasi</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Apakah ada batasan jumlah total koleksi dan partisi di Milvus?</h4><p>Ya, Anda dapat membuat hingga 65.535 koleksi dalam sebuah instans Milvus. Ketika menghitung jumlah koleksi yang ada, Milvus menghitung semua koleksi dengan pecahan dan partisi di dalamnya.</p>
<p>Sebagai contoh, anggaplah Anda telah membuat 100 koleksi, dengan 2 pecahan dan 4 partisi di 60 koleksi dan 1 pecahan dan 12 partisi di 40 koleksi lainnya. Jumlah koleksi saat ini dapat dihitung sebagai:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Mengapa saya mendapatkan lebih sedikit dari k vektor ketika mencari vektor <code translate="no">topk</code>?</h4><p>Di antara indeks-indeks yang didukung Milvus, IVF_FLAT dan IVF_SQ8 mengimplementasikan metode pengelompokan k-means. Sebuah ruang data dibagi menjadi beberapa cluster <code translate="no">nlist</code> dan vektor yang dimasukkan didistribusikan ke cluster-cluster ini. Milvus kemudian memilih <code translate="no">nprobe</code> cluster terdekat dan membandingkan jarak antara vektor target dan semua vektor dalam cluster yang dipilih untuk mengembalikan hasil akhir.</p>
<p>Jika <code translate="no">nlist</code> dan <code translate="no">topk</code> besar dan nprobe kecil, jumlah vektor dalam klaster nprobe mungkin kurang dari <code translate="no">k</code>. Oleh karena itu, ketika Anda mencari <code translate="no">topk</code> vektor terdekat, jumlah vektor yang dikembalikan kurang dari <code translate="no">k</code>.</p>
<p>Untuk menghindari hal ini, coba atur <code translate="no">nprobe</code> lebih besar dan <code translate="no">nlist</code> dan <code translate="no">k</code> lebih kecil.</p>
<p>Lihat <a href="/docs/id/v2.5.x/index.md">Indeks Vektor</a> untuk informasi lebih lanjut.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Berapa dimensi vektor maksimum yang didukung oleh Milvus?</h4><p>Milvus dapat mengelola vektor hingga 32.768 dimensi secara default. Anda dapat meningkatkan nilai <code translate="no">Proxy.maxDimension</code> untuk memungkinkan vektor dengan dimensi yang lebih besar.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Apakah Milvus mendukung CPU Apple M1?</h4><p>Rilis Milvus saat ini tidak mendukung Apple M1 CPU secara langsung. Setelah Milvus 2.3, Milvus menyediakan image Docker untuk arsitektur ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Tipe data apa yang didukung Milvus pada bidang kunci utama?</h4><p>Pada rilis saat ini, Milvus mendukung INT64 dan string.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Apakah Milvus dapat diskalakan?</h4><p>Ya. Anda dapat menggunakan cluster Milvus dengan banyak node melalui Helm Chart di Kubernetes. Lihat <a href="/docs/id/v2.5.x/scaleout.md">Panduan Skala</a> untuk instruksi lebih lanjut.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Apa yang dimaksud dengan growing segment dan sealed segment?</h4><p>Ketika permintaan pencarian datang, Milvus mencari data tambahan dan data historis. Data tambahan adalah pembaruan terkini, yang disimpan di segmen yang berkembang, yang disangga dalam memori sebelum mencapai ambang batas untuk dipertahankan dalam penyimpanan objek dan indeks yang lebih efisien dibuat untuknya, sedangkan data historis adalah pembaruan beberapa waktu yang lalu. Data tersebut berada dalam segmen tertutup yang telah disimpan dalam penyimpanan objek. Data tambahan dan data historis bersama-sama membentuk keseluruhan kumpulan data untuk pencarian. Desain ini membuat data apa pun yang dimasukkan ke Milvus dapat langsung dicari. Untuk Milvus Distributed, ada faktor yang lebih kompleks yang menentukan kapan sebuah record yang baru saja dimasukkan dapat muncul di hasil pencarian. Pelajari lebih lanjut mengenai hal tersebut di <a href="https://milvus.io/docs/consistency.md">tingkat konsistensi</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Apakah Milvus tersedia untuk pencarian secara bersamaan?</h4><p>Ya. Untuk kueri pada koleksi yang sama, Milvus secara bersamaan mencari data tambahan dan data historis. Namun, pencarian pada koleksi yang berbeda dilakukan secara berurutan. Meskipun data historis dapat berupa kumpulan data yang sangat besar, pencarian pada data historis relatif lebih memakan waktu dan pada dasarnya dilakukan secara seri.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Mengapa data di MinIO tetap ada setelah koleksi yang bersangkutan dihapus?</h4><p>Data di MinIO dirancang untuk tetap ada selama jangka waktu tertentu untuk kenyamanan pengembalian data.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Apakah Milvus mendukung mesin pesan selain Pulsar?</h4><p>Ya. Kafka didukung di Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">Apa perbedaan antara pencarian dan kueri?</h4><p>Di Milvus, pencarian kemiripan vektor mengambil vektor berdasarkan perhitungan kemiripan dan akselerasi indeks vektor. Tidak seperti pencarian kemiripan vektor, kueri vektor mengambil vektor melalui pemfilteran skalar berdasarkan ekspresi boolean. Ekspresi boolean memfilter bidang skalar atau bidang kunci utama, dan mengambil semua hasil yang cocok dengan filter. Dalam kueri, tidak ada metrik kemiripan maupun indeks vektor yang terlibat.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Mengapa nilai vektor float memiliki ketepatan 7 digit desimal di Milvus?</h4><p>Milvus mendukung penyimpanan vektor sebagai larik Float32. Nilai Float32 memiliki ketelitian 7 digit desimal. Bahkan dengan nilai Float64, seperti 1.3476964684980388, Milvus menyimpannya sebagai 1.347696. Oleh karena itu, ketika Anda mengambil vektor seperti itu dari Milvus, ketepatan nilai Float64 akan hilang.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Bagaimana Milvus menangani tipe data vektor dan ketepatannya?</h4><p>Milvus mendukung tipe vektor Biner, Float32, Float16, dan BFloat16.</p>
<ul>
<li>Vektor biner: Menyimpan data biner sebagai urutan 0 dan 1, yang digunakan dalam pemrosesan gambar dan pengambilan informasi.</li>
<li>Vektor Float32: Penyimpanan default dengan presisi sekitar 7 digit desimal. Bahkan nilai Float64 pun disimpan dengan presisi Float32, yang menyebabkan potensi kehilangan presisi pada saat pengambilan.</li>
<li>Vektor Float16 dan BFloat16: Menawarkan pengurangan presisi dan penggunaan memori. Float16 cocok untuk aplikasi dengan bandwidth dan penyimpanan terbatas, sedangkan BFloat16 menyeimbangkan jangkauan dan efisiensi, biasanya digunakan dalam deep learning untuk mengurangi kebutuhan komputasi tanpa memengaruhi akurasi secara signifikan.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Apakah Milvus mendukung penentuan nilai default untuk bidang skalar atau vektor?</h4><p>Saat ini, Milvus 2.4.x tidak mendukung penentuan nilai default untuk bidang skalar atau vektor. Fitur ini direncanakan untuk rilis mendatang.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">Apakah ruang penyimpanan akan langsung tersedia setelah penghapusan data di Milvus?</h4><p>Tidak, ruang penyimpanan tidak akan langsung dilepaskan ketika Anda menghapus data di Milvus. Meskipun menghapus data menandai entitas sebagai "dihapus secara logis", ruang penyimpanan yang sebenarnya mungkin tidak langsung kosong. Inilah alasannya:</p>
<ul>
<li><strong>Pemadatan</strong>: Milvus secara otomatis memadatkan data di latar belakang. Proses ini menggabungkan segmen data yang lebih kecil menjadi lebih besar dan menghapus data yang dihapus secara logis (entitas yang ditandai untuk dihapus) atau data yang telah melampaui Time-To-Live (TTL). Namun, pemadatan menciptakan segmen baru sekaligus menandai segmen lama sebagai "Dibuang".</li>
<li><strong>Pengumpulan Sampah</strong>: Proses terpisah yang disebut Garbage Collection (GC) secara berkala menghapus segmen "Dropped" ini, membebaskan ruang penyimpanan yang mereka tempati. Hal ini memastikan penggunaan penyimpanan yang efisien, tetapi dapat menimbulkan sedikit penundaan antara penghapusan dan reklamasi ruang.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">Dapatkah saya melihat data yang disisipkan, dihapus, atau disisipkan segera setelah operasi tanpa menunggu flush?</h4><p>Ya, di Milvus, visibilitas data tidak secara langsung terkait dengan operasi flush karena arsitektur pemilahan komputasi penyimpanannya. Anda dapat mengelola keterbacaan data menggunakan tingkat konsistensi.</p>
<p>Ketika memilih tingkat konsistensi, pertimbangkan trade-off antara konsistensi dan kinerja. Untuk operasi yang membutuhkan visibilitas langsung, gunakan tingkat konsistensi "Kuat". Untuk penulisan yang lebih cepat, prioritaskan konsistensi yang lebih lemah (data mungkin tidak langsung terlihat). Untuk informasi lebih lanjut, lihat <a href="/docs/id/v2.5.x/consistency.md">Konsistensi</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">Setelah mengaktifkan fitur kunci partisi, berapa nilai default dari <code translate="no">num_partitions</code> di Milvus, dan mengapa?</h4><p>Ketika fitur kunci partisi diaktifkan, nilai default dari <code translate="no">num_partitions</code> di Milvus diatur ke <code translate="no">16</code>. Nilai default ini dipilih karena alasan stabilitas dan kinerja. Anda dapat menyesuaikan nilai <code translate="no">num_partitions</code> sesuai kebutuhan dengan menentukannya di fungsi <code translate="no">create_collection</code>.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">Apakah ada batas panjang maksimum untuk ekspresi pemfilteran skalar?</h4><p>Ya, panjang maksimum ekspresi pemfilteran skalar dibatasi oleh batas transfer RPC, yang ditentukan dalam file konfigurasi <code translate="no">milvus.yaml</code>. Secara khusus, batas tersebut ditetapkan oleh parameter <code translate="no">serverMaxRecvSize</code> di bawah bagian proxy:</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Secara default, ukuran maksimum setiap permintaan RPC adalah 64MB. Oleh karena itu, panjang ekspresi pemfilteran harus kurang dari batas ini untuk memastikan pemrosesan yang berhasil.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">Saat melakukan pencarian vektor massal, berapa banyak vektor yang dapat ditentukan sekaligus? Apakah ada batasnya?</h4><p>Ya, jumlah vektor yang dapat ditentukan dalam pencarian vektor massal dibatasi oleh ukuran transfer RPC, seperti yang ditentukan dalam file konfigurasi <code translate="no">milvus.yaml</code>. Batas ini ditentukan oleh parameter <code translate="no">serverMaxRecvSize</code> di bawah bagian proxy:</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Secara default, ukuran maksimum setiap permintaan RPC adalah 64MB. Oleh karena itu, ukuran total vektor input, termasuk data dimensi dan metadata, harus kurang dari batas ini untuk memastikan eksekusi yang sukses.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Bagaimana cara mendapatkan semua nilai unik dari bidang skalar yang diberikan dari sebuah koleksi？</h4><p>Saat ini, tidak ada metode langsung untuk mencapai hal ini. Sebagai solusinya, kami sarankan untuk menggunakan query_iterator untuk mengambil semua nilai dari suatu field tertentu, lalu melakukan deduplikasi secara manual. Kami berencana untuk menambahkan dukungan langsung untuk fitur ini di Milvus 2.6. Contoh penggunaan query_iterator:</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column </span>
<button class="copy-code-btn"></button></code></pre>

<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">Apa saja batasan-batasan dalam menggunakan field dinamis? Sebagai contoh, apakah ada batasan ukuran, metode modifikasi, atau batasan pengindeksan?</h4><p>Field dinamis direpresentasikan secara internal menggunakan field JSON, dengan batas ukuran 65.536 byte. Mereka mendukung modifikasi yang dapat dilakukan, sehingga Anda dapat menambah atau memperbarui field. Namun, sejak Milvus 2.5.1, field dinamis tidak mendukung pengindeksan. Dukungan untuk menambahkan indeks untuk JSON akan diperkenalkan pada rilis mendatang.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">Apakah Milvus mendukung perubahan skema?</h4><p>Pada Milvus versi 2.5.0, perubahan skema terbatas pada modifikasi tertentu, seperti menyesuaikan properti seperti parameter <code translate="no">mmap</code>. Pengguna juga dapat memodifikasi <code translate="no">max_length</code> untuk field varchar dan <code translate="no">max_capacity</code> untuk field array. Namun, kemampuan untuk menambah atau menghapus field dalam skema direncanakan untuk rilis mendatang, untuk meningkatkan fleksibilitas manajemen skema dalam Milvus.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">Apakah memodifikasi max_length untuk VarChar memerlukan reorganisasi data?</h4><p>Tidak, memodifikasi <code translate="no">max_length</code> untuk field VarChar tidak memerlukan reorganisasi data, seperti pemadatan atau reorganisasi. Penyesuaian ini terutama memperbarui kriteria validasi untuk setiap data baru yang dimasukkan ke dalam bidang, sehingga data yang sudah ada tidak terpengaruh. Akibatnya, perubahan ini dianggap ringan dan tidak membebankan biaya tambahan yang signifikan pada sistem.</p>
<h4 id="Still-have-questions" class="common-anchor-header">Masih memiliki pertanyaan?</h4><p>Tentu saja bisa:</p>
<ul>
<li>Lihat <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> di GitHub. Anda dipersilakan untuk mengajukan pertanyaan, berbagi ide, dan membantu orang lain.</li>
<li>Bergabunglah dengan <a href="https://slack.milvus.io/">komunitas Slack</a> kami untuk mendapatkan dukungan dan terlibat dengan komunitas sumber terbuka kami.</li>
</ul>
