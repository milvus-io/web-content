---
id: replica.md
summary: Узнайте о репликации in-memory в Milvus.
title: Репликация в памяти
---
<h1 id="In-Memory-Replica" class="common-anchor-header">Репликация в памяти<button data-href="#In-Memory-Replica" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>В этой теме описывается механизм реплик в памяти (репликаций) в Milvus, который позволяет реплицировать несколько сегментов в рабочей памяти для повышения производительности и доступности.</p>
<p>Информацию о том, как настроить реплики in-memory, см. в разделе <a href="/docs/ru/configure_querynode.md#queryNodereplicas">Конфигурации, связанные с узлами запросов</a>.</p>
<h2 id="Overview" class="common-anchor-header">Обзор<button data-href="#Overview" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.5.x/assets/replica_availability.jpg" alt="Replica_Availiability" class="doc-image" id="replica_availiability" />
   </span> <span class="img-wrapper"> <span>Доступность_реплики</span> </span></p>
<p>С помощью реплик in-memory Milvus может загружать один и тот же сегмент на несколько узлов запросов. Если один узел запроса вышел из строя или занят текущим поисковым запросом, когда приходит другой, система может отправить новые запросы на незанятый узел запроса, на котором есть репликация того же сегмента.</p>
<h3 id="Performance" class="common-anchor-header">Производительность</h3><p>Реплики в памяти позволяют задействовать дополнительные ресурсы процессора и памяти. Это очень полезно, если у вас относительно небольшой набор данных, но вы хотите увеличить пропускную способность чтения за счет дополнительных аппаратных ресурсов. Общая производительность QPS (запрос в секунду) и пропускная способность могут быть значительно улучшены.</p>
<h3 id="Availability" class="common-anchor-header">Доступность</h3><p>Реплики в памяти помогают Milvus быстрее восстанавливаться в случае сбоя узла запроса. Когда узел запроса выходит из строя, сегмент не нужно перезагружать на другой узел запроса. Вместо этого поисковый запрос может быть немедленно отправлен на новый узел запроса без необходимости повторной загрузки данных. При одновременном обслуживании нескольких копий сегментов система становится более устойчивой к сбоям.</p>
<h2 id="Key-Concepts" class="common-anchor-header">Ключевые понятия<button data-href="#Key-Concepts" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Реплики in-memory организованы в виде групп реплик. Каждая группа реплик содержит <a href="https://milvus.io/docs/v2.1.x/glossary.md#Sharding">черепные</a> реплики. Каждая реплика шарда имеет потоковую реплику и историческую реплику, которые соответствуют растущим и закрытым <a href="https://milvus.io/docs/v2.1.x/glossary.md#Segment">сегментам</a> в шарде (т. е. каналу DML).</p>
<p>
  
   <span class="img-wrapper"> <img translate="no" src="/docs/v2.5.x/assets/replica_group.png" alt="An illustration of how in-memory replica works" class="doc-image" id="an-illustration-of-how-in-memory-replica-works" />
   </span> <span class="img-wrapper"> <span>Иллюстрация того, как работает реплика in-memory</span> </span></p>
<h3 id="Replica-group" class="common-anchor-header">Группа реплик</h3><p>Группа реплик состоит из нескольких <a href="https://milvus.io/docs/v2.1.x/four_layers.md#Query-node">узлов запросов</a>, которые отвечают за работу с историческими данными и репликами.</p>
<h3 id="Shard-replica" class="common-anchor-header">Осколочная реплика</h3><p>Осколочная реплика состоит из потоковой и исторической реплик, принадлежащих одному <a href="https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md#Shard">осколку</a>. Количество реплик шардов в группе реплик определяется количеством шардов в указанной коллекции.</p>
<h3 id="Streaming-replica" class="common-anchor-header">Потоковая реплика</h3><p>Потоковая реплика содержит все <a href="https://milvus.io/docs/v2.1.x/glossary.md#Segment">растущие сегменты</a> из одного канала DML. Технически говоря, потоковая реплика должна обслуживаться только одним узлом запроса в одной реплике.</p>
<h3 id="Historical-replica" class="common-anchor-header">Историческая реплика</h3><p>Историческая реплика содержит все запечатанные сегменты из одного и того же канала DML. Запечатанные сегменты одной исторической реплики могут быть распределены по нескольким узлам запросов в рамках одной группы реплик.</p>
<h3 id="Shard-leader" class="common-anchor-header">Лидер осколка</h3><p>Лидер осколка - это узел запроса, обслуживающий потоковую реплику в реплике осколка.</p>
<h2 id="Design-Details" class="common-anchor-header">Детали дизайна<button data-href="#Design-Details" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><h3 id="Balance" class="common-anchor-header">Баланс</h3><p>Новый сегмент, который необходимо загрузить, будет распределен по нескольким различным узлам запросов. Поисковый запрос может быть обработан, как только хотя бы одна реплика будет успешно загружена.</p>
<h3 id="Search" class="common-anchor-header">Поиск</h3><h4 id="Cache" class="common-anchor-header">Кэш</h4><p>Прокси-сервер поддерживает кэш, сопоставляющий сегменты с узлами запроса, и периодически обновляет его. Когда прокси получает запрос, Milvus получает из кэша все сегменты, которые нужно найти, и пытается равномерно распределить их по узлам запроса.</p>
<p>Для растущих сегментов прокси также поддерживает кэш "канал - узел запроса" и отправляет запросы на соответствующие узлы запроса.</p>
<h4 id="Failover" class="common-anchor-header">Отказоустойчивость</h4><p>Кэши на прокси не всегда актуальны. Некоторые сегменты или каналы могут быть перемещены на другие узлы запроса в момент поступления запроса. В этом случае прокси получит ответ об ошибке, обновит кэш и попытается назначить его другому узлу запроса.</p>
<p>Сегмент будет проигнорирован, если прокси не сможет найти его после обновления кэша. Это может произойти, если сегмент был уплотнен.</p>
<p>Если кэш не точен, прокси может пропустить некоторые сегменты. Узлы запроса с каналами DML (растущие сегменты) возвращают ответы на поиск вместе со списком надежных сегментов, с которыми прокси может сравнить и обновить кэш.</p>
<h3 id="Enhancement" class="common-anchor-header">Усовершенствование</h3><p>Прокси не может распределять поисковые запросы между узлами запросов абсолютно одинаково, и узлы запросов могут иметь разные ресурсы для обслуживания поисковых запросов. Чтобы избежать распределения ресурсов по принципу "длинного хвоста", прокси назначает активные сегменты на других узлах запроса незанятому узлу запроса, который также имеет эти сегменты.</p>
