---
id: index.md
related_key: index
summary: Индексный механизм в Милвусе.
title: Индекс в памяти
---

<h1 id="In-memory-Index" class="common-anchor-header">Индекс в памяти<button data-href="#In-memory-Index" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><p>В этой теме перечислены различные типы индексов in-memory, которые поддерживает Milvus, сценарии, для которых каждый из них подходит лучше всего, и параметры, которые пользователи могут настроить для достижения лучшей производительности поиска. Об индексах на диске см. в разделе <strong><a href="/docs/ru/v2.5.x/disk_index.md">Индекс на диске</a></strong>.</p>
<p>Индексирование - это процесс эффективной организации данных, и оно играет важную роль в обеспечении полезности поиска по сходству, значительно ускоряя трудоемкие запросы к большим наборам данных.</p>
<p>Чтобы повысить производительность запросов, можно <a href="/docs/ru/v2.5.x/index-vector-fields.md">указать тип индекса</a> для каждого векторного поля.</p>
<div class="alert note">
В настоящее время векторное поле поддерживает только один тип индекса. При переключении типа индекса Milvus автоматически удаляет старый индекс.</div>
<h2 id="ANNS-vector-indexes" class="common-anchor-header">Векторные индексы ANNS<button data-href="#ANNS-vector-indexes" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Большинство типов векторных индексов, поддерживаемых Milvus, используют алгоритмы приближенного поиска ближайших соседей (ANNS). По сравнению с точным поиском, который обычно занимает много времени, основная идея ANNS заключается не в возвращении наиболее точного результата, а только в поиске соседей цели. ANNS повышает эффективность поиска, жертвуя точностью в приемлемом диапазоне.</p>
<p>В соответствии с методами реализации, векторный индекс ANNS можно разделить на четыре типа: основанные на деревьях, основанные на графах, основанные на хэшах и основанные на квантовании.</p>
<h2 id="Indexes-supported-in-Milvus" class="common-anchor-header">Индексы, поддерживаемые в Milvus<button data-href="#Indexes-supported-in-Milvus" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Milvus поддерживает различные типы индексов, которые делятся по типу векторных вложений, с которыми они работают: <strong>вложения с плавающей точкой</strong> (также известные как векторы с плавающей точкой или плотные векторы), <strong>двоичные вложения</strong> (также известные как двоичные векторы) и <strong>разреженные вложения</strong> (также известные как разреженные векторы).</p>
<div class="filter">
 <a href="#floating">Встраивания с плавающей точкой</a> <a href="#binary">Двоичные встраивания</a> <a href="#sparse">Разреженные встраивания</a></div>
<div class="filter-floating">
<h3 id="Indexes-for-floating-point-embeddings" class="common-anchor-header">Индексы для вкраплений с плавающей точкой</h3><p>Для 128-мерных вкраплений (векторов) с плавающей точкой объем памяти, который они занимают, составляет 128 * размер float = 512 байт. А <a href="/docs/ru/v2.5.x/metric.md">метрики расстояния</a>, используемые для вкраплений с плавающей точкой, - это евклидово расстояние (<code translate="no">L2</code>) и внутреннее произведение (<code translate="no">IP</code>).</p>
<p>К таким типам индексов относятся <code translate="no">FLAT</code>, <code translate="no">IVF_FLAT</code>, <code translate="no">IVF_PQ</code>, <code translate="no">IVF_SQ8</code>, <code translate="no">HNSW</code>, <code translate="no">HNSW_SQ</code>, <code translate="no">HNSW_PQ</code>, <code translate="no">HNSW_PRQ</code>, и <code translate="no">SCANN</code> для поиска ANN на базе процессора.</p>
</div>
<div class="filter-binary">
<h3 id="Indexes-for-binary-embeddings" class="common-anchor-header">Индексы для бинарных вкраплений</h3><p>Для 128-мерных бинарных вкраплений объем памяти, который они занимают, составляет 128 / 8 = 16 байт. В качестве метрики расстояния для бинарных вкраплений используются <code translate="no">JACCARD</code> и <code translate="no">HAMMING</code>.</p>
<p>К этому типу индексов относятся <code translate="no">BIN_FLAT</code> и <code translate="no">BIN_IVF_FLAT</code>.</p>
</div>
<div class="filter-sparse">
<h3 id="Indexes-for-sparse-embeddings" class="common-anchor-header">Индексы для разреженных вкраплений</h3><p>Индексы для разреженных вкраплений поддерживают только метрики <code translate="no">IP</code> и <code translate="no">BM25</code> (для полнотекстового поиска).</p>
<p>Тип индекса, поддерживаемого для разреженных вкраплений: <code translate="no">SPARSE_INVERTED_INDEX</code>.</p>
<div class="alert note">
<p>Начиная с Milvus 2.5.4 и далее, <code translate="no">SPARSE_WAND</code> устаревает. Вместо него рекомендуется использовать <code translate="no">&quot;inverted_index_algo&quot;: &quot;DAAT_WAND&quot;</code> для эквивалентности и сохранения совместимости. Для получения дополнительной информации обратитесь к разделу <a href="/docs/ru/v2.5.x/sparse_vector.md#Set-index-params-for-vector-field">"Разреженный вектор</a>".</p>
</div>
</div>
<div class="filter-floating table-wrapper">
<table id="floating">
<thead>
  <tr>
    <th>Поддерживаемый индекс</th>
    <th>Классификация</th>
    <th>Сценарий</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>ПЛОСКИЙ</td>
    <td>N/A</td>
    <td>
      <ul>
        <li>Относительно небольшой набор данных</li>
        <li>Требуется 100-процентный коэффициент отзыва</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>ЭКО_FLAT</td>
    <td>N/A</td>
    <td>
      <ul>
        <li>Высокоскоростной запрос</li>
        <li>Требуется как можно более высокая скорость запоминания</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>IVF_SQ8</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Очень высокоскоростной запрос</li>
        <li>Ограниченные ресурсы памяти</li>
        <li>Допускает незначительный компромисс в скорости запоминания</li>
      </ul>
    </td>
  </tr>  
  <tr>
    <td>IVF_PQ</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Высокоскоростной запрос</li>
        <li>Ограниченные ресурсы памяти</li>
        <li>Допускает незначительный компромисс в скорости запоминания</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>HNSW</td>
    <td>Индекс на основе графов</td>
    <td>
      <ul>
        <li>Очень высокоскоростной запрос</li>
        <li>Требуется как можно более высокая скорость запоминания</li>
        <li>Большие ресурсы памяти</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>HNSW_SQ</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Очень высокоскоростной запрос</li>
        <li>Ограниченные ресурсы памяти</li>
        <li>Допускает незначительный компромисс в скорости запоминания</li>
      </ul>
    </td>
  </tr>
    <tr>
    <td>HNSW_PQ</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Среднескоростной запрос</li>
        <li>Очень ограниченные ресурсы памяти</li>
        <li>Допускает незначительный компромисс в скорости запоминания</li>
      </ul>
    </td>
  </tr>
    </tr>
    <tr>
    <td>HNSW_PRQ</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Запрос со средней скоростью</li>
        <li>Очень ограниченные ресурсы памяти</li>
        <li>Допускает незначительный компромисс в скорости запоминания</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>SCANN</td>
    <td>Индекс на основе квантования</td>
    <td>
      <ul>
        <li>Очень высокоскоростной запрос</li>
        <li>Требуется как можно более высокая скорость запоминания</li>
        <li>Большие ресурсы памяти</li>
      </ul>
    </td>
  </tr>
</tbody>
</table>
</div>
<div class="filter-binary table-wrapper">
<table id="binary">
<thead>
  <tr>
    <th>Поддерживаемый индекс</th>
    <th>Классификация</th>
    <th>Сценарий</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>BIN_FLAT</td>
    <td>Индекс на основе квантования</td>
    <td><ul>
      <li>Зависит от относительно небольших наборов данных.</li>
      <li>Требуется идеальная точность.</li>
      <li>Сжатие не применяется.</li>
      <li>Гарантирует точные результаты поиска.</li>
    </ul></td>
  </tr>
  <tr>
    <td>BIN_IVF_FLAT</td>
    <td>Индекс на основе квантования</td>
    <td><ul>
      <li>Высокоскоростной запрос</li>
      <li>Требуется как можно более высокий коэффициент отзыва</li>
    </ul></td>
  </tr>
</tbody>
</table>
</div>
<div class="filter-sparse table-wrapper">
<table id="sparse">
<thead>
  <tr>
    <th>Поддерживаемый индекс</th>
    <th>Классификация</th>
    <th>Сценарий</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>РАЗРЕЖЕННЫЙ_ИНВЕРТИРОВАННЫЙ_ИНДЕКС</td>
    <td>Инвертированный индекс</td>
    <td><ul>
      <li>Зависит от относительно небольших наборов данных.</li>
      <li>Требуется 100-процентный коэффициент отзыва.</li>
    </ul></td>
  </tr>
</tbody>
</table>
</div>
<div class="filter-floating">
<h3 id="FLAT" class="common-anchor-header">FLAT</h3><p>Для приложений поиска векторного сходства, требующих идеальной точности и зависящих от относительно небольших (миллионных) наборов данных, индекс FLAT является хорошим выбором. FLAT не сжимает векторы и является единственным индексом, который может гарантировать точные результаты поиска. Результаты, полученные с помощью FLAT, можно также использовать для сравнения с результатами, полученными с помощью других индексов, которые имеют менее чем 100-процентный отзыв.</p>
<p>Точность FLAT объясняется тем, что он использует исчерпывающий подход к поиску, то есть для каждого запроса целевой входной сигнал сравнивается с каждым набором векторов в наборе данных. Это делает FLAT самым медленным индексом в нашем списке и плохо подходит для запросов к массивным векторным данным. Для индекса FLAT в Milvus не требуется никаких параметров, и его использование не требует дополнительного построения индекса.</p>
<ul>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">metric_type</code></td><td>[Необязательно] Выбранная метрика расстояния.</td><td>См. раздел <a href="/docs/ru/v2.5.x/metric.md">Поддерживаемые метрики</a>.</td></tr>
</tbody>
</table>
</li>
</ul>
<h3 id="IVFFLAT" class="common-anchor-header">IVF_FLAT</h3><p>IVF_FLAT делит векторные данные на кластеры <code translate="no">nlist</code>, а затем сравнивает расстояния между целевым входным вектором и центром каждого кластера. В зависимости от количества кластеров, к которым система настроена на запрос (<code translate="no">nprobe</code>), результаты поиска сходства возвращаются на основе сравнений между целевым входным вектором и векторами только в наиболее похожих кластерах, что значительно сокращает время запроса.</p>
<p>Настраивая <code translate="no">nprobe</code>, можно найти идеальный баланс между точностью и скоростью для конкретного сценария. Результаты <a href="https://zilliz.com/blog/Accelerating-Similarity-Search-on-Really-Big-Data-with-Vector-Indexing">тестирования производительности IVF_FLAT</a> показывают, что время выполнения запроса резко возрастает при увеличении как количества векторов целевого входа (<code translate="no">nq</code>), так и количества кластеров для поиска (<code translate="no">nprobe</code>).</p>
<p>IVF_FLAT является самым базовым индексом ЭКО, и закодированные данные, хранящиеся в каждом блоке, соответствуют исходным данным.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nlist</code></td><td>Количество единиц кластера</td><td>[1, 65536]</td><td>128</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<ul>
<li><p>Общий поиск</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nprobe</code></td><td>Количество единиц для запроса</td><td>[1, nlist]</td><td>8</td></tr>
</tbody>
</table>
</li>
<li><p>Поиск диапазона</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">max_empty_result_buckets</code></td><td>Максимальное количество ведер, не дающих результатов поиска.<br/>Это параметр поиска по диапазону, который прекращает процесс поиска, если количество последовательных пустых ведер достигает указанного значения.<br/>Увеличение этого значения может улучшить скорость запоминания за счет увеличения времени поиска.</td><td>[1, 65535]</td><td>2</td></tr>
</tbody>
</table>
</li>
</ul></li>
</ul>
<h3 id="IVFSQ8" class="common-anchor-header">IVF_SQ8</h3><p>IVF_FLAT не выполняет никакого сжатия, поэтому создаваемые им индексные файлы имеют примерно тот же размер, что и исходные, необработанные векторные данные без индексации. Например, если исходный набор данных 1B SIFT имеет размер 476 ГБ, то индексные файлы IVF_FLAT будут немного меньше (~470 ГБ). Загрузка всех индексных файлов в память займет 470 ГБ.</p>
<p>Если ресурсы памяти диска, CPU или GPU ограничены, IVF_SQ8 будет лучшим вариантом, чем IVF_FLAT. Этот тип индекса может преобразовывать каждое FLOAT (4 байта) в UINT8 (1 байт), выполняя скалярное квантование (SQ). Это позволяет сократить потребление памяти на диске, CPU и GPU на 70-75 %. Для набора данных 1B SIFT индексные файлы IVF_SQ8 требуют всего 140 ГБ памяти.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nlist</code></td><td>Количество кластеров</td><td>[1, 65536]</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<ul>
<li><p>Общий поиск</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nprobe</code></td><td>Количество единиц для запроса</td><td>[1, nlist]</td><td>8</td></tr>
</tbody>
</table>
</li>
<li><p>Поиск диапазона</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">max_empty_result_buckets</code></td><td>Максимальное количество ведер, не дающих результатов поиска.<br/>Это параметр поиска по диапазону, который прекращает процесс поиска, если количество последовательных пустых ведер достигает указанного значения.<br/>Увеличение этого значения может улучшить скорость отзыва за счет увеличения времени поиска.</td><td>[1, 65535]</td><td>2</td></tr>
</tbody>
</table>
</li>
</ul></li>
</ul>
<h3 id="IVFPQ" class="common-anchor-header">IVF_PQ</h3><p><code translate="no">PQ</code> (Product Quantization) равномерно разлагает исходное высокоразмерное векторное пространство на декартово произведение <code translate="no">m</code> низкоразмерных векторных пространств, а затем квантует разложенные низкоразмерные векторные пространства. Вместо вычисления расстояний между целевым вектором и центром всех единиц, квантование по продуктам позволяет вычислять расстояния между целевым вектором и центром кластеризации каждого низкоразмерного пространства и значительно сокращает временную и пространственную сложность алгоритма.</p>
<p>IVF_PQ выполняет кластеризацию индекса ЭКО перед квантованием произведения векторов. Его индексный файл еще меньше, чем у IVF_SQ8, но это также приводит к потере точности при поиске векторов.</p>
<div class="alert note">
<p>Параметры построения индекса и параметры поиска зависят от дистрибутива Milvus. Сначала выберите свой дистрибутив Milvus.</p>
</div>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nlist</code></td><td>Количество единиц кластера</td><td>[1, 65536]</td></tr>
<tr><td><code translate="no">m</code></td><td>Количество коэффициентов квантования произведения</td><td><code translate="no">dim mod m == 0</code></td></tr>
<tr><td><code translate="no">nbits</code></td><td>[Необязательно] Количество бит, в которых хранится каждый низкоразмерный вектор.</td><td>[1, 64] (по умолчанию 8)</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<ul>
<li><p>Общий поиск</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nprobe</code></td><td>Количество единиц для запроса</td><td>[1, nlist]</td><td>8</td></tr>
</tbody>
</table>
</li>
<li><p>Поиск диапазона</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">max_empty_result_buckets</code></td><td>Максимальное количество ведер, не дающих результатов поиска.<br/>Это параметр поиска по диапазону, который прекращает процесс поиска, если количество последовательных пустых ведер достигает указанного значения.<br/>Увеличение этого значения может улучшить скорость запоминания за счет увеличения времени поиска.</td><td>[1, 65535]</td><td>2</td></tr>
</tbody>
</table>
</li>
</ul></li>
</ul>
<h3 id="SCANN" class="common-anchor-header">SCANN</h3><p>ScaNN (Scalable Nearest Neighbors) похож на IVF_PQ с точки зрения кластеризации векторов и квантования произведений. Их отличия заключаются в деталях реализации квантования произведения и использовании SIMD (Single-Instruction / Multi-data) для эффективного вычисления.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nlist</code></td><td>Количество кластеров</td><td>[1, 65536]</td></tr>
<tr><td><code translate="no">with_raw_data</code></td><td>Включать ли исходные данные в индекс</td><td><code translate="no">True</code> или <code translate="no">False</code>. По умолчанию <code translate="no">True</code>.</td></tr>
</tbody>
</table>
  <div class="alert note">
<p>В отличие от IVF_PQ, значения по умолчанию применяются к <code translate="no">m</code> и <code translate="no">nbits</code> для оптимизации производительности.</p>
  </div>
</li>
<li><p>Параметры поиска</p>
<ul>
<li><p>Общий поиск</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nprobe</code></td><td>Количество единиц для запроса</td><td>[1, nlist]</td><td></td></tr>
<tr><td><code translate="no">reorder_k</code></td><td>Количество единиц-кандидатов для запроса</td><td>[<code translate="no">top_k</code>, ∞]</td><td><code translate="no">top_k</code></td></tr>
</tbody>
</table>
</li>
<li><p>Поиск в диапазоне</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">max_empty_result_buckets</code></td><td>Максимальное количество ведер, не дающих результатов поиска.<br/>Это параметр поиска по диапазону, который прекращает процесс поиска, если количество последовательных пустых ведер достигает указанного значения.<br/>Увеличение этого значения может улучшить скорость запоминания за счет увеличения времени поиска.</td><td>[1, 65535]</td><td>2</td></tr>
</tbody>
</table>
</li>
</ul></li>
</ul>
<h3 id="HNSW" class="common-anchor-header">HNSW</h3><p>HNSW (Hierarchical Navigable Small World Graph) - это алгоритм индексирования на основе графов. Он строит многослойную навигационную структуру для изображения в соответствии с определенными правилами. В этой структуре верхние слои более разрежены и расстояния между узлами больше, а нижние слои более плотные и расстояния между узлами ближе. Поиск начинается с самого верхнего слоя, в нем находится ближайший к цели узел, а затем переходят к следующему слою, чтобы начать новый поиск. После нескольких итераций поиск быстро приближается к целевой позиции.</p>
<p>Для повышения производительности HNSW ограничивает максимальную степень узлов на каждом слое графа значением <code translate="no">M</code>. Кроме того, вы можете использовать <code translate="no">efConstruction</code> (при построении индекса) или <code translate="no">ef</code> (при поиске целей), чтобы задать диапазон поиска.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">M</code></td><td>M определяет максимальное количество исходящих соединений в графе. Большее значение M приводит к увеличению точности/времени работы при фиксированном ef/efConstruction.</td><td>[2, 2048]</td><td>Нет</td></tr>
<tr><td><code translate="no">efConstruction</code></td><td>ef_construction управляет компромиссом между скоростью поиска индекса и скоростью сборки. Увеличение параметра efConstruction может повысить качество индекса, но также имеет тенденцию к увеличению времени индексирования.</td><td>[1, int_max]</td><td>None</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">ef</code></td><td>Параметр, управляющий компромиссом между временем запроса и точностью. Более высокий <code translate="no">ef</code> приводит к более точному, но более медленному поиску.</td><td>[<code translate="no">top_k</code>, int_max]</td><td>Нет</td></tr>
</tbody>
</table>
</li>
</ul>
<h3 id="HNSWSQ" class="common-anchor-header">HNSW_SQ</h3><p>Скалярное квантование (SQ) - это техника, используемая для дискретизации данных с плавающей точкой на конечный набор значений, основанный на их величине. Например, <strong>SQ6</strong> представляет собой квантование в (2^6 = 64) дискретных значений, где каждое число с плавающей точкой кодируется 6 битами. Аналогично, <strong>SQ8</strong> квантует данные в (2^8 = 256) дискретных значений, где каждое число с плавающей точкой представлено 8 битами. Такое квантование уменьшает занимаемую память, сохраняя при этом важную структуру данных для эффективной обработки.</p>
<p>В сочетании с SQ, HNSW_SQ обеспечивает контролируемый компромисс между размером индекса и точностью, сохраняя при этом высокую производительность запросов в секунду (QPS). По сравнению со стандартным HNSW, это приводит к незначительному увеличению времени построения индекса.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">M</code></td><td>M определяет максимальное количество исходящих соединений в графе. Большее значение M приводит к увеличению точности/времени работы при фиксированном ef/efConstruction.</td><td>[2, 2048]</td><td>Нет</td></tr>
<tr><td><code translate="no">efConstruction</code></td><td>ef_construction управляет компромиссом между скоростью поиска индекса и скоростью сборки. Увеличение параметра efConstruction может повысить качество индекса, но также имеет тенденцию к увеличению времени индексирования.</td><td>[1, int_max]</td><td>None</td></tr>
<tr><td><code translate="no">sq_type</code></td><td>Тип скалярного квантователя.</td><td><code translate="no">SQ6</code>,<code translate="no">SQ8</code>, <code translate="no">BF16</code>, <code translate="no">FP16</code></td><td><code translate="no">SQ8</code></td></tr>
<tr><td><code translate="no">refine</code></td><td>Резервируются ли уточненные данные при построении индекса.</td><td><code translate="no">true</code>, <code translate="no">false</code></td><td><code translate="no">false</code></td></tr>
<tr><td><code translate="no">refine_type</code></td><td>Тип данных уточняемого индекса.</td><td><code translate="no">SQ6</code>, <code translate="no">SQ8</code>, <code translate="no">BF16</code>, <code translate="no">FP16</code>, <code translate="no">FP32</code></td><td>Нет</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">ef</code></td><td>Параметр, управляющий компромиссом между временем запроса и точностью. Более высокое значение <code translate="no">ef</code> приводит к более точному, но более медленному поиску.</td><td>[<code translate="no">top_k</code>, int_max]</td><td>Нет</td></tr>
<tr><td><code translate="no">refine_k</code></td><td>Коэффициент увеличения уточнения по сравнению с <em>k</em>.</td><td>[1, <em>float_max</em>]</td><td><code translate="no">1</code></td></tr>
</tbody>
</table>
</li>
</ul>
<h3 id="HNSWPQ" class="common-anchor-header">HNSW_PQ</h3><p>Основная идея PQ заключается в том, чтобы разбить вектор на <code translate="no">m</code> подвекторов, каждый из которых найдет <em>2^{nbits}</em> центроидов на основе kmeans, и каждый подвектор выберет ближайший центроид в качестве своего приближенного подвектора. Затем мы записываем все центроиды, поэтому каждый подвектор можно закодировать как <code translate="no">nbits</code>, а плавающий вектор длины <code translate="no">dim</code> можно закодировать как <em>m ⋅ nbits</em> бит.</p>
<p>В сочетании с PQ HNSW_PQ обеспечивает контролируемый компромисс между размером индекса и точностью, но имеет более низкое значение QPS и более высокий коэффициент отзыва, чем HNSW_SQ, при одинаковой степени сжатия. По сравнению с HNSW_SQ, на построение индекса уходит больше времени.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">M</code></td><td>M определяет максимальное количество исходящих соединений в графе. Большее значение M приводит к увеличению точности/времени работы при фиксированном ef/efConstruction.</td><td>[2, 2048]</td><td>Нет</td></tr>
<tr><td><code translate="no">efConstruction</code></td><td>ef_construction управляет компромиссом между скоростью поиска индекса и скоростью сборки. Увеличение параметра efConstruction может повысить качество индекса, но также имеет тенденцию к увеличению времени индексирования.</td><td>[1, int_max]</td><td>None</td></tr>
<tr><td><code translate="no">m</code></td><td>Количество групп субвекторов, на которые нужно разбить вектор.</td><td>[1, 65536]</td><td>32</td></tr>
<tr><td><code translate="no">nbits</code></td><td>Количество бит, на которые квантуется каждая группа субвекторов.</td><td>[1, 24]</td><td>8</td></tr>
<tr><td><code translate="no">refine</code></td><td>Резервируются ли уточненные данные при построении индекса.</td><td><code translate="no">true</code>, <code translate="no">false</code></td><td><code translate="no">false</code></td></tr>
<tr><td><code translate="no">refine_type</code></td><td>Тип данных уточненного индекса.</td><td><code translate="no">SQ6</code>, <code translate="no">SQ8</code>, <code translate="no">BF16</code>, <code translate="no">FP16</code>, <code translate="no">FP32</code></td><td>Нет</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">ef</code></td><td>Параметр, управляющий компромиссом между временем запроса и точностью. Более высокое значение <code translate="no">ef</code> приводит к более точному, но более медленному поиску.</td><td>[<code translate="no">top_k</code>, int_max]</td><td>Нет</td></tr>
<tr><td><code translate="no">refine_k</code></td><td>Коэффициент увеличения уточнения по сравнению с <em>k</em>.</td><td>[1, <em>float_max</em>]</td><td><code translate="no">1</code></td></tr>
</tbody>
</table>
</li>
</ul>
<h3 id="HNSWPRQ" class="common-anchor-header">HNSW_PRQ</h3><p>PRQ аналогичен PQ и также делит вектор на группы <code translate="no">m</code>. Каждый субвектор будет закодирован как <code translate="no">nbits</code>. После завершения pq-квантования вычисляется остаток между вектором и pq-квантованным вектором, и к остаточному вектору применяется pq-квантование. Всего будет выполнено <code translate="no">nrq</code> полных pq-квантований, поэтому плавающий вектор длины <code translate="no">dim</code> будет закодирован как <em>m ⋅ nbits ⋅ nrq</em> bits.</p>
<p>В сочетании с квантователем остаточного продукта (PRQ) HNSW_PRQ обеспечивает еще более высокий контролируемый компромисс между размером индекса и точностью. Он имеет почти эквивалентное значение QPS и более высокий коэффициент запоминания, чем HNSW_PQ, при той же степени сжатия. По сравнению с HNSW_PQ время построения индекса может увеличиться в несколько раз.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">M</code></td><td>M определяет максимальное количество исходящих соединений в графе. Большее значение M приводит к увеличению точности/времени работы при фиксированном ef/efConstruction.</td><td>[2, 2048]</td><td>Нет</td></tr>
<tr><td><code translate="no">efConstruction</code></td><td>ef_construction управляет компромиссом между скоростью поиска индекса и скоростью сборки. Увеличение параметра efConstruction может повысить качество индекса, но также имеет тенденцию к увеличению времени индексирования.</td><td>[1, int_max]</td><td>None</td></tr>
<tr><td><code translate="no">m</code></td><td>Количество групп субвекторов, на которые нужно разбить вектор.</td><td>[1, 65536]</td><td>32</td></tr>
<tr><td><code translate="no">nbits</code></td><td>Количество бит, на которые квантуется каждая группа субвекторов.</td><td>[1, 24]</td><td>8</td></tr>
<tr><td><code translate="no">nrq</code></td><td>Количество остаточных субквантователей.</td><td>[1, 16]</td><td>2</td></tr>
<tr><td><code translate="no">refine</code></td><td>Резервируются ли уточненные данные при построении индекса.</td><td><code translate="no">true</code>, <code translate="no">false</code></td><td><code translate="no">false</code></td></tr>
<tr><td><code translate="no">refine_type</code></td><td>Тип данных уточняемого индекса.</td><td><code translate="no">SQ6</code>, <code translate="no">SQ8</code>, <code translate="no">BF16</code>, <code translate="no">FP16</code>, <code translate="no">FP32</code></td><td>Нет</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">ef</code></td><td>Параметр, определяющий компромисс между временем запроса и точностью. Более высокий <code translate="no">ef</code> приводит к более точному, но более медленному поиску.</td><td>[<code translate="no">top_k</code>, int_max]</td><td>Нет</td></tr>
<tr><td><code translate="no">refine_k</code></td><td>Коэффициент увеличения уточнения по сравнению с <em>k</em>.</td><td>[1, <em>float_max</em>]</td><td><code translate="no">1</code></td></tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="filter-binary">
<h3 id="BINFLAT" class="common-anchor-header">BIN_FLAT</h3><p>Этот индекс точно такой же, как FLAT, за исключением того, что он может использоваться только для бинарных вкраплений.</p>
<p>Для приложений поиска векторного сходства, требующих идеальной точности и зависящих от относительно небольших (миллионных) наборов данных, индекс BIN_FLAT является хорошим выбором. BIN_FLAT не сжимает векторы и является единственным индексом, который может гарантировать точные результаты поиска. Результаты BIN_FLAT также можно использовать в качестве точки сравнения для результатов, выдаваемых другими индексами, которые имеют менее чем 100 % отзыв.</p>
<p>Точность BIN_FLAT объясняется тем, что он использует исчерпывающий подход к поиску, то есть для каждого запроса целевой входной сигнал сравнивается с векторами в наборе данных. Это делает BIN_FLAT самым медленным индексом в нашем списке и плохо подходит для запросов к массивным векторным данным. В Milvus нет параметров для индекса BIN_FLAT, и его использование не требует подготовки данных или дополнительного хранения.</p>
<ul>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">metric_type</code></td><td>[Необязательно] Выбранная метрика расстояния.</td><td>См. раздел <a href="/docs/ru/v2.5.x/metric.md">Поддерживаемые метрики</a>.</td></tr>
</tbody>
</table>
</li>
</ul>
<h3 id="BINIVFFLAT" class="common-anchor-header">BIN_IVF_FLAT</h3><p>Этот индекс точно такой же, как IVF_FLAT, за исключением того, что он может использоваться только для бинарных вкраплений.</p>
<p>BIN_IVF_FLAT делит векторные данные на кластеры <code translate="no">nlist</code>, а затем сравнивает расстояния между целевым входным вектором и центром каждого кластера. В зависимости от количества кластеров, к которым система настроена на запрос (<code translate="no">nprobe</code>), результаты поиска сходства возвращаются на основе сравнений между целевым входным вектором и векторами только в наиболее похожих кластерах, что значительно сокращает время запроса.</p>
<p>Настраивая <code translate="no">nprobe</code>, можно найти идеальный баланс между точностью и скоростью для конкретного сценария. Время выполнения запроса резко возрастает при увеличении как количества векторов целевого входа (<code translate="no">nq</code>), так и количества кластеров для поиска (<code translate="no">nprobe</code>).</p>
<p>BIN_IVF_FLAT - это самый базовый индекс BIN_IVF, и закодированные данные, хранящиеся в каждом блоке, соответствуют исходным данным.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nlist</code></td><td>Количество единиц кластера</td><td>[1, 65536]</td></tr>
</tbody>
</table>
</li>
<li><p>Параметры поиска</p>
<ul>
<li><p>Общий поиск</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">nprobe</code></td><td>Количество единиц для запроса</td><td>[1, nlist]</td><td>8</td></tr>
</tbody>
</table>
</li>
<li><p>Поиск диапазона</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th><th>Значение по умолчанию</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">max_empty_result_buckets</code></td><td>Максимальное количество ведер, не дающих результатов поиска.<br/>Это параметр поиска по диапазону, который прекращает процесс поиска, если количество последовательных пустых ведер достигает указанного значения.<br/>Увеличение этого значения может улучшить скорость отзыва за счет увеличения времени поиска.</td><td>[1, 65535]</td><td>2</td></tr>
</tbody>
</table>
</li>
</ul></li>
</ul>
</div>
<div class="filter-sparse">
<h3 id="SPARSEINVERTEDINDEX" class="common-anchor-header">SPARSE_INVERTED_INDEX</h3><p>В каждом измерении хранится список векторов, имеющих ненулевое значение в этом измерении. Во время поиска Milvus итерируется по каждому измерению вектора запроса и вычисляет оценки для векторов, имеющих ненулевые значения в этих измерениях.</p>
<ul>
<li><p>Параметры построения индекса</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">inverted_index_algo</code></td><td>Алгоритм, используемый для построения и запроса индекса. Подробнее см. в разделе <a href="/docs/ru/v2.5.x/sparse_vector.md#Set-index-params-for-vector-field">"Разреженный вектор</a>".</td><td><code translate="no">DAAT_MAXSCORE</code> (по умолчанию), <code translate="no">DAAT_WAND</code>, <code translate="no">TAAT_NAIVE</code></td></tr>
<tr><td><code translate="no">bm25_k1</code></td><td>Управляет насыщенностью частот терминов. Более высокие значения увеличивают важность частот терминов при ранжировании документов.</td><td>[1.2, 2.0]</td></tr>
<tr><td><code translate="no">bm25_b</code></td><td>Управляет степенью нормализации длины документа. По умолчанию 0,75.</td><td>[0, 1]</td></tr>
</tbody>
</table>
  <div class="alert note">
<p>Параметр <code translate="no">drop_ratio_build</code> устарел с версии Milvus v2.5.4. Он все еще может быть принят во время построения индекса, но больше не будет иметь фактического влияния на индекс.</p>
  </div>
</li>
<li><p>Параметры поиска</p>
<table>
<thead>
<tr><th>Параметр</th><th>Описание</th><th>Диапазон</th></tr>
</thead>
<tbody>
<tr><td><code translate="no">drop_ratio_search</code></td><td>Доля малых значений вектора, которые исключаются в процессе поиска. Этот параметр позволяет тонко настроить процесс поиска, указав долю наименьших значений в векторе запроса, которые следует игнорировать. Это помогает сбалансировать точность и производительность поиска. Чем меньше значение <code translate="no">drop_ratio_search</code>, тем меньший вклад эти малые значения вносят в итоговую оценку. Игнорирование некоторых малых значений позволяет повысить производительность поиска при минимальном влиянии на точность.</td><td>[0, 1]</td></tr>
</tbody>
</table>
</li>
</ul>
</div>
<h2 id="FAQ" class="common-anchor-header">FAQ<button data-href="#FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p><details>
<summary><font color="#4fc4f9">В чем разница между индексом FLAT и индексом IVF_FLAT?</font></summary></p>
<p>Индекс IVF_FLAT делит векторное пространство на кластеры <code translate="no">nlist</code>. Если значение <code translate="no">nlist</code> по умолчанию равно 16384, Milvus сравнивает расстояния между целевым вектором и центрами всех 16384 кластеров, чтобы получить <code translate="no">nprobe</code> ближайших кластеров. Затем Milvus сравнивает расстояния между целевым вектором и векторами в выбранных кластерах, чтобы получить ближайшие векторы. В отличие от IVF_FLAT, FLAT напрямую сравнивает расстояния между целевым вектором и каждым вектором.</p>
<p>
Поэтому, когда общее количество векторов приблизительно равно <code translate="no">nlist</code>, IVF_FLAT и FLAT мало отличаются по количеству необходимых вычислений и производительности поиска. Но при увеличении числа векторов в два, три или n раз от <code translate="no">nlist</code> индекс IVF_FLAT начинает демонстрировать все большие преимущества.</p>
<p>
Дополнительную информацию см. в разделе <a href="https://medium.com/unstructured-data-service/how-to-choose-an-index-in-milvus-4f3d15259212">Как выбрать индекс в Milvus</a>.</p>
</details>
<h2 id="Whats-next" class="common-anchor-header">Что дальше<button data-href="#Whats-next" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ul>
<li>Узнайте больше о <a href="/docs/ru/v2.5.x/metric.md">метриках сходства</a>, поддерживаемых в Milvus.</li>
</ul>
