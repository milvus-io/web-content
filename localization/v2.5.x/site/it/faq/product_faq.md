---
id: product_faq.md
summary: >-
  Trovate le risposte alle domande più frequenti sul database vettoriale più
  avanzato al mondo.
title: FAQ sul prodotto
---

<h1 id="Product-FAQ" class="common-anchor-header">FAQ sul prodotto<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Quanto costa Milvus?</h4><p>Milvus è un progetto open-source gratuito al 100%.</p>
<p>Quando si utilizza Milvus per scopi di produzione o distribuzione, si prega di attenersi alla <a href="http://www.apache.org/licenses/LICENSE-2.0">Licenza Apache 2.0</a>.</p>
<p>Zilliz, l'azienda che sta dietro a Milvus, offre anche una versione cloud completamente gestita della piattaforma per coloro che non vogliono costruire e mantenere la propria istanza distribuita. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> mantiene automaticamente l'affidabilità dei dati e consente agli utenti di pagare solo per ciò che utilizzano.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Milvus supporta architetture non x86?</h4><p>Milvus non può essere installato o eseguito su piattaforme non-x86.</p>
<p>La CPU deve supportare uno dei seguenti set di istruzioni per eseguire Milvus: SSE4.2, AVX, AVX2, AVX512. Si tratta di set di istruzioni SIMD dedicati a x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Dove vengono memorizzati i dati in Milvus?</h4><p>Milvus tratta due tipi di dati: i dati inseriti e i metadati.</p>
<p>I dati inseriti, compresi i dati vettoriali, i dati scalari e lo schema specifico della collezione, sono memorizzati in un archivio persistente come log incrementale. Milvus supporta diversi backend di archiviazione a oggetti, tra cui <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> e <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>I metadati sono generati all'interno di Milvus. Ogni modulo Milvus ha i propri metadati che vengono memorizzati in etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Perché non ci sono dati vettoriali in etcd?</h4><p>etcd memorizza i metadati dei moduli Milvus; MinIO memorizza le entità.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Milvus supporta l'inserimento e la ricerca di dati contemporaneamente?</h4><p>Sì. Le operazioni di inserimento e di interrogazione sono gestite da due moduli distinti e indipendenti tra loro. Dal punto di vista del client, un'operazione di inserimento è completa quando i dati inseriti entrano nella coda dei messaggi. Tuttavia, i dati inseriti non sono ricercabili finché non vengono caricati sul nodo di interrogazione. Se la dimensione del segmento non raggiunge la soglia di costruzione dell'indice (512 MB per impostazione predefinita), Milvus ricorre alla ricerca bruta e le prestazioni della query possono diminuire.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">È possibile inserire in Milvus vettori con chiavi primarie duplicate?</h4><p>Sì, Milvus non controlla se i vettori hanno chiavi primarie duplicate. Milvus non controlla se le chiavi primarie dei vettori sono duplicate.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Quando si inseriscono vettori con chiavi primarie duplicate, Milvus li tratta come un'operazione di aggiornamento?</h4><p>No. Milvus non supporta attualmente le operazioni di aggiornamento e non controlla se le chiavi primarie delle entità sono duplicate. È responsabilità dell'utente assicurarsi che le chiavi primarie delle entità siano uniche e, in caso contrario, Milvus potrebbe contenere più entità con chiavi primarie duplicate.</p>
<p>In questo caso, la copia dei dati che viene restituita quando viene interrogata rimane un comportamento sconosciuto. Questa limitazione sarà risolta nelle prossime versioni.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Qual è la lunghezza massima delle chiavi primarie autodefinite delle entità?</h4><p>Le chiavi primarie delle entità devono essere numeri interi non negativi a 64 bit.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Qual è la quantità massima di dati che possono essere aggiunti per ogni operazione di inserimento?</h4><p>Un'operazione di inserimento non deve superare i 1.024 MB. Si tratta di un limite imposto da gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">La dimensione della raccolta influisce sulle prestazioni della query quando si effettua una ricerca in una partizione specifica?</h4><p>No. Se vengono specificate le partizioni per una ricerca, Milvus cerca solo nelle partizioni specificate.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Milvus deve caricare l'intera collezione quando si specificano le partizioni per una ricerca?</h4><p>Dipende dai dati necessari per la ricerca. Tutte le partizioni che potrebbero apparire nei risultati della ricerca devono essere caricate prima della ricerca.</p>
<ul>
<li>Ad esempio, se si desidera cercare solo una o più partizioni specifiche, non è necessario caricarle tutte. Chiamare <code translate="no">load_partition()</code> per caricare le partizioni desiderate <em>, quindi</em> specificare la partizione o le partizioni nella chiamata al metodo <code translate="no">search()</code>.</li>
<li>Se si desidera cercare tutte le partizioni, chiamare <code translate="no">load_collection()</code> per caricare l'intero insieme, comprese tutte le partizioni.</li>
<li>Se non si carica l'insieme o le partizioni specifiche prima della ricerca, Milvus restituisce un errore.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">È possibile creare indici dopo aver inserito i vettori?</h4><p>Sì. Se in precedenza è stato creato un indice per una collezione da <code translate="no">create_index()</code>, Milvus creerà automaticamente un indice per i vettori inseriti successivamente. Tuttavia, Milvus non costruisce un indice finché i nuovi vettori inseriti non riempiono un intero segmento e il nuovo file di indice creato è separato da quello precedente.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">Come si differenziano gli indici FLAT e IVF_FLAT?</h4><p>L'indice IVF_FLAT divide lo spazio vettoriale in cluster di elenchi. Al valore predefinito di 16.384, Milvus confronta le distanze tra il vettore di destinazione e i centroidi di tutti i 16.384 cluster per restituire i cluster più vicini. Milvus confronta quindi le distanze tra il vettore target e i vettori nei cluster selezionati per ottenere i vettori più vicini. A differenza di IVF_FLAT, FLAT confronta direttamente le distanze tra il vettore target e ogni altro vettore.</p>
<p>Quando il numero totale di vettori è approssimativamente pari a nlist, la distanza tra IVF_FLAT e FLAT è minima in termini di requisiti di calcolo e prestazioni di ricerca. Tuttavia, quando il numero di vettori supera nlist di un fattore due o più, IVF_FLAT inizia a mostrare vantaggi in termini di prestazioni.</p>
<p>Per ulteriori informazioni, vedere <a href="/docs/it/v2.5.x/index.md">Indice dei vettori</a>.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Come fa Milvus a scaricare i dati?</h4><p>Milvus restituisce un successo quando i dati inseriti vengono inseriti nella coda dei messaggi. Tuttavia, i dati non vengono ancora scaricati sul disco. Quindi il nodo dati di Milvus scrive i dati nella coda dei messaggi in un archivio persistente come log incrementale. Se si chiama <code translate="no">flush()</code>, il nodo dati è costretto a scrivere immediatamente tutti i dati nella coda dei messaggi nell'archivio persistente.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Cos'è la normalizzazione? Perché la normalizzazione è necessaria?</h4><p>La normalizzazione si riferisce al processo di conversione di un vettore in modo che la sua norma sia uguale a 1. Se il prodotto interno viene utilizzato per calcolare la somiglianza tra vettori, i vettori devono essere normalizzati. Dopo la normalizzazione, il prodotto interno equivale alla somiglianza del coseno.</p>
<p>Per ulteriori informazioni, consultare <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a>.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Perché la distanza euclidea (L2) e il prodotto interno (IP) danno risultati diversi?</h4><p>Per i vettori normalizzati, la distanza euclidea (L2) è matematicamente equivalente al prodotto interno (IP). Se queste metriche di somiglianza danno risultati diversi, verificare se i vettori sono normalizzati.</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">C'è un limite al numero totale di collezioni e partizioni in Milvus?</h4><p>Sì. È possibile creare fino a 65.535 collezioni in un'istanza di Milvus. Quando si calcola il numero di collezioni esistenti, Milvus conta tutte le collezioni con frammenti e partizioni al loro interno.</p>
<p>Ad esempio, supponiamo di aver già creato 100 raccolte, con 2 frammenti e 4 partizioni in 60 di esse e con 1 frammento e 12 partizioni nelle altre 40 raccolte. Il numero attuale di raccolte può essere calcolato come:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Perché ottengo meno di k vettori quando cerco i vettori di <code translate="no">topk</code>?</h4><p>Tra gli indici supportati da Milvus, IVF_FLAT e IVF_SQ8 implementano il metodo di clustering k-means. Uno spazio dati viene suddiviso in <code translate="no">nlist</code> cluster e i vettori inseriti vengono distribuiti in questi cluster. Milvus seleziona quindi i cluster <code translate="no">nprobe</code> più vicini e confronta le distanze tra il vettore target e tutti i vettori nei cluster selezionati per restituire i risultati finali.</p>
<p>Se <code translate="no">nlist</code> e <code translate="no">topk</code> sono grandi e nprobe è piccolo, il numero di vettori nei cluster nprobe può essere inferiore a <code translate="no">k</code>. Pertanto, quando si cercano i vettori più vicini a <code translate="no">topk</code>, il numero di vettori restituiti è inferiore a <code translate="no">k</code>.</p>
<p>Per evitare questo problema, provare a impostare <code translate="no">nprobe</code> più grande e <code translate="no">nlist</code> e <code translate="no">k</code> più piccolo.</p>
<p>Per ulteriori informazioni, vedere <a href="/docs/it/v2.5.x/index.md">Indice vettoriale</a>.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Qual è la dimensione massima dei vettori supportata da Milvus?</h4><p>Per impostazione predefinita, Milvus può gestire vettori con un massimo di 32.768 dimensioni. È possibile aumentare il valore di <code translate="no">Proxy.maxDimension</code> per consentire un vettore di dimensioni maggiori.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Milvus supporta la CPU Apple M1?</h4><p>L'attuale versione di Milvus non supporta direttamente la CPU Apple M1. Dopo Milvus 2.3, Milvus fornirà immagini Docker per l'architettura ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Quali tipi di dati supporta Milvus per il campo chiave primaria?</h4><p>Nella versione attuale, Milvus supporta sia INT64 che stringhe.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Milvus è scalabile?</h4><p>Sì. È possibile distribuire il cluster Milvus con più nodi tramite Helm Chart su Kubernetes. Per ulteriori istruzioni, consultare la <a href="/docs/it/v2.5.x/scaleout.md">Guida alla scalabilità</a>.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Cosa sono il segmento crescente e il segmento chiuso?</h4><p>Quando arriva una richiesta di ricerca, Milvus cerca sia i dati incrementali che quelli storici. I dati incrementali sono aggiornamenti recenti e sono memorizzati nei segmenti in crescita, che vengono bufferizzati in memoria prima che raggiungano la soglia per essere persistiti nello storage a oggetti e per i quali viene costruito un indice più efficiente, mentre i dati storici sono aggiornamenti di qualche tempo fa. Si trovano nei segmenti sigillati che sono stati persistiti nell'archivio oggetti. I dati incrementali e i dati storici costituiscono l'intero set di dati per la ricerca. Questo design rende qualsiasi dato inserito in Milvus immediatamente ricercabile. Per Milvus Distributed, ci sono fattori più complessi che decidono quando un record appena ingerito può apparire nei risultati di ricerca. Per saperne di più su questo aspetto, consultate i <a href="https://milvus.io/docs/consistency.md">livelli di consistenza</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Milvus è disponibile per la ricerca simultanea?</h4><p>Sì. Per le interrogazioni sulla stessa collezione, Milvus è disponibile per la ricerca concorrente? Per le query sulla stessa collezione, Milvus esegue ricerche simultanee sui dati incrementali e storici. Tuttavia, le query su collezioni diverse sono condotte in serie. Mentre i dati storici possono essere un insieme di dati estremamente vasto, le ricerche sui dati storici sono relativamente più lunghe ed eseguite essenzialmente in serie.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Perché i dati in MinIO rimangono anche dopo che la raccolta corrispondente è stata eliminata?</h4><p>I dati in MinIO sono progettati per rimanere per un certo periodo di tempo per la comodità del rollback dei dati.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Milvus supporta motori di messaggi diversi da Pulsar?</h4><p>Sì. Kafka è supportato in Milvus. Kafka è supportato in Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">Qual è la differenza tra una ricerca e una query?</h4><p>In Milvus, una ricerca per similarità vettoriale recupera i vettori in base al calcolo della similarità e all'accelerazione dell'indice vettoriale. A differenza di una ricerca per similarità vettoriale, una query vettoriale recupera i vettori tramite un filtro scalare basato su un'espressione booleana. L'espressione booleana filtra i campi scalari o il campo chiave primaria e recupera tutti i risultati che corrispondono ai filtri. In una query non sono coinvolti né la metrica di similarità né l'indice vettoriale.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Perché un valore vettoriale float ha una precisione di 7 cifre decimali in Milvus?</h4><p>Milvus supporta la memorizzazione di vettori come array Float32. Un valore Float32 ha una precisione di 7 cifre decimali. Anche con un valore Float64, come 1,3476964684980388, Milvus lo memorizza come 1,347696. Pertanto, quando si recupera un vettore di questo tipo da Milvus, si perde la precisione del valore Float64.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Come gestisce Milvus i tipi di dati vettoriali e la precisione?</h4><p>Milvus supporta i tipi di vettore Binary, Float32, Float16 e BFloat16.</p>
<ul>
<li>Vettori binari: Memorizzano dati binari come sequenze di 0 e 1, utilizzati nell'elaborazione delle immagini e nel recupero delle informazioni.</li>
<li>Vettori Float32: Memorizzazione predefinita con una precisione di circa 7 cifre decimali. Anche i valori Float64 sono memorizzati con precisione Float32, con conseguente potenziale perdita di precisione al momento del recupero.</li>
<li>Vettori Float16 e BFloat16: Offrono una precisione e un utilizzo della memoria ridotti. Float16 è adatto per applicazioni con larghezza di banda e memoria limitate, mentre BFloat16 bilancia la portata e l'efficienza, ed è comunemente usato nel deep learning per ridurre i requisiti computazionali senza impattare significativamente sulla precisione.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Milvus supporta la specificazione di valori predefiniti per campi scalari o vettoriali?</h4><p>Attualmente, Milvus 2.4.x non supporta la specificazione di valori predefiniti per i campi scalari o vettoriali. Questa funzione è prevista per le prossime versioni.</p>
<h4 id="Is-storage-space-released-right-after-data-deletion-in-Milvus" class="common-anchor-header">Lo spazio di archiviazione viene rilasciato subito dopo la cancellazione dei dati in Milvus?</h4><p>No, lo spazio di archiviazione non viene rilasciato immediatamente quando si eliminano i dati in Milvus. Anche se l'eliminazione dei dati segna le entità come "logicamente eliminate", lo spazio effettivo potrebbe non essere liberato immediatamente. Ecco perché:</p>
<ul>
<li><strong>Compattazione</strong>: Milvus compatta automaticamente i dati in background. Questo processo unisce segmenti di dati più piccoli in segmenti più grandi e rimuove i dati eliminati logicamente (entità contrassegnate per l'eliminazione) o i dati che hanno superato il loro Time-To-Live (TTL). Tuttavia, la compattazione crea nuovi segmenti e contrassegna quelli vecchi come "abbandonati".</li>
<li><strong>Garbage Collection</strong>: Un processo separato chiamato Garbage Collection (GC) rimuove periodicamente questi segmenti "abbandonati", liberando lo spazio di memoria che occupavano. Ciò garantisce un uso efficiente dello spazio di archiviazione, ma può comportare un leggero ritardo tra l'eliminazione e il recupero dello spazio.</li>
</ul>
<h4 id="Can-I-see-inserted-deleted-or-upserted-data-immediately-after-the-operation-without-waiting-for-a-flush" class="common-anchor-header">Posso vedere i dati inseriti, cancellati o upsertati subito dopo l'operazione senza aspettare il flush?</h4><p>Sì, in Milvus la visibilità dei dati non è direttamente legata alle operazioni di flush, grazie alla sua architettura di disaggregazione storage-computer. È possibile gestire la leggibilità dei dati utilizzando i livelli di coerenza.</p>
<p>Quando si sceglie un livello di coerenza, bisogna considerare il compromesso tra coerenza e prestazioni. Per le operazioni che richiedono una visibilità immediata, utilizzare un livello di coerenza "forte". Per le scritture più veloci, privilegiare una consistenza più debole (i dati potrebbero non essere immediatamente visibili). Per ulteriori informazioni, consultare <a href="/docs/it/v2.5.x/consistency.md">Consistenza</a>.</p>
<h4 id="After-enabling-the-partition-key-feature-what-is-the-default-value-of-numpartitions-in-Milvus-and-why" class="common-anchor-header">Dopo aver abilitato la funzione di chiave di partizione, qual è il valore predefinito di <code translate="no">num_partitions</code> in Milvus e perché?</h4><p>Quando la funzione di chiave di partizione è abilitata, il valore predefinito di <code translate="no">num_partitions</code> in Milvus è impostato su <code translate="no">16</code>. Questo valore predefinito è stato scelto per motivi di stabilità e prestazioni. È possibile modificare il valore di <code translate="no">num_partitions</code> in base alle esigenze specificandolo nella funzione <code translate="no">create_collection</code>.</p>
<h4 id="Is-there-a-maximum-length-limit-for-scalar-filtering-expressions" class="common-anchor-header">Esiste un limite massimo di lunghezza per le espressioni di filtraggio scalari?</h4><p>Sì, la lunghezza massima di un'espressione di filtraggio scalare è vincolata dal limite di trasferimento RPC, che è definito nel file di configurazione <code translate="no">milvus.yaml</code>. In particolare, il limite è impostato dal parametro <code translate="no">serverMaxRecvSize</code> nella sezione proxy:</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Per impostazione predefinita, la dimensione massima di ogni richiesta RPC è di 64 MB. Pertanto, la lunghezza dell'espressione di filtraggio deve essere inferiore a questo limite per garantire un'elaborazione corretta.</p>
<h4 id="When-performing-a-bulk-vector-search-how-many-vectors-can-be-specified-at-once-Is-there-a-limit" class="common-anchor-header">Quando si esegue una ricerca massiva di vettori, quanti vettori possono essere specificati contemporaneamente? C'è un limite?</h4><p>Sì, il numero di vettori che possono essere specificati in una ricerca vettoriale massiva è limitato dalla dimensione del trasferimento RPC, come definito nel file di configurazione <code translate="no">milvus.yaml</code>. Questo limite è determinato dal parametro <code translate="no">serverMaxRecvSize</code> nella sezione proxy:</p>
<pre><code translate="no" class="language-yaml">proxy:
  grpc:
    serverMaxRecvSize: <span class="hljs-number">67108864</span> <span class="hljs-comment"># The maximum size of each RPC request that the proxy can receive, unit: byte</span>
<button class="copy-code-btn"></button></code></pre>
<p>Per impostazione predefinita, la dimensione massima di ogni richiesta RPC è di 64 MB. Pertanto, la dimensione totale dei vettori di input, compresi i dati dimensionali e i metadati, deve essere inferiore a questo limite per garantire un'esecuzione corretta.</p>
<h4 id="How-can-I-get-all-the-unique-value-of-a-given-scalar-field-from-a-collection" class="common-anchor-header">Come posso ottenere tutti i valori univoci di un dato campo scalare da una collezione?</h4><p>Attualmente non esiste un metodo diretto per ottenere questo risultato. Come soluzione alternativa, si consiglia di usare un query_iterator per recuperare tutti i valori di un campo specifico e poi eseguire la deduplicazione manualmente. Abbiamo in programma di aggiungere un supporto diretto per questa funzione in Milvus 2.6. Esempio di utilizzo di query_iterator:</p>
<pre><code translate="no" class="language-python"><span class="hljs-comment"># set up iterator</span>
iterator = client.query_iterator(
    collection_name=<span class="hljs-string">&quot;demo_collection&quot;</span>,
    output_fields=[<span class="hljs-string">&quot;target&quot;</span>]
)
<span class="hljs-comment"># do iteration and store target values into value_set </span>
value_set = <span class="hljs-built_in">set</span>()
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;query iteration finished, close&quot;</span>)
        iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        value_set.add(res[i][<span class="hljs-string">&quot;target&quot;</span>])

<span class="hljs-comment"># value_set will contain unique values for target column </span>
<button class="copy-code-btn"></button></code></pre>

<h4 id="What-are-the-limitations-of-using-dynamic-fields-For-example-are-there-size-limits-modification-methods-or-indexing-restrictions" class="common-anchor-header">Quali sono i limiti dell'uso dei campi dinamici? Per esempio, ci sono limiti di dimensione, metodi di modifica o restrizioni di indicizzazione?</h4><p>I campi dinamici sono rappresentati internamente con campi JSON, con un limite di dimensione di 65.536 byte. Supportano le modifiche upsert, che consentono di aggiungere o aggiornare i campi. Tuttavia, a partire da Milvus 2.5.1, i campi dinamici non supportano l'indicizzazione. Il supporto per l'aggiunta di indici per JSON sarà introdotto nelle prossime versioni.</p>
<h4 id="Does-Milvus-support-schema-changes" class="common-anchor-header">Milvus supporta le modifiche allo schema?</h4><p>A partire dalla versione 2.5.0 di Milvus, le modifiche allo schema sono limitate a modifiche specifiche, come la regolazione di proprietà quali il parametro <code translate="no">mmap</code>. Gli utenti possono anche modificare i parametri <code translate="no">max_length</code> per i campi varchar e <code translate="no">max_capacity</code> per i campi array. Tuttavia, per le versioni future è prevista la possibilità di aggiungere o rimuovere campi negli schemi, migliorando la flessibilità della gestione degli schemi in Milvus.</p>
<h4 id="Does-modifying-maxlength-for-VarChar-require-data-reorganization" class="common-anchor-header">La modifica di max_length per VarChar richiede una riorganizzazione dei dati?</h4><p>No, la modifica di <code translate="no">max_length</code> per un campo VarChar non richiede la riorganizzazione dei dati, come la compattazione o la riorganizzazione. Questa modifica aggiorna principalmente i criteri di convalida per qualsiasi nuovo dato inserito nel campo, lasciando inalterati i dati esistenti. Di conseguenza, questa modifica è considerata leggera e non comporta un sovraccarico significativo per il sistema.</p>
<h4 id="Still-have-questions" class="common-anchor-header">Avete ancora domande?</h4><p>È possibile:</p>
<ul>
<li>Controllare <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> su GitHub. Siete invitati a porre domande, condividere idee e aiutare gli altri.</li>
<li>Unitevi alla nostra <a href="https://slack.milvus.io/">comunità Slack</a> per trovare supporto e impegnarvi con la nostra comunità open-source.</li>
</ul>
