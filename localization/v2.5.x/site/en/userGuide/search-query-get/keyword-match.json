{"codeList":["from pymilvus import MilvusClient, DataType​\n​\nschema = MilvusClient.create_schema(auto_id=True, enable_dynamic_field=False)​\n​\nschema.add_field(​\n    field_name='text', ​\n    datatype=DataType.VARCHAR, ​\n    max_length=1000, ​\n    enable_analyzer=True, # Whether to enable text analysis for this field​\n    enable_match=True # Whether to enable text match​\n)​\n\n","import io.milvus.v2.common.DataType;\nimport io.milvus.v2.service.collection.request.AddFieldReq;\nimport io.milvus.v2.service.collection.request.CreateCollectionReq;\n\nCreateCollectionReq.CollectionSchema schema = CreateCollectionReq.CollectionSchema.builder()\n        .enableDynamicField(false)\n        .build();\n\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"text\")\n        .dataType(DataType.VarChar)\n        .maxLength(1000)\n        .enableAnalyzer(true)\n        .enableMatch(true)\n        .build());\n\n","const schema = [\n  {\n    name: \"id\",\n    data_type: DataType.Int64,\n    is_primary_key: true,\n  },\n  {\n    name: \"text\",\n    data_type: \"VarChar\",\n    enable_analyzer: true,\n    enable_match: true,\n    max_length: 1000,\n  },\n  {\n    name: \"sparse\",\n    data_type: DataType.SparseFloatVector,\n  },\n];\n\n","export schema='{\n        \"autoId\": true,\n        \"enabledDynamicField\": false,\n        \"fields\": [\n            {\n                \"fieldName\": \"id\",\n                \"dataType\": \"Int64\",\n                \"isPrimary\": true\n            },\n            {\n                \"fieldName\": \"text\",\n                \"dataType\": \"VarChar\",\n                \"elementTypeParams\": {\n                    \"max_length\": 1000,\n                    \"enable_analyzer\": true,\n                    \"enable_match\": true\n                }\n            },\n            {\n                \"fieldName\": \"sparse\",\n                \"dataType\": \"SparseFloatVector\"\n            }\n        ]\n    }'\n\n","analyzer_params={​\n    \"type\": \"english\"​\n}​\n​\nschema.add_field(​\n    field_name='text', ​\n    datatype=DataType.VARCHAR, ​\n    max_length=200, ​\n    enable_analyzer=True，​\n    analyzer_params=analyzer_params,​\n    enable_match=True, ​\n)​\n\n","Map<String, Object> analyzerParams = new HashMap<>();\nanalyzerParams.put(\"type\", \"english\");\nschema.addField(AddFieldReq.builder()\n        .fieldName(\"text\")\n        .dataType(DataType.VarChar)\n        .maxLength(200)\n        .enableAnalyzer(true)\n        .analyzerParams(analyzerParams)\n        .enableMatch(true)\n        .build());\n\n","const schema = [\n  {\n    name: \"id\",\n    data_type: DataType.Int64,\n    is_primary_key: true,\n  },\n  {\n    name: \"text\",\n    data_type: \"VarChar\",\n    enable_analyzer: true,\n    enable_match: true,\n    max_length: 1000,\n    analyzer_params: { type: 'english' },\n  },\n  {\n    name: \"sparse\",\n    data_type: DataType.SparseFloatVector,\n  },\n];\n\n","export schema='{\n        \"autoId\": true,\n        \"enabledDynamicField\": false,\n        \"fields\": [\n            {\n                \"fieldName\": \"id\",\n                \"dataType\": \"Int64\",\n                \"isPrimary\": true\n            },\n            {\n                \"fieldName\": \"text\",\n                \"dataType\": \"VarChar\",\n                \"elementTypeParams\": {\n                    \"max_length\": 200,\n                    \"enable_analyzer\": true,\n                    \"enable_match\": true,\n                    \"analyzer_params\": {\"type\": \"english\"}\n                }\n            },\n            {\n                \"fieldName\": \"my_vector\",\n                \"dataType\": \"FloatVector\",\n                \"elementTypeParams\": {\n                    \"dim\": \"5\"\n                }\n            }\n        ]\n    }'\n\n","TEXT_MATCH(field_name, text)​\n\n","filter = \"TEXT_MATCH(text, 'machine deep')\"​\n","String filter = \"TEXT_MATCH(text, 'machine deep')\";\n","const filter = \"TEXT_MATCH(text, 'machine deep')\";\n","export filter=\"\\\"TEXT_MATCH(text, 'machine deep')\\\"\"\n","filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\"​\n","String filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\";\n","const filter = \"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\"\n","export filter=\"\\\"TEXT_MATCH(text, 'machine') and TEXT_MATCH(text, 'deep')\\\"\"\n","# Match entities with `keyword1` or `keyword2`​\nfilter = \"TEXT_MATCH(text, 'keyword1 keyword2')\"​\n​\n# Assuming 'embeddings' is the vector field and 'text' is the VARCHAR field​\nresult = MilvusClient.search(​\n    collection_name=\"YOUR_COLLECTION_NAME\", # Your collection name​\n    anns_field=\"embeddings\", # Vector field name​\n    data=[query_vector], # Query vector​\n    filter=filter,​\n    search_params={\"params\": {\"nprobe\": 10}},​\n    limit=10, # Max. number of results to return​\n    output_fields=[\"id\", \"text\"] # Fields to return​\n)​\n\n","String filter = \"TEXT_MATCH(text, 'keyword1 keyword2')\";\n\nSearchResp searchResp = client.search(SearchReq.builder()\n        .collectionName(\"YOUR_COLLECTION_NAME\")\n        .annsField(\"embeddings\")\n        .data(Collections.singletonList(queryVector)))\n        .filter(filter)\n        .topK(10)\n        .outputFields(Arrays.asList(\"id\", \"text\"))\n        .build());\n","// Match entities with `keyword1` or `keyword2`\nconst filter = \"TEXT_MATCH(text, 'keyword1 keyword2')\";\n\n// Assuming 'embeddings' is the vector field and 'text' is the VARCHAR field\nconst result = await client.search(\n    collection_name: \"YOUR_COLLECTION_NAME\", // Your collection name\n    anns_field: \"embeddings\", // Vector field name\n    data: [query_vector], // Query vector\n    filter: filter,\n    params: {\"nprobe\": 10},\n    limit: 10, // Max. number of results to return\n    output_fields: [\"id\", \"text\"] //Fields to return\n);\n","export filter=\"\\\"TEXT_MATCH(text, 'keyword1 keyword2')\\\"\"\n\nexport CLUSTER_ENDPOINT=\"http://localhost:19530\"\nexport TOKEN=\"root:Milvus\"\n\ncurl --request POST \\\n--url \"${CLUSTER_ENDPOINT}/v2/vectordb/entities/search\" \\\n--header \"Authorization: Bearer ${TOKEN}\" \\\n--header \"Content-Type: application/json\" \\\n-d '{\n    \"collectionName\": \"demo2\",\n    \"annsField\": \"my_vector\",\n    \"data\": [[0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104]],\n    \"filter\": '\"$filter\"',\n    \"searchParams\": {\n        \"params\": {\n            \"nprobe\": 10\n        }\n    },\n    \"limit\": 3,\n    \"outputFields\": [\"text\",\"id\"]\n}'\n","# Match entities with both `keyword1` and `keyword2`​\nfilter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\"​\n​\nresult = MilvusClient.query(​\n    collection_name=\"YOUR_COLLECTION_NAME\",​\n    filter=filter, ​\n    output_fields=[\"id\", \"text\"]​\n)​\n\n","String filter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\";\n\nQueryResp queryResp = client.query(QueryReq.builder()\n        .collectionName(\"YOUR_COLLECTION_NAME\")\n        .filter(filter)\n        .outputFields(Arrays.asList(\"id\", \"text\"))\n        .build()\n);\n","// Match entities with both `keyword1` and `keyword2`\nconst filter = \"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\";\n\nconst result = await client.query(\n    collection_name: \"YOUR_COLLECTION_NAME\",\n    filter: filter, \n    output_fields: [\"id\", \"text\"]\n)\n","export filter=\"\\\"TEXT_MATCH(text, 'keyword1') and TEXT_MATCH(text, 'keyword2')\\\"\"\n\nexport CLUSTER_ENDPOINT=\"http://localhost:19530\"\nexport TOKEN=\"root:Milvus\"\n\ncurl --request POST \\\n--url \"${CLUSTER_ENDPOINT}/v2/vectordb/entities/query\" \\\n--header \"Authorization: Bearer ${TOKEN}\" \\\n--header \"Content-Type: application/json\" \\\n-d '{\n    \"collectionName\": \"demo2\",\n    \"filter\": '\"$filter\"',\n    \"outputFields\": [\"id\", \"text\"]\n}'\n"],"headingContent":"Text Match​","anchorList":[{"label":"Text Match​","href":"Text-Match​","type":1,"isActive":false},{"label":"Overview","href":"Overview","type":2,"isActive":false},{"label":"Enable text match","href":"Enable-text-match","type":2,"isActive":false},{"label":"Use text match","href":"Use-text-match","type":2,"isActive":false},{"label":"Considerations","href":"Considerations","type":2,"isActive":false}]}