---
id: product_faq.md
summary: >-
  Trouvez les réponses aux questions les plus fréquemment posées sur la base de
  données vectorielles la plus avancée au monde.
title: FAQ sur les produits
---
<h1 id="Product-FAQ" class="common-anchor-header">FAQ sur les produits<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Combien coûte Milvus ?</h4><p>Milvus est un projet open-source 100% gratuit.</p>
<p>Veuillez respecter la <a href="http://www.apache.org/licenses/LICENSE-2.0">licence Apache 2.0</a> lorsque vous utilisez Milvus à des fins de production ou de distribution.</p>
<p>Zilliz, la société à l'origine de Milvus, propose également une version cloud entièrement gérée de la plateforme pour ceux qui ne souhaitent pas construire et maintenir leur propre instance distribuée. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> maintient automatiquement la fiabilité des données et permet aux utilisateurs de ne payer que pour ce qu'ils utilisent.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Milvus prend-il en charge les architectures non-x86 ?</h4><p>Milvus ne peut pas être installé ou exécuté sur des plates-formes non-x86.</p>
<p>Votre processeur doit prendre en charge l'un des jeux d'instructions suivants pour exécuter Milvus : SSE4.2, AVX, AVX2, AVX512. Il s'agit de jeux d'instructions SIMD dédiés à l'architecture x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Où Milvus stocke-t-il les données ?</h4><p>Milvus traite deux types de données, les données insérées et les métadonnées.</p>
<p>Les données insérées, y compris les données vectorielles, les données scalaires et le schéma spécifique à la collection, sont stockées dans un stockage persistant en tant que journal incrémentiel. Milvus prend en charge plusieurs backends de stockage d'objets, notamment <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> et <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Les métadonnées sont générées au sein de Milvus. Chaque module Milvus a ses propres métadonnées qui sont stockées dans etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Pourquoi n'y a-t-il pas de données vectorielles dans etcd ?</h4><p>etcd stocke les métadonnées des modules Milvus ; MinIO stocke les entités.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Milvus prend-il en charge l'insertion et la recherche de données simultanément ?</h4><p>Oui. Les opérations d'insertion et les opérations de recherche sont gérées par deux modules distincts qui sont mutuellement indépendants. Du point de vue du client, une opération d'insertion est terminée lorsque les données insérées entrent dans la file d'attente des messages. Cependant, les données insérées ne sont pas consultables tant qu'elles n'ont pas été chargées dans le nœud d'interrogation. Si la taille du segment n'atteint pas le seuil de construction de l'index (512 Mo par défaut), Milvus a recours à la recherche par force brute et les performances de la requête peuvent être réduites.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Les vecteurs dont les clés primaires sont dupliquées peuvent-ils être insérés dans Milvus ?</h4><p>Oui. Milvus ne vérifie pas si les clés primaires des vecteurs sont dupliquées.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">Lorsque des vecteurs avec des clés primaires dupliquées sont insérés, Milvus les traite-t-il comme une opération de mise à jour ?</h4><p>Non. Milvus ne prend pas actuellement en charge les opérations de mise à jour et ne vérifie pas si les clés primaires des entités sont dupliquées. Il vous incombe de vous assurer que les clés primaires des entités sont uniques et, si ce n'est pas le cas, Milvus peut contenir plusieurs entités avec des clés primaires dupliquées.</p>
<p>Dans ce cas, la copie de données qui sera renvoyée lors d'une requête reste un comportement inconnu. Cette limitation sera corrigée dans les prochaines versions.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Quelle est la longueur maximale des clés primaires d'entité auto-définies ?</h4><p>Les clés primaires des entités doivent être des nombres entiers non négatifs de 64 bits.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Quelle est la quantité maximale de données pouvant être ajoutées par opération d'insertion ?</h4><p>La taille d'une opération d'insertion ne doit pas dépasser 1 024 Mo. Il s'agit d'une limite imposée par gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">La taille de la collection a-t-elle un impact sur les performances de la requête lors d'une recherche dans une partition spécifique ?</h4><p>Non. Si des partitions sont spécifiées pour une recherche, Milvus recherche uniquement dans les partitions spécifiées.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Milvus doit-il charger l'ensemble de la collection lorsque des partitions sont spécifiées pour une recherche ?</h4><p>Cela dépend des données nécessaires à la recherche. Toutes les partitions susceptibles d'apparaître dans les résultats de la recherche doivent être chargées avant la recherche.</p>
<ul>
<li>Par exemple, si vous ne souhaitez rechercher qu'une ou plusieurs partitions spécifiques, il n'est pas nécessaire de charger toutes les partitions. Appelez <code translate="no">load_partition()</code> pour charger la ou les partition(s) voulue(s) <em>, puis</em> spécifiez la ou les partition(s) dans l'appel de la méthode <code translate="no">search()</code>.</li>
<li>Si vous souhaitez rechercher toutes les partitions, appelez <code translate="no">load_collection()</code> pour charger l'ensemble de la collection, y compris toutes les partitions.</li>
<li>Si vous ne chargez pas la collection ou une ou plusieurs partitions spécifiques avant d'effectuer la recherche, Milvus renvoie une erreur.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Peut-on créer des index après avoir inséré des vecteurs ?</h4><p>Oui. Si un index a été construit pour une collection par <code translate="no">create_index()</code> auparavant, Milvus construira automatiquement un index pour les vecteurs insérés ultérieurement. Toutefois, Milvus ne construit pas d'index tant que les vecteurs nouvellement insérés ne remplissent pas un segment entier et que le fichier d'index nouvellement créé n'est pas séparé du précédent.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">En quoi les index FLAT et IVF_FLAT sont-ils différents ?</h4><p>L'index IVF_FLAT divise l'espace vectoriel en groupes de listes. Avec la valeur de liste par défaut de 16 384, Milvus compare les distances entre le vecteur cible et les centroïdes de tous les 16 384 clusters pour renvoyer les clusters les plus proches de la sonde. Milvus compare ensuite les distances entre le vecteur cible et les vecteurs des grappes sélectionnées pour obtenir les vecteurs les plus proches. Contrairement à IVF_FLAT, FLAT compare directement les distances entre le vecteur cible et tous les autres vecteurs.</p>
<p>Lorsque le nombre total de vecteurs est approximativement égal à nlist, il y a peu de différence entre IVF_FLAT et FLAT en termes d'exigences de calcul et de performances de recherche. Toutefois, lorsque le nombre de vecteurs dépasse nlist d'un facteur de deux ou plus, IVF_FLAT commence à présenter des avantages en termes de performances.</p>
<p>Voir <a href="/docs/fr/v2.4.x/index.md">Index des vecteurs</a> pour plus d'informations.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Comment Milvus extrait-il les données ?</h4><p>Milvus renvoie un succès lorsque les données insérées sont ingérées dans la file d'attente des messages. Toutefois, les données ne sont pas encore transférées sur le disque. Le nœud de données de Milvus écrit alors les données de la file d'attente de messages dans le stockage persistant sous forme de journaux incrémentiels. Si <code translate="no">flush()</code> est appelé, le nœud de données est forcé d'écrire immédiatement toutes les données de la file d'attente des messages dans le stockage permanent.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Qu'est-ce que la normalisation ? Pourquoi la normalisation est-elle nécessaire ?</h4><p>La normalisation est le processus de conversion d'un vecteur de sorte que sa norme soit égale à 1. Si le produit intérieur est utilisé pour calculer la similarité vectorielle, les vecteurs doivent être normalisés. Après normalisation, le produit intérieur est égal à la similarité en cosinus.</p>
<p>Voir <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> pour plus d'informations.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Pourquoi la distance euclidienne (L2) et le produit intérieur (PI) donnent-ils des résultats différents ?</h4><p>Pour les vecteurs normalisés, la distance euclidienne (L2) est mathématiquement équivalente au produit intérieur (PI). Si ces mesures de similarité donnent des résultats différents, vérifiez si vos vecteurs sont normalisés.</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Y a-t-il une limite au nombre total de collections et de partitions dans Milvus ?</h4><p>Oui. Vous pouvez créer jusqu'à 65 535 collections dans une instance Milvus. Lors du calcul du nombre de collections existantes, Milvus prend en compte toutes les collections contenant des tessons et des partitions.</p>
<p>Par exemple, supposons que vous ayez déjà créé 100 collections, avec 2 shards et 4 partitions dans 60 d'entre elles et avec 1 shard et 12 partitions dans les 40 collections restantes. Le nombre actuel de collections peut être calculé comme suit :</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Pourquoi est-ce que j'obtiens moins de k vecteurs lorsque je cherche <code translate="no">topk</code> vecteurs ?</h4><p>Parmi les index pris en charge par Milvus, IVF_FLAT et IVF_SQ8 mettent en œuvre la méthode de regroupement k-means. Un espace de données est divisé en <code translate="no">nlist</code> clusters et les vecteurs insérés sont distribués dans ces clusters. Milvus sélectionne ensuite les <code translate="no">nprobe</code> grappes les plus proches et compare les distances entre le vecteur cible et tous les vecteurs dans les grappes sélectionnées pour renvoyer les résultats finaux.</p>
<p>Si <code translate="no">nlist</code> et <code translate="no">topk</code> sont grands et que nprobe est petit, le nombre de vecteurs dans les grappes nprobe peut être inférieur à <code translate="no">k</code>. Par conséquent, lorsque vous recherchez les vecteurs les plus proches <code translate="no">topk</code>, le nombre de vecteurs renvoyés est inférieur à <code translate="no">k</code>.</p>
<p>Pour éviter cela, essayez d'augmenter <code translate="no">nprobe</code> et de réduire <code translate="no">nlist</code> et <code translate="no">k</code>.</p>
<p>Voir <a href="/docs/fr/v2.4.x/index.md">Index des vecteurs</a> pour plus d'informations.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Quelle est la dimension vectorielle maximale prise en charge par Milvus ?</h4><p>Milvus peut gérer des vecteurs ayant jusqu'à 32 768 dimensions par défaut. Vous pouvez augmenter la valeur de <code translate="no">Proxy.maxDimension</code> pour permettre un vecteur de plus grande dimension.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Milvus prend-il en charge le processeur Apple M1 ?</h4><p>La version actuelle de Milvus ne prend pas directement en charge le processeur Apple M1. Après Milvus 2.3, Milvus fournit des images Docker pour l'architecture ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Quels types de données Milvus prend-il en charge dans le champ de clé primaire ?</h4><p>Dans la version actuelle, Milvus prend en charge à la fois INT64 et les chaînes de caractères.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Milvus est-il évolutif ?</h4><p>Oui. Vous pouvez déployer le cluster Milvus avec plusieurs nœuds via Helm Chart sur Kubernetes. Reportez-vous au <a href="/docs/fr/v2.4.x/scaleout.md">Guide de mise à l'échelle</a> pour plus d'instructions.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Qu'est-ce qu'un segment croissant et un segment scellé ?</h4><p>Lorsqu'une demande de recherche arrive, Milvus recherche à la fois des données incrémentielles et des données historiques. Les données incrémentielles sont des mises à jour récentes, elles sont stockées dans les segments croissants, qui sont mis en mémoire tampon avant d'atteindre le seuil de persistance dans le stockage d'objets et un index plus efficace est construit pour elles, tandis que les données historiques sont des mises à jour qui datent d'il y a un certain temps. Elles se trouvent dans les segments scellés qui ont été conservés dans le stockage d'objets. Les données incrémentielles et les données historiques constituent ensemble l'ensemble des données à rechercher. Grâce à cette conception, toutes les données introduites dans Milvus sont instantanément consultables. Pour Milvus Distribué, il existe des facteurs plus complexes qui déterminent quand un enregistrement qui vient d'être ingéré peut apparaître dans les résultats de recherche. Pour en savoir plus, consultez les <a href="https://milvus.io/docs/consistency.md">niveaux de cohérence</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Milvus est-il disponible pour la recherche simultanée ?</h4><p>Oui. Pour les requêtes sur la même collection, Milvus recherche simultanément les données incrémentielles et historiques. Toutefois, les requêtes sur différentes collections sont effectuées en série. Alors que les données historiques peuvent constituer un ensemble de données extrêmement volumineux, les recherches sur les données historiques prennent relativement plus de temps et sont essentiellement effectuées en série.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Pourquoi les données de MinIO sont-elles conservées après l'abandon de la collection correspondante ?</h4><p>Les données dans MinIO sont conçues pour rester pendant un certain temps afin de faciliter le retour en arrière des données.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Milvus prend-il en charge des moteurs de messages autres que Pulsar ?</h4><p>Oui. Kafka est pris en charge dans Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">Quelle est la différence entre une recherche et une requête ?</h4><p>Dans Milvus, une recherche de similarité vectorielle récupère des vecteurs sur la base du calcul de similarité et de l'accélération de l'index vectoriel. Contrairement à une recherche de similarité vectorielle, une requête vectorielle récupère des vecteurs via un filtrage scalaire basé sur une expression booléenne. L'expression booléenne filtre les champs scalaires ou le champ de clé primaire, et récupère tous les résultats qui correspondent aux filtres. Dans une requête, ni la métrique de similarité ni l'index vectoriel ne sont impliqués.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Pourquoi une valeur vectorielle flottante a-t-elle une précision de 7 chiffres après la virgule dans Milvus ?</h4><p>Milvus prend en charge le stockage des vecteurs en tant que tableaux Float32. Une valeur Float32 a une précision de 7 chiffres après la virgule. Même avec une valeur Float64, telle que 1.3476964684980388, Milvus la stocke sous la forme 1.347696. Par conséquent, lorsque vous récupérez un tel vecteur dans Milvus, la précision de la valeur Float64 est perdue.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Comment Milvus gère-t-il les types de données vectorielles et la précision ?</h4><p>Milvus prend en charge les types de vecteurs Binary, Float32, Float16 et BFloat16.</p>
<ul>
<li>Vecteurs binaires : Stockent des données binaires sous forme de séquences de 0 et de 1. Ils sont utilisés dans le traitement des images et la recherche d'informations.</li>
<li>Vecteurs de type Float32 : Stockage par défaut avec une précision d'environ 7 chiffres après la virgule. Même les valeurs Float64 sont stockées avec une précision Float32, ce qui peut entraîner une perte de précision lors de la recherche.</li>
<li>Vecteurs Float16 et BFloat16 : Ils offrent une précision et une utilisation de la mémoire réduites. Float16 convient aux applications dont la bande passante et le stockage sont limités, tandis que BFloat16 établit un équilibre entre la portée et l'efficacité, couramment utilisé dans l'apprentissage profond pour réduire les exigences de calcul sans avoir d'impact significatif sur la précision.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Milvus prend-il en charge la spécification de valeurs par défaut pour les champs scalaires ou vectoriels ?</h4><p>Actuellement, Milvus 2.4.x ne prend pas en charge la spécification de valeurs par défaut pour les champs scalaires ou vectoriels. Cette fonctionnalité est prévue pour les prochaines versions.</p>
<h4 id="Still-have-questions" class="common-anchor-header">Vous avez encore des questions ?</h4><p>Vous pouvez le faire :</p>
<ul>
<li>Consulter <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> sur GitHub. Vous pouvez poser des questions, partager des idées et aider les autres.</li>
<li>Rejoignez notre <a href="https://discord.com/invite/8uyFbECzPX">serveur Discord</a> pour trouver de l'aide et vous engager avec notre communauté open-source.</li>
</ul>
