---
id: product_faq.md
summary: >-
  Найдите ответы на часто задаваемые вопросы о самой передовой в мире базе
  данных векторов.
title: Часто задаваемые вопросы о продукте
---
<h1 id="Product-FAQ" class="common-anchor-header">Часто задаваемые вопросы о продукте<button data-href="#Product-FAQ" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h1><h4 id="How-much-does-Milvus-cost" class="common-anchor-header">Сколько стоит Milvus?</h4><p>Milvus - это 100% бесплатный проект с открытым исходным кодом.</p>
<p>Пожалуйста, придерживайтесь <a href="http://www.apache.org/licenses/LICENSE-2.0">лицензии Apache License 2.0</a> при использовании Milvus для производства или распространения.</p>
<p>Компания Zilliz, стоящая за Milvus, также предлагает полностью управляемую облачную версию платформы для тех, кто не хочет создавать и поддерживать свой собственный распределенный экземпляр. <a href="https://zilliz.com/cloud">Zilliz Cloud</a> автоматически поддерживает надежность данных и позволяет пользователям платить только за то, что они используют.</p>
<h4 id="Does-Milvus-support-non-x86-architectures" class="common-anchor-header">Поддерживает ли Milvus архитектуры, отличные от x86?</h4><p>Milvus нельзя установить или запустить на платформах, не поддерживающих архитектуру x86.</p>
<p>Для работы Milvus ваш процессор должен поддерживать один из следующих наборов инструкций: SSE4.2, AVX, AVX2, AVX512. Это все наборы SIMD-инструкций, предназначенные для x86.</p>
<h4 id="Where-does-Milvus-store-data" class="common-anchor-header">Где Milvus хранит данные?</h4><p>Milvus имеет дело с двумя типами данных - вставленными данными и метаданными.</p>
<p>Вставленные данные, включая векторные данные, скалярные данные и специфическую схему коллекции, хранятся в постоянном хранилище в виде инкрементного журнала. Milvus поддерживает множество бэкендов объектных хранилищ, включая <a href="https://min.io/">MinIO</a>, <a href="https://aws.amazon.com/s3/?nc1=h_ls">AWS S3</a>, <a href="https://cloud.google.com/storage?hl=en#object-storage-for-companies-of-all-sizes">Google Cloud Storage</a> (GCS), <a href="https://azure.microsoft.com/en-us/products/storage/blobs">Azure Blob Storage</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> и <a href="https://www.tencentcloud.com/products/cos">Tencent Cloud Object Storage</a> (COS).</p>
<p>Метаданные генерируются внутри Milvus. Каждый модуль Milvus имеет свои собственные метаданные, которые хранятся в etcd.</p>
<h4 id="Why-is-there-no-vector-data-in-etcd" class="common-anchor-header">Почему в etcd нет векторных данных?</h4><p>В etcd хранятся метаданные модуля Milvus; в MinIO хранятся сущности.</p>
<h4 id="Does-Milvus-support-inserting-and-searching-data-simultaneously" class="common-anchor-header">Поддерживает ли Milvus одновременную вставку и поиск данных?</h4><p>Да. Операции вставки и запросы обрабатываются двумя отдельными модулями, которые взаимно независимы. С точки зрения клиента, операция вставки завершается, когда вставленные данные попадают в очередь сообщений. Однако вставленные данные недоступны для поиска до тех пор, пока они не будут загружены в узел запроса. Если размер сегмента не достигает порога построения индекса (512 МБ по умолчанию), Milvus прибегает к грубому поиску, и производительность запросов может снизиться.</p>
<h4 id="Can-vectors-with-duplicate-primary-keys-be-inserted-into-Milvus" class="common-anchor-header">Можно ли вставлять в Milvus векторы с дублирующимися первичными ключами?</h4><p>Да. Milvus не проверяет, являются ли первичные ключи векторов дубликатами.</p>
<h4 id="When-vectors-with-duplicate-primary-keys-are-inserted-does-Milvus-treat-it-as-an-update-operation" class="common-anchor-header">При вставке векторов с дублирующимися первичными ключами Milvus рассматривает это как операцию обновления?</h4><p>Нет. В настоящее время Milvus не поддерживает операции обновления и не проверяет, являются ли первичные ключи сущностей дубликатами. Вы отвечаете за то, чтобы первичные ключи сущностей были уникальными, и если это не так, то Milvus может содержать несколько сущностей с дублирующимися первичными ключами.</p>
<p>В этом случае неизвестно, какая копия данных будет возвращена при запросе. Это ограничение будет исправлено в будущих релизах.</p>
<h4 id="What-is-the-maximum-length-of-self-defined-entity-primary-keys" class="common-anchor-header">Какова максимальная длина самоопределяемых первичных ключей сущностей?</h4><p>Первичные ключи сущностей должны быть неотрицательными 64-битными целыми числами.</p>
<h4 id="What-is-the-maximum-amount-of-data-that-can-be-added-per-insert-operation" class="common-anchor-header">Какой максимальный объем данных может быть добавлен за одну операцию вставки?</h4><p>Размер операции вставки не должен превышать 1 024 МБ. Это ограничение, накладываемое gRPC.</p>
<h4 id="Does-collection-size-impact-query-performance-when-searching-in-a-specific-partition" class="common-anchor-header">Влияет ли размер коллекции на производительность запроса при поиске в определенном разделе?</h4><p>Нет. Если разделы для поиска указаны, Milvus выполняет поиск только в указанных разделах.</p>
<h4 id="Does-Milvus-need-to-load-the-entire-collection-when-partitions-are-specified-for-a-search" class="common-anchor-header">Нужно ли Milvus загружать всю коллекцию, если для поиска указаны разделы?</h4><p>Это зависит от того, какие данные нужны для поиска. Перед поиском необходимо загрузить все разделы, которые могут появиться в результатах поиска.</p>
<ul>
<li>Например, если вы хотите найти только определенный раздел (разделы), вам не нужно загружать все разделы. Вызовите <code translate="no">load_partition()</code>, чтобы загрузить нужный раздел (разделы) <em>, а затем</em> укажите раздел (разделы) в вызове метода <code translate="no">search()</code>.</li>
<li>Если вы хотите выполнить поиск во всех разделах, вызовите <code translate="no">load_collection()</code>, чтобы загрузить всю коллекцию, включая все разделы.</li>
<li>Если вы не загрузите коллекцию или конкретный раздел(ы) перед поиском, Milvus вернет ошибку.</li>
</ul>
<h4 id="Can-indexes-be-created-after-inserting-vectors" class="common-anchor-header">Можно ли создавать индексы после вставки векторов?</h4><p>Да. Если ранее для коллекции был создан индекс по адресу <code translate="no">create_index()</code>, Milvus автоматически создаст индекс для последующих вставленных векторов. Однако Milvus не строит индекс до тех пор, пока вновь вставленные векторы не заполнят весь сегмент, а вновь созданный индексный файл не будет отделен от предыдущего.</p>
<h4 id="How-are-the-FLAT-and-IVFFLAT-indexes-different" class="common-anchor-header">Чем отличаются индексы FLAT и IVF_FLAT?</h4><p>Индекс IVF_FLAT делит векторное пространство на кластеры списка. При значении списка по умолчанию 16 384, Milvus сравнивает расстояния между целевым вектором и центроидами всех 16 384 кластеров, чтобы вернуть ближайшие кластеры. Затем Milvus сравнивает расстояния между целевым вектором и векторами в выбранных кластерах, чтобы получить ближайшие векторы. В отличие от IVF_FLAT, FLAT напрямую сравнивает расстояния между целевым вектором и каждым другим вектором.</p>
<p>Когда общее количество векторов приблизительно равно nlist, между IVF_FLAT и FLAT существует небольшое расстояние с точки зрения требований к вычислениям и производительности поиска. Однако, когда количество векторов превышает nlist в два и более раз, IVF_FLAT начинает демонстрировать преимущества в производительности.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/v2.4.x/index.md">"Векторный индекс"</a>.</p>
<h4 id="How-does-Milvus-flush-data" class="common-anchor-header">Как Milvus промывает данные?</h4><p>Milvus возвращает успешный результат, когда вставленные данные попадают в очередь сообщений. Однако данные еще не выгружены на диск. Затем узел данных Milvus записывает данные в очереди сообщений в постоянное хранилище в виде инкрементных журналов. Если вызвать <code translate="no">flush()</code>, то узел данных будет вынужден немедленно записать все данные в очереди сообщений в постоянное хранилище.</p>
<h4 id="What-is-normalization-Why-is-normalization-needed" class="common-anchor-header">Что такое нормализация? Зачем нужна нормализация?</h4><p>Нормализация - это процесс преобразования вектора таким образом, чтобы его норма была равна 1. Если для вычисления сходства векторов используется внутреннее произведение, векторы должны быть нормализованы. После нормализации внутреннее произведение равно косинусному сходству.</p>
<p>Более подробную информацию см. в <a href="https://en.wikipedia.org/wiki/Unit_vector">Википедии</a>.</p>
<h4 id="Why-do-Euclidean-distance-L2-and-inner-product-IP-return-different-results" class="common-anchor-header">Почему евклидово расстояние (L2) и внутреннее произведение (IP) дают разные результаты?</h4><p>Для нормализованных векторов евклидово расстояние (L2) математически эквивалентно внутреннему произведению (IP). Если эти метрики сходства дают разные результаты, проверьте, нормализованы ли ваши векторы.</p>
<h4 id="Is-there-a-limit-to-the-total-number-of-collections-and-partitions-in-Milvus" class="common-anchor-header">Существует ли ограничение на общее количество коллекций и разделов в Milvus?</h4><p>Да. Вы можете создать до 65 535 коллекций в экземпляре Milvus. При подсчете количества существующих коллекций Milvus учитывает все коллекции, в которых есть осколки и разделы.</p>
<p>Например, предположим, что вы уже создали 100 коллекций, в 60 из которых есть 2 шарда и 4 раздела, а в остальных 40 коллекциях - 1 шард и 12 разделов. Текущее количество коллекций можно вычислить так:</p>
<pre><code translate="no">60 * 2 * 4 + 40 * 1 * 12 = 960
<button class="copy-code-btn"></button></code></pre>
<h4 id="Why-do-I-get-fewer-than-k-vectors-when-searching-for-topk-vectors" class="common-anchor-header">Почему при поиске векторов по адресу <code translate="no">topk</code> я получаю меньше k векторов?</h4><p>Среди индексов, которые поддерживает Milvus, IVF_FLAT и IVF_SQ8 реализуют метод кластеризации k-means. Пространство данных делится на кластеры <code translate="no">nlist</code>, и вставленные векторы распределяются по этим кластерам. Затем Milvus выбирает ближайшие кластеры <code translate="no">nprobe</code> и сравнивает расстояния между целевым вектором и всеми векторами в выбранных кластерах, получая окончательные результаты.</p>
<p>Если <code translate="no">nlist</code> и <code translate="no">topk</code> велики, а nprobe мало, количество векторов в кластерах nprobe может быть меньше, чем <code translate="no">k</code>. Поэтому при поиске ближайших векторов <code translate="no">topk</code> количество возвращаемых векторов будет меньше, чем <code translate="no">k</code>.</p>
<p>Чтобы избежать этого, попробуйте задать <code translate="no">nprobe</code> больше, а <code translate="no">nlist</code> и <code translate="no">k</code> меньше.</p>
<p>Дополнительные сведения см. в разделе <a href="/docs/ru/v2.4.x/index.md">Индекс вектора</a>.</p>
<h4 id="What-is-the-maximum-vector-dimension-supported-in-Milvus" class="common-anchor-header">Какая максимальная размерность вектора поддерживается в Milvus?</h4><p>По умолчанию Milvus может управлять векторами с размерностью до 32 768. Вы можете увеличить значение <code translate="no">Proxy.maxDimension</code>, чтобы позволить вектору иметь большую размерность.</p>
<h4 id="Does-Milvus-support-Apple-M1-CPU" class="common-anchor-header">Поддерживает ли Milvus процессор Apple M1?</h4><p>Текущий выпуск Milvus не поддерживает процессор Apple M1 напрямую. После выхода Milvus 2.3 Milvus будет предоставлять Docker-образы для архитектуры ARM64.</p>
<h4 id="What-data-types-does-Milvus-support-on-the-primary-key-field" class="common-anchor-header">Какие типы данных поддерживает Milvus для поля первичного ключа?</h4><p>В текущем выпуске Milvus поддерживает INT64 и string.</p>
<h4 id="Is-Milvus-scalable" class="common-anchor-header">Является ли Milvus масштабируемым?</h4><p>Да. Вы можете развернуть кластер Milvus с несколькими узлами с помощью Helm Chart на Kubernetes. Дополнительные инструкции см. в <a href="/docs/ru/v2.4.x/scaleout.md">руководстве по масштабированию</a>.</p>
<h4 id="What-are-growing-segment-and-sealed-segment" class="common-anchor-header">Что такое растущий сегмент и уплотненный сегмент?</h4><p>Когда поступает запрос на поиск, Milvus ищет как инкрементные, так и исторические данные. Инкрементные данные - это недавние обновления, они хранятся в растущих сегментах, которые буферизируются в памяти до того, как они достигнут порога для сохранения в объектном хранилище, и для них строится более эффективный индекс, а исторические данные - это обновления, произошедшие некоторое время назад. Они находятся в запечатанных сегментах, которые были сохранены в объектном хранилище. Инкрементные и исторические данные вместе составляют весь набор данных для поиска. Такая конструкция делает любые данные, поступающие в Milvus, доступными для мгновенного поиска. Для Milvus Distributed существуют более сложные факторы, которые решают, когда только что поступившая запись может появиться в результатах поиска. Подробнее об этом можно узнать на <a href="https://milvus.io/docs/consistency.md">уровнях согласованности</a>.</p>
<h4 id="Is-Milvus-available-for-concurrent-search" class="common-anchor-header">Доступен ли в Milvus параллельный поиск?</h4><p>Да. При запросах по одной и той же коллекции Milvus выполняет одновременный поиск в инкрементных и исторических данных. Однако запросы к разным коллекциям выполняются последовательно. В то время как исторические данные могут представлять собой чрезвычайно огромный набор данных, поиск по историческим данным занимает относительно больше времени и, по сути, выполняется последовательно.</p>
<h4 id="Why-does-the-data-in-MinIO-remain-after-the-corresponding-collection-is-dropped" class="common-anchor-header">Почему данные в MinIO сохраняются после удаления соответствующей коллекции?</h4><p>Данные в MinIO сохраняются в течение определенного периода времени для удобства отката данных.</p>
<h4 id="Does-Milvus-support-message-engines-other-than-Pulsar" class="common-anchor-header">Поддерживает ли Milvus движки сообщений, отличные от Pulsar?</h4><p>Да. Kafka поддерживается в версии Milvus 2.1.0.</p>
<h4 id="Whats-the-difference-between-a-search-and-a-query" class="common-anchor-header">В чем разница между поиском и запросом?</h4><p>В Milvus поиск по векторному сходству извлекает векторы на основе расчета сходства и ускорения векторного индекса. В отличие от поиска по векторному сходству, векторный запрос извлекает векторы с помощью скалярной фильтрации на основе булева выражения. Булево выражение фильтрует скалярные поля или поле первичного ключа и извлекает все результаты, соответствующие фильтрам. В запросе не задействованы ни метрика сходства, ни индекс вектора.</p>
<h4 id="Why-does-a-float-vector-value-have-a-precision-of-7-decimal-digits-in-Milvus" class="common-anchor-header">Почему в Milvus векторное значение float имеет точность 7 десятичных цифр?</h4><p>Milvus поддерживает хранение векторов в виде массивов Float32. Значение Float32 имеет точность 7 десятичных цифр. Даже если значение Float64, например 1.3476964684980388, Milvus сохраняет его как 1.347696. Поэтому, когда вы получаете такой вектор из Milvus, точность значения Float64 теряется.</p>
<h4 id="How-does-Milvus-handle-vector-data-types-and-precision" class="common-anchor-header">Как Milvus работает с типами векторных данных и точностью?</h4><p>Milvus поддерживает векторные типы Binary, Float32, Float16 и BFloat16.</p>
<ul>
<li>Двоичные векторы: Хранят двоичные данные в виде последовательностей 0 и 1, используются в обработке изображений и поиске информации.</li>
<li>Векторы Float32: По умолчанию хранятся с точностью около 7 десятичных цифр. Даже значения Float64 хранятся с точностью Float32, что приводит к возможной потере точности при их извлечении.</li>
<li>Векторы Float16 и BFloat16: Предлагают меньшую точность и меньшее использование памяти. Float16 подходит для приложений с ограниченной пропускной способностью и памятью, в то время как BFloat16 балансирует между дальностью и эффективностью, обычно используется в глубоком обучении для снижения вычислительных требований без существенного влияния на точность.</li>
</ul>
<h4 id="Does-Milvus-support-specifying-default-values-for-scalar-or-vector-fields" class="common-anchor-header">Поддерживает ли Milvus указание значений по умолчанию для скалярных или векторных полей?</h4><p>В настоящее время Milvus 2.4.x не поддерживает указание значений по умолчанию для скалярных или векторных полей. Эта функция запланирована на будущие релизы.</p>
<h4 id="Still-have-questions" class="common-anchor-header">У вас все еще есть вопросы?</h4><p>Вы можете:</p>
<ul>
<li>Ознакомиться с <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> на GitHub. Вы можете задавать вопросы, делиться идеями и помогать другим.</li>
<li>Присоединяйтесь к нашему <a href="https://discord.com/invite/8uyFbECzPX">серверу Discord</a>, чтобы найти поддержку и принять участие в работе нашего сообщества разработчиков с открытым исходным кодом.</li>
</ul>
